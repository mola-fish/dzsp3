/**
 * Cegore
 *
 * 根命名空间，所有Cegore库都会存在于该命名空间
 */
var Cegore;
(function (Cegore) {
    Cegore.Version = 103;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */
/*
 * File of Class TypeCheck
 */
var Cegore;
(function (Cegore) {
    /**
     * 类 TypeCheck
     *
     * 用于JavaScript 类型检查
     *
     */
    class TypeCheck {
        /**
         * 返回值或者默认值
         *
         * 判断一个值是否定义，如果定义则，返回这个值，否则返回默认值
         *
         * @param value 待判断的值
         * @param default 默认值
         */
        static defaultValue(value, defaut) {
            if (value !== undefined && value !== null) {
                return value;
            }
            return defaut;
        }
        /**
         * 判断一个变量是否定义
         *
         * @param value 代判断的值
         * @returns 是否定义
         */
        static isDefined(value) {
            return value !== undefined && value !== null;
        }
        /**
         * 判断一个变量是否为null
         */
        static isNull(value) {
            return value === null;
        }
        /**
         * 这是一个修正的 typeof运算符
         *
         * Undefined 返回 'undefined'
         * null 返回 'null'
         * Boolean 返回 'boolean'
         * Number 返回 'number'
         * String 返回 'string'
         * Symbol 返回 'symbol'
         * 函数   返回  'function'
         * 数组   返回 'array'
         * Object 返回  'object'
         * @param value 带判断类型的值
         * @return 类型名称
         */
        static typeOf(value) {
            var s = typeof value;
            if (s == 'object') {
                if (value) {
                    // Check these first, so we can avoid calling Object.prototype.toString if
                    // possible.
                    //
                    // IE improperly marshals typeof across execution contexts, but a
                    // cross-context object will still return false for "instanceof Object".
                    if (value instanceof Array) {
                        return 'array';
                    }
                    else if (value instanceof Object) {
                        return s;
                    }
                    // HACK: In order to use an Object prototype method on the arbitrary
                    //   value, the compiler requires the value be cast to type Object,
                    //   even though the ECMA spec explicitly allows it.
                    var className = Object.prototype.toString.call(/** @type {!Object} */ (value));
                    // In Firefox 3.6, attempting to access iframe window objects' length
                    // property throws an NS_ERROR_FAILURE, so we need to special-case it
                    // here.
                    if (className == '[object Window]') {
                        return 'object';
                    }
                    // We cannot always use constructor == Array or instanceof Array because
                    // different frames have different Array objects. In IE6, if the iframe
                    // where the array was created is destroyed, the array loses its
                    // prototype. Then dereferencing val.splice here throws an exception, so
                    // we can't use isFunction. Calling typeof directly returns 'unknown'
                    // so that will work. In this case, this function will return false and
                    // most array functions will still work because the array is still
                    // array-like (supports length and []) even though it has lost its
                    // prototype.
                    // Mark Miller noticed that Object.prototype.toString
                    // allows access to the unforgeable [[Class]] property.
                    //  15.2.4.2 Object.prototype.toString ( )
                    //  When the toString method is called, the following steps are taken:
                    //      1. Get the [[Class]] property of this object.
                    //      2. Compute a string value by concatenating the three strings
                    //         "[object ", Result(1), and "]".
                    //      3. Return Result(2).
                    // and this behavior survives the destruction of the execution context.
                    if ((className == '[object Array]' ||
                        // In IE all non value types are wrapped as objects across window
                        // boundaries (not iframe though) so we have to do object detection
                        // for this edge case.
                        typeof value.length == 'number' &&
                            typeof value.splice != 'undefined' &&
                            typeof value.propertyIsEnumerable != 'undefined' &&
                            !value.propertyIsEnumerable('splice'))) {
                        return 'array';
                    }
                    // HACK: There is still an array case that fails.
                    //     function ArrayImpostor() {}
                    //     ArrayImpostor.prototype = [];
                    //     var impostor = new ArrayImpostor;
                    // this can be fixed by getting rid of the fast path
                    // (value instanceof Array) and solely relying on
                    // (value && Object.prototype.toString.vall(value) === '[object Array]')
                    // but that would require many more function calls and is not warranted
                    // unless closure code is receiving objects from untrusted sources.
                    // IE in cross-window calls does not correctly marshal the function type
                    // (it appears just as an object) so we cannot use just typeof val ==
                    // 'function'. However, if the object has a call property, it is a
                    // function.
                    if ((className == '[object Function]' ||
                        typeof value.call != 'undefined' &&
                            typeof value.propertyIsEnumerable != 'undefined' &&
                            !value.propertyIsEnumerable('call'))) {
                        return 'function';
                    }
                }
                else {
                    return 'null';
                }
            }
            else if (s == 'function' && typeof value.call == 'undefined') {
                // In Safari typeof nodeList returns 'function', and on Firefox typeof
                // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
                // would like to return object for those and we can detect an invalid
                // function by making sure that the function object has a call method.
                return 'object';
            }
            return s;
        }
        /**
         * 判断是否为函数
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个函数，否则false.
         */
        static isFunction(value) {
            return (typeof value === 'function');
        }
        /**
         * 判断是否为函数
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isString(value) {
            return (typeof value === 'string');
        }
        /**
         * 判断是否为数字
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isNumber(value) {
            return (typeof value === 'number');
        }
        /**
         * 判断是否为对象
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isObject(value) {
            var type = typeof value;
            return type == 'object' && value != null || type == 'function';
        }
        /**
         * 判断是否为布尔值
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isBool(value) {
            return (typeof value === 'boolean');
        }
        /**
         * 判断是否为数组
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isArray(value) {
            return TypeCheck.typeOf(value) == 'array';
        }
        /**
         * 判断是否为某类型
         *
         * @param val
         * @param type
         */
        static isInstanceOf(val, type) {
            return val instanceof type;
        }
        /**
         * 冻结对象
         *
         * 同Object.freeze，兼容不支持该接口的浏览器
         * @param o 要冻结的对象
         * @return 冻结后的对象
         */
        static freezeObject(o) {
            return TypeCheck._freezeObject(o);
        }
    }
    /// 
    TypeCheck._freezeObject = Object.freeze ? Object.freeze : function (o) { return o; };
    Cegore.TypeCheck = TypeCheck;
})(Cegore || (Cegore = {}));
/*
 * File of Class Map<T>
 */
var Cegore;
(function (Cegore) {
    /**
     * 提供Map容器的基本功能
     */
    class HashMap {
        /**
         * 构造一个新的Map<T>对象
         * @param creator 构造器，当获取的值不存在时，且没有指定默认值，则通过构造器创建默认值
         */
        constructor(creator) {
            this._data = {};
            this._creator = null;
            this._creator = creator;
        }
        /**
         * 获取值
         *
         * @param {string} key 要获取的key值
         * @param {T} def 当获取的值为null时，指定默认值
         *
         * @return {T} 返回获取到的值或者 undefined
         */
        getOrCreate(key, def) {
            var item = this._data[key];
            if (Cegore.TypeCheck.isDefined(item)) {
                return item.val;
            }
            /// 当指定了默认值def时，添加并返回默认值
            if (Cegore.TypeCheck.isDefined(def)) {
                item = { val: def };
                ///
                this._data[key] = item;
                return item.val;
            }
            if (Cegore.TypeCheck.isDefined(this._creator)) {
                item = { val: this._creator() };
                ///
                this._data[key] = item;
                return item.val;
            }
            ///
            return undefined;
        }
        /**
         * 获取 Map 中键为 key的对象
         * @param key 键值
         * @return {any|undefined}
         */
        get(key) {
            var item = this._data[key];
            if (Cegore.TypeCheck.isDefined(item)) {
                return item.val;
            }
            return;
        }
        /**
         * 设置值
         *
         * @param {string} key 设置的key值
         * @param {T} val 设置的val值
         */
        put(key, val) {
            this._data[key] = { val: val };
        }
        /**
         * 根据值获取对应的key
         *
         * @param {T} val 要获取key 的值对象
         */
        key(val) {
            for (var key in this._data) {
                if (this._data[key].val === val) {
                    return key;
                }
            }
            ///
            return;
        }
        /**
         * 获取所有的key
         */
        keys() {
            var keys = [];
            for (var key in this._data) {
                keys.push(key);
            }
            return keys;
        }
        /**
         * 判断指定的元素是否存在
         */
        exist(key) {
            return Cegore.TypeCheck.isDefined(this._data[key]);
        }
        /**
         * 移除指定的元素
         */
        remove(key) {
            delete this._data[key];
        }
        /**
         * 移除所有元素
         */
        clear() {
            this._data = {};
        }
        /**
         * 移除所有元素
         */
        removeAll() {
            this.clear();
        }
    }
    Cegore.HashMap = HashMap;
})(Cegore || (Cegore = {}));
/*
 * File LongEx.ts
 */
var Cegore;
(function (Cegore) {
    /**
     * 字符串处理辅助类
     */
    class StringUtil {
        /**
         * 判断一个字符串是否以指定的字符串开始
         *
         * @param str 待判断的字符串
         * @param pattern 字符串样式
         * @param ignoreCase 是否忽略大小写
         */
        static startsWidth(str, pattern, ignoreCase) {
            /// 线比较字符串长度
            var thisLen = this.length;
            var patternLen = pattern.length;
            if (thisLen < patternLen || patternLen == 0)
                return false;
            /// 获取和 匹配字符串等长的字符
            var startOfThis = str.substr(0, patternLen);
            /// 是否转为小写
            if (ignoreCase) {
                startOfThis = startOfThis.toLowerCase();
                pattern = pattern.toLowerCase();
            }
            ///
            return (startOfThis === pattern);
        }
        /**
         * 判断一个字符串是否以指定的字符串结束
         *
         * @param str 待判断的字符串
         * @param pattern 字符串样式
         * @param ignoreCase 是否忽略大小写
         */
        static endsWidth(str, pattern, ignoreCase) {
            /// 线比较字符串长度
            var thisLen = this.length;
            var patternLen = pattern.length;
            if (thisLen < patternLen || patternLen == 0)
                return false;
            /// 获取和 匹配字符串等长的字符
            var endOfThis = str.substr(thisLen - patternLen, patternLen);
            /// 是否转为小写
            if (ignoreCase) {
                endOfThis = endOfThis.toLowerCase();
                pattern = pattern.toLowerCase();
            }
            ///
            return (endOfThis === pattern);
        }
        /**
         * 解析整数，js parseInt函数的增强版
         *      解析输入数据为一个整数
         *      如果输入值不是一个数值，则返回默认值
         *      如果未指定默认值，则返回0
         *
         * @param {String} value 要解析的对象
         * @param {Number} def 默认值
         * @param [Number] radix 可选。表示要解析的数字的基数。
         */
        static parseInt(value, def, radix) {
            let ret = parseInt(value, radix);
            if (!isNaN(ret))
                return ret;
            if (Cegore.TypeCheck.isDefined(def))
                return def;
            return 0;
        }
        /**
         * 解析整数，js parseFloat函数的增强版
         *      解析输入数据为一个整数
         *      如果输入值不是一个数值，则返回默认值
         *      如果未指定默认值，则返回0
         *
         * @param {String|any} value 要解析的对象
         * @param {Number} def 默认值
         */
        static parseFloat(value, def) {
            let ret = parseFloat(value);
            if (!isNaN(ret))
                return ret;
            if (Cegore.TypeCheck.isDefined(def))
                return def;
            return 0;
        }
        /**
         * 对象转Post请求的body
         * @param data
         * @returns
         */
        static toPostFormBody(data) {
            const body = [];
            for (let key in data) {
                body.push(`${key}=${encodeURIComponent(data[key])}`);
            }
            return body.join('&');
        }
    }
    Cegore.StringUtil = StringUtil;
})(Cegore || (Cegore = {}));
/**
 * End of file
 */ 
/*
 * File of class ArrayUtil
 */
var Cegore;
(function (Cegore) {
    /**
     * @class
     */
    class ArrayUtil {
        /**
         * 查找数组，但可以自定义比较函数
         * @param item 查询的对象
         * @param array 查询到数组
         * @param cmp 比较函数
         */
        static indexOf(item, array, cmp) {
            if (!Cegore.TypeCheck.isFunction(cmp)) {
                throw "cmp must be function.";
            }
            for (let i = 0; i < array.length; ++i) {
                if (cmp(array[i], item)) {
                    return i;
                }
            }
            return -1;
        }
    }
    /**
     * 一个空的数组，不可修改
     */
    ArrayUtil.EmptyArray = Cegore.TypeCheck.freezeObject([]);
    Cegore.ArrayUtil = ArrayUtil;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class LoadWithXhr
 */
var Cegore;
(function (Cegore) {
    /**
     * 使用 xhr 加载数据
     */
    class LoadWithXhr {
        static loadWithXhr(options) {
            LoadWithXhr.onPromise(Cesium.Resource.fetch(options), options);
        }
        /**
         * 使用xhr加载json数据
         *
         * @param options
         */
        static loadJSON(options) {
            LoadWithXhr.onPromise(Cesium.Resource.fetchJson(options.url), options);
        }
        static onPromise(promise, options) {
            if (!Cegore.TypeCheck.isDefined(promise))
                return;
            if (Cegore.TypeCheck.isFunction(options.success))
                promise.then(options.success);
            if (Cegore.TypeCheck.isFunction(options.error))
                promise.otherwise(options.error);
        }
    }
    Cegore.LoadWithXhr = LoadWithXhr;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
var Cegore;
(function (Cegore) {
    class DOM {
        static createContext2D(width, height) {
            var canvas = document.createElement('CANVAS');
            ///
            if (width)
                canvas.width = width;
            if (height)
                canvas.height = height;
            return canvas.getContext('2d');
        }
    }
    Cegore.DOM = DOM;
})(Cegore || (Cegore = {}));
/*
 * File of class Vector2
 */
var Cegore;
(function (Cegore) {
    /**
     * 一个二维的点或者向量
     */
    class Vector2 {
        constructor(v0, v1) {
            /**
             * x坐标值
             */
            this.x = 0.0;
            /**
             * y坐标值
             */
            this.y = 0.0;
            this.set(v0, v1);
        }
        /**
         * 获取当前向量的长度（点到原点的距离）
         */
        get length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        /**
         * 向量的权重，同length
         */
        get magnitude() { return this.length; }
        /**
         * 获取向量长度的平方，用于不需要知道实际长度的情况下，避免进行开方运算
         */
        get squaredLength() { return this.x * this.x + this.y * this.y; }
        set(v0, v1) {
            let x, y;
            switch (Cegore.TypeCheck.typeOf(v0)) {
                case 'number':
                    x = v0;
                    y = v1;
                    break;
                case 'array':
                    x = v0[0];
                    y = v0[1];
                    break;
                case 'object':
                    x = v0.x;
                    y = v0.y;
                    break;
            }
            this.x = Cegore.StringUtil.parseFloat(x);
            this.y = Cegore.StringUtil.parseFloat(y);
        }
        /**
         * 复制当前对象
         * @param result 一个可选的参数，用来存储输出结果
         * @returns 复制的对象
         */
        clone(result) {
            return Vector2.clone(this, result);
        }
        /**
         * 判断当前对象和指定的对象是否相等
         * @param right
         */
        equals(right) {
            return Vector2.equals(this, right);
        }
        /**
         * 返回如下格式的字符串 '(x,y)'
         */
        toString() {
            return '(' + this.x + ',' + this.y + ')';
        }
        /**
         * @private
         */
        _asCzVector2() {
            return new Cesium.Cartesian2(this.x, this.y);
        }
        /**
         * 计算两个向量的距离
         * @param left
         * @param right
         */
        static distance(left, right) {
            return Math.sqrt(Vector2.squaredDistance(left, right));
        }
        /**
         * 计算两个向量距离的平方
         * @param left
         * @param right
         */
        static squaredDistance(left, right) {
            let x = left.x - right.x;
            let y = left.y - right.y;
            return x * x + y * y;
        }
        /**
         * 复制传入的对象
         * @param target 要复制的对象
         * @param result 可选的对象，用于存储复制结果
         */
        static clone(target, result) {
            return Vector2.newOrResult(target.x, target.y, result);
        }
        /**
         * 比较两个对象是否相等
         */
        static equals(left, right) {
            return (left === right) ||
                ((Cegore.TypeCheck.isDefined(left)) &&
                    (Cegore.TypeCheck.isDefined(right)) &&
                    (left.x === right.x) &&
                    (left.y === right.y));
        }
        /**
         * 计算两个向量的和
         * @param left
         * @param right
         * @param result
         */
        static add(left, right, result) {
            return Vector2.newOrResult(left.x + right.x, left.y + right.y, result);
        }
        /**
         * 计算两个向量的差
         * @param left
         * @param right
         * @param result
         */
        static sub(left, right, result) {
            return Vector2.newOrResult(left.x - right.x, left.y - right.y, result);
        }
        static mul(left, right, result) {
            if (Cegore.TypeCheck.isNumber(right))
                return Vector2.newOrResult(left.x * right, left.y * right, result);
            if (Cegore.TypeCheck.isInstanceOf(right, Vector2))
                return Vector2.newOrResult(left.x * right.x, left.y * right.y, result);
            throw "unknown param right.";
        }
        static div(left, right, result) {
            if (Cegore.TypeCheck.isNumber(right))
                return Vector2.newOrResult(left.x / right, left.y / right, result);
            if (Cegore.TypeCheck.isInstanceOf(right, Vector2))
                return Vector2.newOrResult(left.x / right.x, left.y / right.y, result);
            throw "unknown param right.";
        }
        /**
         * 对当前向量取反
         * @param target
         * @param result
         */
        static negate(target, result) {
            return Vector2.newOrResult(-target.x, -target.y, result);
        }
        /**
         * 计算两个向量的点积（点乘）
         * @param left
         * @param right
         */
        static dot(left, right) {
            return left.x * right.x + left.y * right.y;
        }
        /**
         * 计算两个向量的叉积（叉乘）
         * @param left
         * @param right
         */
        static cross(left, right, result) {
            return Vector2.newOrResult(-right.y, right.x, result);
        }
        /**
         * 归一化向量
         * @param target
         * @param result
         */
        static normalize(target, result) {
            let fLength = target.length;
            // Will also work for zero-sized vectors, but will change nothing
            let x = target.x, y = target.y;
            if (fLength > 1e-08) {
                fLength = 1.0 / fLength;
                x *= fLength;
                y *= fLength;
            }
            return Vector2.newOrResult(x, y, result);
        }
        /**
         * 计算两个点的中点
         * @param left
         * @param right
         * @param result
         */
        static middle(left, right, result) {
            return Vector2.newOrResult((left.x + right.x) * 0.5, (left.y + right.y) * 0.5, result);
        }
        /**
         * 计算两个向量每个分量的最小值
         * @param left
         * @param right
         * @param result
         */
        static floor(left, right, result) {
            let x = left.x < right.x ? left.x : right.x;
            let y = left.y < right.y ? left.y : right.y;
            return Vector2.newOrResult(x, y, result);
        }
        /**
         * 计算两个向量每个分量的最大值
         * @param left
         * @param right
         * @param result
         */
        static ceil(left, right, result) {
            let x = left.x > right.x ? left.x : right.x;
            let y = left.y > right.y ? left.y : right.y;
            return Vector2.newOrResult(x, y, result);
        }
        /**
         * 对两个向量进行插值
         * @param start 起点
         * @param end 终点
         * @param t 插值参数，介于[0,1]之间
         * @param result
         */
        static lerp(start, end, t, result) {
            t = Cegore.GeoMath.clamp(t, 0, 1);
            Vector2.mul(start, 1 - t, Vector2._LerpStart);
            Vector2.mul(end, t, Vector2._LerpEnd);
            return Vector2.add(Vector2._LerpStart, Vector2._LerpEnd, result);
        }
        /**
         * 计算两个向量之间的夹角，返回弧度
         * @param start
         * @param end
         */
        static angle(start, end) {
            Vector2.normalize(start, Vector2._AngleStart);
            Vector2.normalize(end, Vector2._AngleEnd);
            return Cegore.GeoMath.acosClamped(Vector2.dot(Vector2._AngleStart, Vector2._AngleEnd));
        }
        /**
         * 构造新对象或者使用旧对象
         * @param x
         * @param y
         * @param result
         */
        static newOrResult(x, y, result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Vector2)) {
                return new Vector2(x, y);
            }
            result.x = x;
            result.y = y;
            return result;
        }
    }
    Vector2._LerpStart = new Vector2();
    Vector2._LerpEnd = new Vector2();
    /**
     * 向量（0,0）
     */
    Vector2.ZERO = Cegore.TypeCheck.freezeObject(new Vector2(0, 0));
    /**
     * 向量（1,1），单位向量
     */
    Vector2.UNIT = Cegore.TypeCheck.freezeObject(new Vector2(1, 1));
    /**
     * 向量（1,0）
     */
    Vector2.UNIT_X = Cegore.TypeCheck.freezeObject(new Vector2(1, 0));
    /**
     * 向量（0,1）
     */
    Vector2.UNIT_Y = Cegore.TypeCheck.freezeObject(new Vector2(0, 1));
    Cegore.Vector2 = Vector2;
})(Cegore || (Cegore = {}));
/*
 * File of class Vector3
 */
var Cegore;
(function (Cegore) {
    /**
     * 一个三维的点或者向量
     */
    class Vector3 {
        constructor(v0, v1, v2) {
            /**
             * x坐标值
             */
            this.x = 0.0;
            /**
             * y坐标值
             */
            this.y = 0.0;
            /**
             * z坐标值
             */
            this.z = 0.0;
            this.set(v0, v1, v2);
        }
        /**
         * 获取当前向量的长度（点到原点的距离）
         */
        get length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        /**
         * 向量的权重，同length
         */
        get magnitude() { return this.length; }
        /**
         * 获取向量长度的平方，用于不需要知道实际长度的情况下，避免进行开方运算
         */
        get squaredLength() { return this.x * this.x + this.y * this.y + this.z * this.z; }
        set(v0, v1, v2) {
            let x, y, z;
            switch (Cegore.TypeCheck.typeOf(v0)) {
                case 'number':
                    x = v0;
                    y = v1;
                    z = v2;
                    break;
                case 'array':
                    x = v0[0];
                    y = v0[1];
                    z = v0[2];
                    break;
                case 'object':
                    x = v0.x;
                    y = v0.y;
                    z = v0.z;
                    break;
            }
            this.x = Cegore.StringUtil.parseFloat(x);
            this.y = Cegore.StringUtil.parseFloat(y);
            this.z = Cegore.StringUtil.parseFloat(z);
        }
        /**
         * 复制当前对象
         * @param result 一个可选的参数，用来存储输出结果
         * @returns 复制的对象
         */
        clone(result) {
            return Vector3.clone(this, result);
        }
        /**
         * 判断当前对象和指定的对象是否相等
         * @param right
         */
        equals(right) {
            return Vector3.equals(this, right);
        }
        /**
         * 返回如下格式的字符串 '(x,y,z)'
         */
        toString() {
            return '(' + this.x + ',' + this.y + ',' + this.z + ')';
        }
        /**
         * @private
         */
        _asCzVector3() {
            return new Cesium.Cartesian3(this.x, this.y, this.z);
        }
        /**
         * 计算两个向量的距离
         * @param left
         * @param right
         */
        static distance(left, right) {
            return Math.sqrt(Vector3.squaredDistance(left, right));
        }
        /**
         * 计算两个向量距离的平方
         * @param left
         * @param right
         */
        static squaredDistance(left, right) {
            let x = left.x - right.x;
            let y = left.y - right.y;
            let z = left.z - right.z;
            return x * x + y * y + z * z;
        }
        /**
         * 复制传入的对象
         * @param target 要复制的对象
         * @param result 可选的对象，用于存储复制结果
         */
        static clone(target, result) {
            return Vector3.newOrResult(target.x, target.y, target.z, result);
        }
        /**
         * 比较两个对象是否相等
         */
        static equals(left, right) {
            return (left === right) ||
                ((Cegore.TypeCheck.isDefined(left)) &&
                    (Cegore.TypeCheck.isDefined(right)) &&
                    (left.x === right.x) &&
                    (left.y === right.y) &&
                    (left.z === right.z));
        }
        /**
         * 计算两个向量的和
         * @param left
         * @param right
         * @param result
         */
        static add(left, right, result) {
            return Vector3.newOrResult(left.x + right.x, left.y + right.y, left.z + right.z, result);
        }
        /**
         * 计算两个向量的差
         * @param left
         * @param right
         * @param result
         */
        static sub(left, right, result) {
            return Vector3.newOrResult(left.x - right.x, left.y - right.y, left.z - right.z, result);
        }
        static mul(left, right, result) {
            if (Cegore.TypeCheck.isNumber(right))
                return Vector3.newOrResult(left.x * right, left.y * right, left.z * right, result);
            if (Cegore.TypeCheck.isInstanceOf(right, Vector3))
                return Vector3.newOrResult(left.x * right.x, left.y * right.y, left.z * right.z, result);
            throw "unknown param right.";
        }
        static div(left, right, result) {
            if (Cegore.TypeCheck.isNumber(right))
                return Vector3.newOrResult(left.x / right, left.y / right, left.z / right, result);
            if (Cegore.TypeCheck.isInstanceOf(right, Vector3))
                return Vector3.newOrResult(left.x / right.x, left.y / right.y, left.z / right.z, result);
            throw "unknown param right.";
        }
        /**
         * 对当前向量取反
         * @param target
         * @param result
         */
        static negate(target, result) {
            return Vector3.newOrResult(-target.x, -target.y, -target.z, result);
        }
        /**
         * 计算两个向量的点积（点乘）
         * @param left
         * @param right
         */
        static dot(left, right) {
            return left.x * right.x + left.y * right.y + left.z * right.z;
        }
        /**
         * 计算两个向量的叉积（叉乘）
         * @param left
         * @param right
         */
        static cross(left, right, result) {
            let x = left.y * right.z - left.z * right.y;
            let y = left.z * right.x - left.x * right.z;
            let z = left.x * right.y - left.y * right.x;
            return Vector3.newOrResult(x, y, z, result);
        }
        /**
         * 归一化向量
         * @param target
         * @param result
         */
        static normalize(target, result) {
            let fLength = target.length;
            // Will also work for zero-sized vectors, but will change nothing
            let x = target.x, y = target.y, z = target.z;
            if (fLength > 1e-08) {
                fLength = 1.0 / fLength;
                x *= fLength;
                y *= fLength;
                z *= fLength;
            }
            return Vector3.newOrResult(x, y, z, result);
        }
        /**
         * 计算两个点的中点
         * @param left
         * @param right
         * @param result
         */
        static middle(left, right, result) {
            return Vector3.newOrResult((left.x + right.x) * 0.5, (left.y + right.y) * 0.5, (left.z + right.z) * 0.5, result);
        }
        /**
         * 计算两个向量每个分量的最小值
         * @param left
         * @param right
         * @param result
         */
        static floor(left, right, result) {
            let x = left.x < right.x ? left.x : right.x;
            let y = left.y < right.y ? left.y : right.y;
            let z = left.z < right.z ? left.z : right.z;
            return Vector3.newOrResult(x, y, z, result);
        }
        /**
         * 计算两个向量每个分量的最大值
         * @param left
         * @param right
         * @param result
         */
        static ceil(left, right, result) {
            let x = left.x > right.x ? left.x : right.x;
            let y = left.y > right.y ? left.y : right.y;
            let z = left.z > right.z ? left.z : right.z;
            return Vector3.newOrResult(x, y, z, result);
        }
        /**
         * 对两个向量进行插值
         * @param start 起点
         * @param end 终点
         * @param t 插值参数，介于[0,1]之间
         * @param result
         */
        static lerp(start, end, t, result) {
            t = Cegore.GeoMath.clamp(t, 0, 1);
            Vector3.mul(start, 1 - t, Vector3._LerpStart);
            Vector3.mul(end, t, Vector3._LerpEnd);
            return Vector3.add(Vector3._LerpStart, Vector3._LerpEnd, result);
        }
        /**
         * 计算两个向量之间的夹角，返回弧度
         * @param start
         * @param end
         */
        static angle(start, end) {
            Vector3.normalize(start, Vector3._AngleStart);
            Vector3.normalize(end, Vector3._AngleEnd);
            var cosine = Vector3.dot(Vector3._AngleStart, Vector3._AngleEnd);
            var cross = Vector3.cross(Vector3._AngleStart, Vector3._AngleEnd, Vector3._AngleCross);
            var sine = cross.length;
            return Math.atan2(sine, cosine);
        }
        /**
         * 构造新对象或者使用旧对象
         * @param x
         * @param y
         * @param result
         */
        static newOrResult(x, y, z, result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Vector3)) {
                return new Vector3(x, y, z);
            }
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
    }
    Vector3._LerpStart = new Vector3();
    Vector3._LerpEnd = new Vector3();
    /**
     * 向量（0,0）
     */
    Vector3.ZERO = Cegore.TypeCheck.freezeObject(new Vector3(0, 0, 0));
    /**
     * 向量（1,1），单位向量
     */
    Vector3.UNIT = Cegore.TypeCheck.freezeObject(new Vector3(1, 1, 1));
    /**
     * 向量（1,0）
     */
    Vector3.UNIT_X = Cegore.TypeCheck.freezeObject(new Vector3(1, 0, 0));
    /**
     * 向量（0,1）
     */
    Vector3.UNIT_Y = Cegore.TypeCheck.freezeObject(new Vector3(0, 1, 0));
    /**
     * 向量（0,0,1）
     */
    Vector3.UNIT_Z = Cegore.TypeCheck.freezeObject(new Vector3(0, 0, 1));
    Cegore.Vector3 = Vector3;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Position
 */
var Cegore;
(function (Cegore) {
    /**
     * 表示一个位置
     *
     * 该类封装了一个位置信息，表示空间上的一个某一点
     */
    class Position {
        /**
         * 构造一个新的LongLat对象
         */
        constructor(p0, p1, p2) {
            this.set(p0, p1, p2);
        }
        /**
         * 获取经度值
         */
        get lon() { return this._x; }
        /**
         * 获取纬度值
         */
        get lat() { return this._y; }
        /**
         * 获取高程
         */
        get altitude() { return this._z; }
        /**
         * 设置经度
         */
        set lon(value) { this._x = Cegore.StringUtil.parseFloat(value); }
        /**
         * 设置纬度
         */
        set lat(value) { this._y = Cegore.StringUtil.parseFloat(value); }
        /**
         * 设置高程
         */
        set altitude(value) { this._z = Cegore.StringUtil.parseFloat(value); }
        /**
         * 获取x坐标，同lon
         */
        get x() { return this.lon; }
        /**
         * 设置x坐标，同lon=val
         */
        set x(val) { this.lon = val; }
        /**
         * 获取y坐标，同lat
         */
        get y() { return this.lat; }
        /**
         * 设置y坐标，同lat=val
         */
        set y(val) { this.lat = val; }
        /**
         * 获取z坐标，同altitude
         */
        get z() { return this.altitude; }
        /**
         * 设置z坐标，同altitude=val
         */
        set z(val) { this.altitude = val; }
        set(p0, p1, p2) {
            let x, y, z;
            if (p0 instanceof Cesium.Cartesian3) {
                p0 = Cesium.Cartographic.fromCartesian(p0);
            }
            if (p0 instanceof Cesium.Cartographic) {
                x = Cegore.GeoMath.toDegree(p0.longitude);
                y = Cegore.GeoMath.toDegree(p0.latitude);
                z = p0.height;
            }
            else {
                const v0 = p0;
                switch (Cegore.TypeCheck.typeOf(p0)) {
                    case 'array': {
                        x = p0[0];
                        y = p0[1];
                        z = p0[2];
                        break;
                    }
                    case 'object': {
                        x = v0.x;
                        y = v0.y;
                        z = v0.z;
                        break;
                    }
                    case 'number':
                    case 'string': {
                        x = Cegore.StringUtil.parseFloat(p0);
                        y = Cegore.StringUtil.parseFloat(p1);
                        z = Cegore.StringUtil.parseFloat(p2);
                        break;
                    }
                }
            }
            this.lon = Cegore.TypeCheck.defaultValue(x, 0);
            this.lat = Cegore.TypeCheck.defaultValue(y, 0);
            this.altitude = Cegore.TypeCheck.defaultValue(z, 0);
            ;
        }
        static from(p0, p1, p2) {
            if (Cegore.TypeCheck.isInstanceOf(p0, Position))
                return p0;
            return new Position(p0, p1, p2);
        }
        /**
         * 解析点字符串
         * @param lineStr 点位字符串，格式 'x,y,z|x,y,z|...';
         */
        static parsePoints(lineStr) {
            let lonlats = [];
            let pts = lineStr.split('|');
            for (let i = 0; i < pts.length; ++i) {
                let pt = pts.split(',');
                lonlats.push(pt[0], pt[1], pt[2]);
            }
            ///
            return lonlats;
        }
    }
    Cegore.Position = Position;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Rectangle
 */
var Cegore;
(function (Cegore) {
    /**
     * 一个二维的矩形区域
     *
     * Rectangle可以表述一个地理坐标（经纬度），也可以表示一个二维平面坐标
     * 在表示地理坐标的时候和二维平面坐标的时候某些行为有些不同，
     * 因为地理坐标系在经度方向上是循环连续的（-180和180的位置重合），
     * 所以在使用上需要注意。
     */
    class Rectangle {
        constructor(v1, v2, v3, v4, v5) {
            /**
             * x 的最小值
             */
            this._minx = 0.0;
            /**
             * y 的最小值
             */
            this._miny = 0.0;
            /**
             * x 的最大值
             */
            this._maxx = 0.0;
            /**
             * y 的最大值
             */
            this._maxy = 0.0;
            /**
             * 是否为空矩形
             */
            this._isEmpty = true;
            /**
             * 是否地理坐标
             */
            this._isGeographical = true;
            let type = Cegore.TypeCheck.typeOf(v1);
            if (type === 'number') {
            }
            else if (type === 'array') {
                let array = v1;
                v5 = v2;
                v1 = array[0];
                v2 = array[1];
                v3 = array[2];
                v4 = array[3];
            }
            else if (Cegore.TypeCheck.isInstanceOf(v1, Cesium.Rectangle)) {
                let rc = v1;
                v1 = Cegore.GeoMath.toDegree(rc.west);
                v2 = Cegore.GeoMath.toDegree(rc.south);
                v3 = Cegore.GeoMath.toDegree(rc.east);
                v4 = Cegore.GeoMath.toDegree(rc.north);
            }
            else if (type === 'object') {
                let obj = v1;
                v5 = v2;
                if (Cegore.TypeCheck.isDefined(v1.minx)) {
                    v1 = obj.minx;
                    v2 = obj.miny;
                    v3 = obj.maxx;
                    v4 = obj.maxy;
                }
                else if (Cegore.TypeCheck.isDefined(v1.west)) {
                    v1 = obj.west;
                    v2 = obj.south;
                    v3 = obj.east;
                    v4 = obj.north;
                }
                else if (Cegore.TypeCheck.isDefined(v1.left)) {
                    v1 = obj.left;
                    v2 = obj.bottom;
                    v3 = obj.right;
                    v4 = obj.top;
                }
            }
            else if (type === 'boolean') {
                v5 = v1;
            }
            else {
                /// empty
                return;
            }
            this._minx = Cegore.TypeCheck.defaultValue(v1, 0.0);
            this._miny = Cegore.TypeCheck.defaultValue(v2, 0.0);
            this._maxx = Cegore.TypeCheck.defaultValue(v3, 0.0);
            this._maxy = Cegore.TypeCheck.defaultValue(v4, 0.0);
            this._isGeographical = Cegore.TypeCheck.defaultValue(v5, true);
            this._isEmpty = false;
        }
        /**
         * 获取minx
         */
        get minx() { return this._isEmpty ? 0.0 : this._minx; }
        /**
         * 设置minx，如果当前是地理坐标，则只能设置为 [-180,180] 之间
         */
        set minx(val) {
            this._minx = this._isGeographical ? Rectangle.normalizeLongitude(val) : val;
            this._isEmpty = false;
        }
        /**
         * 获取maxx
         */
        get maxx() { return this._isEmpty ? 0.0 : this._maxx; }
        /**
         * 设置maxx，如果当前是地理坐标，则只能设置为 [-180,180] 之间
         */
        set maxx(val) {
            this._maxx = this._isGeographical ? Rectangle.normalizeLongitude(val) : val;
            this._isEmpty = false;
        }
        /**
         * 获取miny
         */
        get miny() { return this._isEmpty ? 0.0 : this._miny; }
        /**
         * 设置miny，如果当前是地理坐标，则只能设置为 [-90,90] 之间
         */
        set miny(val) {
            this._miny = this._isGeographical ? Rectangle.normalizeLatitude(val) : val;
            this._isEmpty = false;
        }
        /**
         * 获取maxy
         */
        get maxy() { return this._isEmpty ? 0.0 : this._maxy; }
        /**
         * 设置maxy，如果当前是地理坐标，则只能设置为 [-90,90] 之间
         */
        set maxy(val) {
            this._maxy = this._isGeographical ? Rectangle.normalizeLatitude(val) : val;
            this._isEmpty = false;
        }
        /**
         * 获取当前矩形是否为<空>
         */
        get empty() { return this._isEmpty; }
        /**
         * 设置当前矩形是否为<空>
         */
        set empty(empty) { this._isEmpty = empty; }
        /**
         * 返回当前对象是否是表示的是地理坐标
         */
        get isGeographical() { return this._isGeographical; }
        /**
         * 获取矩形的宽度
         */
        get width() {
            return this.maxx - this.minx;
        }
        /**
         * 获取矩形的高度
         */
        get height() { return this.maxy - this.miny; }
        /**
         * 获取最西边的值，等同于minx
         */
        get west() { return this.minx; }
        /**
         * 设置最西边的值，等永远minx = val
         */
        set west(val) { this.minx = val; }
        /**
         * 获取最东边的值，等永远maxx
         */
        get east() { return this.maxx; }
        /**
         * 设置最东边的值，等永远maxx = val
         */
        set east(val) { this.maxx = val; }
        /**
         * 获取最南边的值，等永远miny
         */
        get south() { return this.miny; }
        /**
         * 设置最南边的值，等同于miny = val
         */
        set south(val) { this.miny = val; }
        /**
         * 获取最北边的值，等同于maxy
         */
        get north() { return this.maxy; }
        /**
         * 设置最北边的值，等同于maxy = val
         */
        set north(val) { this.maxy = val; }
        /**
         * 获取最左边的值，等同于minx
         */
        get left() { return this.minx; }
        /**
         * 设置最左边的值，等永远minx = val
         */
        set left(val) { this.minx = val; }
        /**
         * 获取最右边的值，等永远maxx
         */
        get right() { return this.maxx; }
        /**
         * 设置最右边的值，等永远maxx = val
         */
        set right(val) { this.maxx = val; }
        /**
         * 获取最下边的值，等永远miny
         */
        get bottom() { return this.miny; }
        /**
         * 设置最下边的值，等同于miny = val
         */
        set bottom(val) { this.miny = val; }
        /**
         * 获取最上边的值，等同于maxy
         */
        get top() { return this.maxy; }
        /**
         * 设置最上边的值，等同于maxy = val
         */
        set top(val) { this.maxy = val; }
        /**
         * 获取矩形的中心点
         * @param result 一个可选的对象，用来存储矩形的中心点
         * @returns 返回矩形的中心点
         */
        center(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Cegore.Position)) {
                result = new Cegore.Position();
            }
            ///
            if (this._isGeographical) {
                let minx = this.minx;
                let maxx = this.maxx;
                if (maxx < minx)
                    maxx += 360.0;
                result.x = Cegore.GeoMath.stdAngle((maxx + minx) / 2.0);
            }
            else {
                result.x = (this.minx + this.maxx) / 2.0;
            }
            ///
            result.y = (this.miny + this.maxy) / 2.0;
            return result;
        }
        /**
         * 获取最小点
         * @param result
         */
        min(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Cegore.Position)) {
                result = new Cegore.Position();
            }
            result.x = this.minx;
            result.y = this.miny;
            return result;
        }
        /**
         * 获取最大点
         * @param result
         */
        max(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Cegore.Position)) {
                result = new Cegore.Position();
            }
            result.x = this.maxx;
            result.y = this.maxy;
            return result;
        }
        /**
         * 获取左下角
         * @param result
         */
        leftBottom(result) {
            return this.min(result);
        }
        /**
         * 获取左上角
         * @param result
         */
        leftTop(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Cegore.Position)) {
                result = new Cegore.Position();
            }
            result.x = this.minx;
            result.y = this.maxy;
            return result;
        }
        /**
         * 获取右上角
         * @param result
         */
        rightTop(result) {
            return this.max(result);
        }
        /**
         * 获取右下角
         * @param result
         */
        rightBottom(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Cegore.Position)) {
                result = new Cegore.Position();
            }
            result.x = this.maxx;
            result.y = this.miny;
            return result;
        }
        /**
         * 获取西南角
         * @param result
         */
        southWest(result) { return this.leftBottom(result); }
        /**
         * 获取东南角
         * @param result
         */
        southEast(result) { return this.rightBottom(result); }
        /**
         * 获取西北角
         * @param result
         */
        northWest(result) { return this.leftTop(result); }
        /**
         * 获取东北角
         * @param result
         */
        northEast(result) { return this.rightTop(result); }
        inflate(v1, v2) {
            if (Cegore.TypeCheck.isNumber(v1)) {
                if (!Cegore.TypeCheck.isNumber(v2))
                    v2 = v1;
            }
            else if (Cegore.TypeCheck.isInstanceOf(v1, Cegore.Vector2)) {
                let pt = v1;
                v1 = pt.x;
                v2 = pt.y;
            }
            else if (Cegore.TypeCheck.isInstanceOf(v1, Cegore.Position)) {
                let pt = v1;
                v1 = pt.x;
                v2 = pt.y;
            }
            this.minx -= v1;
            this.maxx += v1;
            this.miny -= v2;
            this.maxy += v2;
        }
        merge(v, w) {
            /// 数组
            if (Cegore.TypeCheck.isArray(v)) {
                for (let i = 0; i < v.length; ++i) {
                    this.merge(v[i]);
                }
                return;
            }
            if (Cegore.TypeCheck.isNumber(v)) {
                let x = v;
                let y = w;
                if (this.empty) {
                    this.minx = this.maxx = x;
                    this.miny = this.maxy = y;
                    this.empty = false;
                    return;
                }
                if (this._isGeographical) {
                    let sminx = Cegore.GeoMath.innerAngle(x, this.minx);
                    let smaxx = Cegore.GeoMath.innerAngle(x, this.maxx);
                    /// 对于地理坐标模式，使用最近的边进行判断
                    if (sminx <= smaxx && x < this.minx)
                        this.minx = x;
                    if (sminx >= smaxx && x > this.maxx)
                        this.maxx = x;
                }
                else {
                    /// 
                    if (x < this.minx)
                        this.minx = x;
                    if (x > this.maxx)
                        this.maxx = x;
                }
                //
                if (y < this.miny)
                    this.miny = y;
                if (y > this.maxy)
                    this.maxy = y;
                return;
            }
            /// 点
            if (Cegore.TypeCheck.isInstanceOf(v, Cegore.Position)) {
                this.merge(v.x, v.y);
                return;
            }
            if (Cegore.TypeCheck.isInstanceOf(v, Rectangle)) {
                let rc = v;
                if (this.empty) {
                    this.minx = rc.minx;
                    this.miny = rc.miny;
                    this.maxx = rc.maxx;
                    this.maxy = rc.maxy;
                    this.empty = false;
                    return;
                }
                if (this._isGeographical) {
                    let ct = this.center();
                    let sminx = Cegore.GeoMath.innerAngle(ct.x, this.minx);
                    let smaxx = Cegore.GeoMath.innerAngle(ct.x, this.maxx);
                    /// 对于地理坐标模式，使用最近的边进行判断
                    if (sminx <= smaxx && rc.minx < this.minx)
                        this.minx = rc.minx;
                    if (sminx >= smaxx && rc.maxx > this.maxx)
                        this.maxx = rc.maxx;
                }
                else {
                    if (rc.minx < this.minx)
                        this.minx = rc.minx;
                    if (rc.maxx > this.maxx)
                        this.maxx = rc.maxx;
                }
                if (rc.miny < this.miny)
                    this.miny = rc.miny;
                if (rc.maxy > this.maxy)
                    this.maxy = rc.maxy;
                return;
            }
        }
        /**
         * 将当前矩形对象转换成一个数组对象
         *
         * @param result 一个可选的对象，用于存储输出结果
         * @return 一个数组包含矩形的最小值最大值，如：[minx,miny,maxx,maxy]。
         */
        asArray(result) {
            if (!Cegore.TypeCheck.isArray(result)) {
                result = [];
            }
            result[0] = this.minx;
            result[1] = this.miny;
            result[2] = this.maxx;
            result[3] = this.maxy;
            return result;
        }
        /**
         * 复制当前对象
         * @param result 一个可选的对象，用于存储复制结果
         * @returns 复制的结果
         */
        clone(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Rectangle)) {
                result = new Rectangle();
            }
            result.minx = this.minx;
            result.miny = this.miny;
            result.maxx = this.maxx;
            result.maxy = this.maxy;
            return result;
        }
        contains(v) {
            if (Cegore.TypeCheck.isInstanceOf(v, Cegore.Position)) {
                let p = v;
                if (this.isGeographical) {
                    let x = p.x;
                    let minx = this.miny;
                    let maxx = this.maxx;
                    if (maxx < minx)
                        maxx += 360.0;
                    if (x < minx)
                        x += 360.0;
                    if (x < minx || x > maxx)
                        return false;
                }
                else {
                    if (p.x < this.minx || p.x > this.maxx)
                        return false;
                }
                if (p.y < this.miny || p.y > this.maxy)
                    return false;
                ///
                return true;
            }
            else if (Cegore.TypeCheck.isInstanceOf(v, Rectangle)) {
                let rc = v;
                return this.contains(rc.min()) && this.contains(rc.max());
            }
            throw "unknow param v, v must be a Position or Rectangle.";
        }
        /**
         * 求取两个矩形的交集，如果两个矩形不相交，返回undefined
         * @param rc
         * @param result
         */
        intersection(rc, result) {
            let x1, x2;
            if (this._isGeographical) {
                let minx1 = this.minx;
                let maxx1 = this.maxx;
                let minx2 = rc.minx;
                let maxx2 = rc.maxx;
                if (maxx1 < minx1) {
                    if (maxx2 < minx2)
                        minx2 += 360;
                    else if (minx2 < maxx1) {
                        minx2 += 360;
                        maxx2 += 360;
                    }
                    maxx1 += 360;
                }
                else if (maxx2 < minx2) {
                    if (minx1 < maxx2) {
                        minx1 += 360;
                        maxx1 += 360;
                    }
                    maxx2 += 360;
                }
                x1 = minx1 > minx2 ? minx1 : minx2;
                x2 = maxx1 < maxx2 ? maxx1 : maxx2;
                if (x1 > x2)
                    return undefined;
            }
            else {
                x1 = this.minx > rc.minx ? this.minx : rc.minx;
                x2 = this.maxx < rc.maxx ? this.maxx : rc.maxx;
                if (x1 > x2)
                    return undefined;
            }
            let y1, y2;
            y1 = this.miny > rc.miny ? this.miny : rc.miny;
            y2 = this.maxy < rc.maxy ? this.maxy : rc.maxy;
            if (y1 > y2)
                return undefined;
            if (!Cegore.TypeCheck.isInstanceOf(result, Rectangle)) {
                result = new Rectangle();
            }
            result.minx = x1;
            result.maxx = x2;
            result.miny = y1;
            result.maxy = y2;
            return result;
        }
        /**
         * @private
         */
        toCZRectangle() {
            return Cesium.Rectangle.fromDegrees(this._minx, this.miny, this.maxx, this.maxy);
        }
        static toCZRectangle(any) {
            if (!any)
                return undefined;
            if (any instanceof Rectangle)
                return any.toCZRectangle();
            return new Rectangle(any).toCZRectangle();
        }
        /**
         * 标准化经度，使输入的经度处于[-180,180]之间
         * @param lon 待处理的经度
         * @return 返回标准化后的经度
         */
        static normalizeLongitude(lon) {
            return Cegore.GeoMath.stdAngle(lon);
        }
        /**
         * 标准化纬度，使输入的纬度处于[-90,90]之间
         * @param lat 待处理的纬度
         * @return 返回标准化后的纬度
         */
        static normalizeLatitude(lat) {
            return Cegore.GeoMath.clamp(lat, -90, 90);
        }
    }
    Cegore.Rectangle = Rectangle;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class HeadingPitchRoll
 */
var Cegore;
(function (Cegore) {
    /**
     * 表述模型的姿态信息
     */
    class HeadingPitchRoll {
        /**
         * 构造函数
         */
        constructor(v0, v1, v2) {
            /// 方位角，绕Z轴旋转，单位：度
            this._heading = 0.0;
            /// 俯仰角，绕Y轴旋转，单位：度
            this._pitch = 0.0;
            /// 滚转角，绕X轴旋转，单位：度
            this._roll = 0.0;
            this.set(v0, v1, v2);
        }
        /**
         * 获取 方位角，绕Z轴旋转，单位：度
         */
        get heading() { return this._heading; }
        /**
         * 设置 方位角，绕Z轴旋转，单位：度
         */
        set heading(heading) { this._heading = heading; }
        /**
         * 获取 俯仰角，绕Y轴旋转，单位：度
         */
        get pitch() { return this._pitch; }
        /**
         * 设置 俯仰角，绕Y轴旋转，单位：度
         */
        set pitch(pitch) { this._pitch = pitch; }
        /**
         * 获取 滚转角，绕X轴旋转，单位：度
         */
        get roll() { return this._roll; }
        /**
         * 设置 滚转角，绕X轴旋转，单位：度
         */
        set roll(roll) { this._roll = roll; }
        set(v0, v1, v2) {
            let h, p, r;
            if (Cegore.TypeCheck.isArray(v0)) {
                let hpr = v0;
                h = hpr[0];
                p = hpr[1];
                r = hpr[2];
            }
            else if (Cegore.TypeCheck.isObject(v0)) {
                let hpr = v0;
                h = hpr.heading;
                p = hpr.pitch;
                r = hpr.roll;
            }
            else if (Cegore.TypeCheck.isNumber(v0)) {
                h = v0;
                p = v1;
                r = v2;
            }
            this.heading = Cegore.TypeCheck.defaultValue(h, 0);
            this.pitch = Cegore.TypeCheck.defaultValue(p, 0);
            this.roll = Cegore.TypeCheck.defaultValue(r, 0);
        }
        setFromRadius(v0, v1, v2) {
            let h, p, r;
            if (Cegore.TypeCheck.isArray(v0)) {
                let hpr = v0;
                h = hpr[0];
                p = hpr[1];
                r = hpr[2];
            }
            else if (Cegore.TypeCheck.isObject(v0)) {
                let hpr = v0;
                h = hpr.heading;
                p = hpr.pitch;
                r = hpr.roll;
            }
            else if (Cegore.TypeCheck.isNumber(v0)) {
                h = v0;
                p = v1;
                r = v2;
            }
            this.heading = Cegore.GeoMath.toDegree(Cegore.TypeCheck.defaultValue(h, 0));
            this.pitch = Cegore.GeoMath.toDegree(Cegore.TypeCheck.defaultValue(p, 0));
            this.roll = Cegore.GeoMath.toDegree(Cegore.TypeCheck.defaultValue(r, 0));
        }
    }
    Cegore.HeadingPitchRoll = HeadingPitchRoll;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
var Cegore;
(function (Cegore) {
    /**
     * 定义了一个局部坐标下的方位角，高度角和距离
     */
    class HeadingPitchDistance {
        constructor(v0, v1, v2) {
            /**
             * 相对于正北方向的方位角
             */
            this.heading = 0.0;
            /**
             * 相对于xy平面的高度角
             */
            this.pitch = 0.0;
            /**
             * 局部坐标下相对于的中心的距离
             */
            this.distance = 0.0;
            this.set(v0, v1, v2);
        }
        set(v0, v1, v2) {
            let h, p, d;
            let type = Cegore.TypeCheck.typeOf(v0);
            switch (type) {
                case 'number':
                    h = v0;
                    p = v1;
                    d = v2;
                    break;
                case 'array':
                    h = v0[0];
                    p = v0[1];
                    d = v0[2];
                    break;
                case 'object':
                    h = v0.heading;
                    p = v0.pitch;
                    d = v0.distance;
                    break;
            }
            this.heading = Cegore.TypeCheck.defaultValue(h, 0);
            this.pitch = Cegore.TypeCheck.defaultValue(p, 0);
            this.distance = Cegore.TypeCheck.defaultValue(d, 0);
        }
        /**
         * @private
         */
        _asCzObject(result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Cesium.HeadingPitchRange)) {
                result = new Cesium.HeadingPitchRange();
            }
            result.heading = Cegore.GeoMath.toRadian(this.heading);
            result.pitch = Cegore.GeoMath.toRadian(this.pitch);
            result.range = this.distance;
            return result;
        }
    }
    Cegore.HeadingPitchDistance = HeadingPitchDistance;
})(Cegore || (Cegore = {}));
/*
 * File of class GeoMath
 */
var Cegore;
(function (Cegore) {
    /**
     * 地理计算
     *
     * 地理计算类主要提供一些工具函数，用于常用的地理计算函数
     */
    class GeoMath {
        /**
         * 度转弧度
         * @param degree
         */
        static toRadian(degree) {
            return degree * this._degree2radian;
        }
        /**
         * 弧度转度
         * @param radian
         */
        static toDegree(radian) {
            return radian * this._radian2degree;
        }
        /**
         * 限制val的取值范围，如果val小于min则返回min，如果val大于max则返回max，否则返回val
         *
         * @param val 输入值
         * @param min 最小值
         * @param max 最大值
         */
        static clamp(val, min, max) {
            if (val < min)
                val = min;
            if (val > max)
                val = max;
            return val;
        }
        /**
         * 同 Math.acos，计算之前先 clamp值到 [-1.0,1.0] 之间，避免返回NaN
         * @param val
         */
        static acosClamped(value) {
            return Math.acos(GeoMath.clamp(value, -1.0, 1.0));
        }
        /**
         * 同 Math.asin，计算之前先 clamp值到 [-1.0,1.0] 之间，避免返回NaN
         * @param val
         */
        static asinClamped(value) {
            return Math.asin(GeoMath.clamp(value, -1.0, 1.0));
        }
        static random(v1, v2) {
            let r = Math.random();
            let min = Cegore.TypeCheck.defaultValue(v1, 0.0);
            let max = Cegore.TypeCheck.defaultValue(v2, 1.0);
            ///
            return min + (max - min) * r;
        }
        static surfaceDistance(p0, p1, radius) {
            if (Cegore.TypeCheck.isArray(p0)) {
                let sum = 0;
                for (let i = 1; i < p0.length; ++i) {
                    sum += GeoMath.surfaceDistance(p0[i - 1], p0[i], radius);
                }
                return sum;
            }
            if (!Cegore.TypeCheck.isInstanceOf(p0, Cegore.Position))
                p0 = new Cegore.Position(p0);
            if (!Cegore.TypeCheck.isInstanceOf(p1, Cegore.Position))
                p1 = new Cegore.Position(p1);
            if (!Cegore.TypeCheck.isDefined(radius))
                radius = 6378137.0;
            let radLatA = GeoMath.toRadian(p0.lat);
            let radLatB = GeoMath.toRadian(p1.lat);
            let radLonA = GeoMath.toRadian(p0.lon);
            let radLonB = GeoMath.toRadian(p1.lon);
            let ac = Math.cos(radLatA) * Math.cos(radLatB) * Math.cos(radLonA - radLonB);
            let as = Math.sin(radLatA) * Math.sin(radLatB);
            /// ac + as 有可能微微大于1或者小于-1,会导致acos计算出错
            let a = GeoMath.clamp(ac + as, -1, 1);
            ///
            return (Math.acos(a) * radius);
        }
        /**
         * 计算两个角度之间的夹角
         * @param a1
         * @param a2
         */
        static innerAngle(a1, a2) {
            a1 = GeoMath.stdAngle(a1);
            a2 = GeoMath.stdAngle(a2);
            let s = Math.abs(a1 - a2);
            if (s > 180)
                s = 360 - s;
            return s;
        }
        /**
         * 标准化角度，使输入的角度处于[-180,180]之间
         * @param angle 待处理的角度
         * @return 返回标准化后的角度
         */
        static stdAngle(angle) {
            let n = angle % 360.0;
            if (n > 180.0)
                n -= 360.0;
            if (n < -180.0)
                n += 360.0;
            return n;
        }
        /**
         * 计算地球表面上多边形的投影面积
         * @param polygon 多边形，定点序列，坐标为经纬度坐标
         * @param radius 地球半径
         */
        static surfaceArea(polygon, radius) {
            var outs = [];
            var rect = new Cegore.Rectangle();
            for (let i = 0; i < polygon.length; ++i) {
                rect.merge(polygon[i]);
            }
            var ori = rect.min();
            for (let i = 0; i < polygon.length; ++i) {
                var pt = new Cegore.Position(polygon[i]);
                let x = GeoMath.surfaceDistance(new Cegore.Position(pt.x, pt.y), new Cegore.Position(pt.x, ori.y), radius);
                let y = GeoMath.surfaceDistance(new Cegore.Position(pt.x, pt.y), new Cegore.Position(ori.x, pt.y), radius);
                outs.push(new Cegore.Position(x, y));
            }
            return GeoMath.area(outs);
        }
        /**
         * 计算多边形的面积
         * @param polygon 多边形的点序列，输入坐标为笛卡尔坐标系下的二维坐标
         */
        static area(polygon) {
            return Math.abs(GeoMath.signedArea(polygon));
        }
        /**
         * 计算带方向的面积
         * @param pts 多边形点序列
         */
        static signedArea(pts) {
            if (pts == null || pts.length < 3)
                return 0;
            var point_num = pts.length;
            var p0 = pts[point_num - 1];
            var p1 = pts[0];
            var p2 = pts[1];
            var s = p1.y * (p0.x - p2.x);
            for (var i = 1; i < point_num; ++i) {
                p0 = p1;
                p1 = p2;
                p2 = pts[(i + 1) % point_num];
                ///
                s += p1.y * (p0.x - p2.x);
            }
            ///
            return s / 2.0;
        }
    }
    GeoMath._degree2radian = Math.PI / 180.0;
    GeoMath._radian2degree = 180.0 / Math.PI;
    Cegore.GeoMath = GeoMath;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
var Cegore;
(function (Cegore) {
    /**
     * 线段，支持插值
     */
    class Segment {
        constructor(begin, end) {
            this._begin = begin;
            this._end = end;
            this._interp = new Cegore.Vector2();
        }
        /**
         * 插值
         * @param amount
         */
        interp(amount) {
            return Cegore.Vector2.lerp(this._begin, this._end, amount, this._interp);
        }
    }
    /**
     * 由多个线段并排构成的桥
     */
    class LineBridge {
        /**
         * 构造一个桥对象
         * @param begins
         * @param ends
         */
        constructor(begins, ends) {
            this._segments = [];
            let num = begins.length < ends.length ? begins.length : ends.length;
            for (let i = 0; i < num; ++i) {
                this._segments[i] = new Segment(begins[i], ends[i]);
            }
            this._interp = [];
        }
        /**
         * 插值桥中间的点
         * @param amount
         */
        interp(amount) {
            for (let i = 0; i < this._segments.length; ++i) {
                this._interp[i] = this._segments[i].interp(amount);
            }
            ///
            return this._interp;
        }
    }
    class InterpTool {
        /**
         * 计算最近的点
         * @param p
         * @param pts
         */
        static nearPoint(p, pts) {
            let index = 0;
            let length = Cegore.Vector2.squaredDistance(p, pts[0]);
            for (let i = 1; i < pts.length; ++i) {
                let l = Cegore.Vector2.squaredDistance(p, pts[i]);
                if (l < length) {
                    length = l;
                    index = i;
                }
            }
            return index;
        }
    }
    /**
     * 在多条线段间进行形插值
     */
    class MultiLineInterp {
        /// 
        constructor(options) {
            let lines = options.lines.slice();
            for (let i = 0; i < lines.length; ++i) {
                let pts = lines[i];
                for (let j = 0; j < pts.length; ++j) {
                    if (!Cegore.TypeCheck.isInstanceOf(pts[j], Cegore.Vector2))
                        pts[j] = new Cegore.Vector2(pts[j]);
                }
            }
            this._bridges = [];
            for (let i = 1; i < lines.length; ++i) {
                let pts0 = lines[i - 1];
                let pts1 = lines[i];
                this._bridges.push(new LineBridge(pts0, pts1));
            }
        }
        /**
         * 插值折线或者多边形
         * @param amount
         */
        interp(amount) {
            amount = Cegore.GeoMath.clamp(amount, 0, 1);
            let tamount = amount * this._bridges.length;
            let bri, ba;
            if (amount == 1) {
                bri = this._bridges.length - 1;
                ba = 1;
            }
            else {
                bri = Math.floor(tamount);
                ba = tamount - bri;
            }
            ///
            return this._bridges[bri].interp(ba);
        }
    }
    Cegore.MultiLineInterp = MultiLineInterp;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    /**
     * 基于Canvas的绘制类，提供基础的功能
     */
    class CanvasDraw {
        /**
         * 构造函数
         * @param options 一个可选的参数
         * @param options.canvas 一个可选的参数，指定使用的canvas dom 或者 id
         * @param options.width 指定画布的宽度，默认值：512
         * @param options.heigth 指定画布的高度，默认值：512
         */
        constructor(options) {
            let width = Cegore.TypeCheck.defaultValue(options.width, 512);
            let height = Cegore.TypeCheck.defaultValue(options.height, 512);
            this._ctx = this.createCanvasContext2D(options.canvas, width, height);
            this._canvas = this._ctx.canvas;
        }
        /**
         * 获取输出的Canvas
         */
        get canvas() { return this._canvas; }
        /**
         * 获取 Context2D
         */
        get context() { return this._ctx; }
        /**
         * 获取数据的范围
         */
        get rect() { return this._rect; }
        /**
         * 获取画布的宽度
         */
        get width() { return this._canvas.width; }
        ;
        /**
         * 获取画布的高度
         */
        get height() { return this._canvas.height; }
        /**
         * 清空画布
         */
        clear() { this._ctx.clearRect(0, 0, this.width, this.height); }
        /**
         * 计算数据的范围
         * @param lines
         */
        calcRect(lines) {
            if (!Cegore.TypeCheck.isDefined(this._rect))
                this._rect = new Cegore.Rectangle();
            else
                this._rect.empty = true;
            /// 递归函数
            function calc(lines, rect) {
                for (let i = 0; i < lines.length; ++i) {
                    let line = lines[i];
                    if (Cegore.TypeCheck.isInstanceOf(line, Cegore.Vector2))
                        rect.merge(line.x, line.y);
                    else if (Cegore.TypeCheck.isNumber(line[0])) {
                        lines[i] = new Cegore.Vector2(line);
                        rect.merge(line[0], line[1]);
                    }
                    else
                        calc(line, rect);
                }
            }
            ///
            calc(lines, this._rect);
            ///
            this._geoWidth = this._rect.width;
            this._getHeight = this._rect.height;
        }
        /**
         * X坐标转画布坐标
         * @param x
         */
        convertX(x) {
            return (x - this._rect.minx) / this._geoWidth * this.width;
        }
        /**
         * Y坐标转画布坐标
         * @param y
         */
        convertY(y) {
            return (this._rect.maxy - y) / this._getHeight * this.height;
        }
        /**
         * 创建或者使用输入的Canvas
         * @param canvas 一个可选的参数，指定使用的Canvas
         */
        createCanvasContext2D(canvas, width, height) {
            let result;
            if (Cegore.TypeCheck.isDefined(canvas)) {
                if (Cegore.TypeCheck.isString(canvas))
                    result = document.getElementById(canvas);
                else if (Cegore.TypeCheck.isInstanceOf(canvas, HTMLCanvasElement))
                    result = canvas;
            }
            if (!result) {
                result = document.createElement('CANVAS');
            }
            ///
            if (width)
                result.width = width;
            if (height)
                result.height = height;
            return result.getContext('2d');
        }
    }
    Cegore.CanvasDraw = CanvasDraw;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    /**
     * 多边形掩码
     */
    class PolygonMask extends Cegore.CanvasDraw {
        /**
         * 构造一个多边形掩码对象
         * @param lines 多边形的点
         * @param options
         */
        constructor(lines, options) {
            super(options);
            ///
            this.calcRect(lines);
            ///
            this._interp = new Cegore.MultiLineInterp({ lines: lines });
        }
        /**
         * 绘制指定时刻的多边形掩码
         * @param amount
         */
        draw(amount) {
            const ctx = this.context;
            ctx.fillStyle = '#FF0000';
            const pts = this._interp.interp(amount);
            this.clear();
            ctx.beginPath();
            ctx.moveTo(this.convertX(pts[0].x), this.convertY(pts[0].y));
            for (var i = 1; i < pts.length; ++i) {
                ctx.lineTo(this.convertX(pts[i].x), this.convertY(pts[i].y));
            }
            ctx.closePath();
            ctx.fill();
        }
    }
    Cegore.PolygonMask = PolygonMask;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    /**
     * 折线，多边形渐变
     */
    class PolylineGradual extends Cegore.CanvasDraw {
        constructor(lines, options) {
            super(options);
            this._fill = true;
            this._ctx1 = this.createCanvasContext2D(null, this.width, this.height);
            this._canvas1 = this._ctx1.canvas;
            this._ctx2 = this.createCanvasContext2D(null, this.width, this.height);
            this._canvas2 = this._ctx2.canvas;
            //this._fadein = TypeCheck.defaultValue(options.fadein, 0.5);
            //this._fadeout = TypeCheck.defaultValue(options.fadeout, 0.5);
            this._lines = lines;
            ///
            this.calcRect(lines);
        }
        draw(amount) {
            this.clear();
            this.context.fillStyle = '#FF0000';
            this.context.strokeStyle = "#FF0000";
            amount = Cegore.GeoMath.clamp(amount, 0, 1);
            let tamount = amount * (this._lines.length - 1);
            let bri1 = Math.floor(tamount);
            if (bri1 === this._lines.length - 1)
                bri1--;
            ///
            let bri2 = bri1 + 1;
            let ba = tamount - bri1;
            this.drawLine(this._ctx1, this._lines[bri1]);
            this.drawLine(this._ctx2, this._lines[bri2]);
            ///
            this.drawMix(this._ctx1, this._ctx2, ba);
        }
        drawLine(ctx, line) {
            const fill = this._fill;
            //let cbyte = Math.floor(alpha * 255);
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#FFFFFF';
            ctx.clearRect(0, 0, this.width, this.height);
            //
            //ctx.globalAlpha = alpha;
            ctx.beginPath();
            ///
            let self = this;
            function draw(line) {
                if (!Cegore.TypeCheck.isInstanceOf(line[0], Cegore.Vector2)) {
                    for (let i = 0; i < line.length; ++i) {
                        draw(line[i]);
                    }
                }
                ///
                ctx.moveTo(self.convertX(line[0].x), self.convertY(line[0].y));
                for (var i = 1; i < line.length; ++i) {
                    ctx.lineTo(self.convertX(line[i].x), self.convertY(line[i].y));
                }
            }
            ///
            draw(line);
            if (this._fill)
                ctx.fill();
            else
                ctx.stroke();
        }
        drawMix(ctx1, ctx2, alpha) {
            const width = this.width;
            const height = this.height;
            let imgdata1 = ctx1.getImageData(0, 0, width, height);
            let imgdata2 = ctx2.getImageData(0, 0, width, height);
            let imgdatat = this.context.getImageData(0, 0, width, height);
            let d1 = imgdata1.data;
            let d2 = imgdata2.data;
            let dt = imgdatat.data;
            let length = width * height * 4;
            for (let i = 0; i < length; i += 4) {
                dt[i] = 255;
                dt[i + 1] = dt[i + 2] = 0;
                if (d1[i + 3] != 0 && d2[i + 3] != 0) {
                    dt[i + 3] = (d1[i] + d2[i]) / 2;
                }
                else if (d1[i + 3] != 0) {
                    dt[i + 3] = (1.0 - alpha) * d1[i + 3];
                }
                else if (d2[i + 3] != 0) {
                    dt[i + 3] = alpha * d2[i + 3];
                }
                else {
                    dt[i + 3] = 0;
                }
                dt[i] = dt[i + 3];
            }
            this.context.putImageData(imgdatat, 0, 0);
        }
    }
    Cegore.PolylineGradual = PolylineGradual;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    class DynamicArea {
        constructor(options) {
            this._viewer = options.viewer;
            let size = Cegore.TypeCheck.defaultValue(options.textureSize, {});
            function initLines(lines, level, result) {
                if (lines.length == 0)
                    return;
                ///
                let equel = true;
                let length = lines[0].length;
                for (let i = 0; i < lines.length; ++i) {
                    let line = lines[i];
                    if (Cegore.TypeCheck.isNumber(line[0])) {
                        lines[i] = new Cegore.Vector2(line);
                    }
                    else {
                        initLines(line, level + 1, result);
                    }
                    if (length != line.length)
                        equel = false;
                }
                if (level == 0)
                    result.isEquel = equel;
                if (level > 1)
                    result.isSimple = false;
            }
            let result = { isEquel: false, isSimple: true };
            let lines = options.lines.slice();
            initLines(lines, 0, result);
            if (result.isEquel && result.isSimple) {
                this._polygonMask = new Cegore.PolygonMask(lines, {
                    canvas: options.canvas,
                    width: size.width,
                    height: size.height
                });
            }
            else {
                this._polygonMask = new Cegore.PolylineGradual(lines, {
                    canvas: options.canvas,
                    width: size.width,
                    height: size.height
                });
            }
            ///
            this._material = new Cesium.Material({
                fabric: {
                    type: 'Water',
                    uniforms: {
                        specularMap: this._polygonMask.canvas,
                        normalMap: '../../build/dep.debug/Assets/Textures/waterNormals.jpg',
                        frequency: 10000.0,
                        animationSpeed: 0.01,
                        amplitude: 1.0
                    }
                }
            });
            this._appearance = new Cesium.EllipsoidSurfaceAppearance({
                aboveGround: true,
                faceForward: false,
                material: this._material,
                renderState: {
                    fog: { enabled: true, density: 0.01 }
                }
            });
            this._geometry = new Cesium.RectangleGeometry({
                rectangle: this._polygonMask.rect.toCZRectangle(),
                vertexFormat: Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
                height: options.height,
                extrudedHeight: options.extrudedHeight,
                granularity: Math.PI / 5000
            });
            ///
            this._primitive = options.viewer._czdata.viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: this._geometry
                }),
                appearance: this._appearance,
                show: true
            }));
        }
        draw(amount) {
            this._polygonMask.draw(amount);
            let tex = this._material._textures.specularMap;
            let canvas = this._polygonMask.canvas;
            if (tex && tex.width == canvas.width && tex.height == canvas.height) {
                tex.copyFrom(canvas);
            }
        }
        set visible(visible) {
            if (this._primitive)
                this._primitive.show = visible;
        }
        get visible() { return this._primitive ? this._primitive.show : false; }
        /**
         * 删除该对象
         */
        remove() {
            this._viewer._czdata.viewer.scene.primitives.remove(this._primitive);
            this._primitive = this._primitive.destroy();
            this._appearance = null;
            this._material = this._material.destroy();
            this._geometry = null;
            this._polygonMask = null;
        }
    }
    Cegore.DynamicArea = DynamicArea;
})(Cegore || (Cegore = {}));
/*
 * File of class Color
 */
var Cegore;
(function (Cegore) {
    /**
     * 颜色类
     *
     * 使用 red，green，blue和alpha四个[0.0, 1.0]之间的浮点数分量描述颜色信息
     */
    class Color {
        constructor(r, g, b, a) {
            this._r = 0.0;
            this._g = 0.0;
            this._b = 0.0;
            this._a = 0.0;
            this.set(r, g, b, a);
        }
        set(r, g, b, a) {
            if (Cegore.TypeCheck.isInstanceOf(r, Cesium.Color)) {
                let c = r;
                r = c.red;
                g = c.green;
                b = c.blue;
                a = c.alpha;
            }
            else if (Cegore.TypeCheck.isString(r)) {
                let c = Color.fromCssColor(r);
                r = c.r;
                g = c.g;
                b = c.b;
                a = c.a;
            }
            else if (Cegore.TypeCheck.isArray(r)) {
                let arr = r;
                r = arr[0];
                g = arr[1];
                b = arr[2];
                a = arr[3];
            }
            else if (Cegore.TypeCheck.isObject(r)) {
                let obj = r;
                r = obj.r;
                g = obj.g;
                b = obj.b;
                a = obj.a;
            }
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        /**
         * 获取红色分量
         */
        get red() { return this._r; }
        /**
         * 获取绿色分量
         */
        get green() { return this._g; }
        /**
         * 获取蓝色分量
         */
        get blue() { return this._b; }
        /**
         * 获取透明度分量
         */
        get alpha() { return this._a; }
        /**
         * 获取红色分量
         */
        get r() { return this._r; }
        /**
         * 获取绿色分量
         */
        get g() { return this._g; }
        /**
         * 获取蓝色分量
         */
        get b() { return this._b; }
        /**
         * 获取透明度分量
         */
        get a() { return this._a; }
        /**
         * 设置红色分量
         */
        set r(value) { this._r = Cegore.GeoMath.clamp(Cegore.TypeCheck.defaultValue(value, 0.0), 0.0, 1.0); }
        /**
         * 设置绿色分量
         */
        set g(value) { this._g = Cegore.GeoMath.clamp(Cegore.TypeCheck.defaultValue(value, 0.0), 0.0, 1.0); }
        /**
         * 设置蓝色分量
         */
        set b(value) { this._b = Cegore.GeoMath.clamp(Cegore.TypeCheck.defaultValue(value, 0.0), 0.0, 1.0); }
        /**
         * 设置透明度分量
         */
        set a(value) { this._a = Cegore.GeoMath.clamp(Cegore.TypeCheck.defaultValue(value, 0.0), 0.0, 1.0); }
        /**
         * 从CSS格式颜色字符构造颜色对象
         *
         * @param css CSS格式的颜色字符串
         */
        static fromCssColor(css) {
            return new Color(Cesium.Color.fromCssColorString(css));
        }
        /**
         * 通过 0-255的 RGBA分量构造颜色对象
         * @param r [0-255]的红色分量
         * @param g [0-255]的的绿分量
         * @param b [0-255]的的蓝分量
         * @param a [0-255]的的透明分量
         * @param result 用于存储结果的对象
         */
        static fromBytes(r, g, b, a, result) {
            if (!Cegore.TypeCheck.isInstanceOf(result, Color)) {
                result = Color.BLACK;
            }
            result.r = (r / 255);
            result.g = (g / 255);
            result.b = (b / 255);
            result.a = (a / 255);
            return result;
        }
        /**
         * 从一个32位的 RGBA 构造颜色
         * @param rgba 32位的RGBA颜色
         * @param result 用于存储结果的对象
         */
        static fromRGBA32(rgba, result) {
            /// unionUint32 和 unionUint8 共享内存
            Color.UnionUint32[0] = rgba;
            return Color.fromBytes(Color.UnionUint8[0], Color.UnionUint8[1], Color.UnionUint8[2], Color.UnionUint8[3], result);
        }
        /**
         * 根据指定的参数随机生成颜色
         *
         * @param options 用于生成随机颜色的参数
         * @param options.red 如果指定该参数，则是用该参数代替随机值
         * @param options.minRed 指定随机颜色的最小值，默认为0.0
         * @param options.maxRed 指定随机颜色的最大值，默认为1.0
         * @param options.blue 如果指定该参数，则是用该参数代替随机值
         * @param options.minBlue 指定随机颜色的最小值，默认为0.0
         * @param options.maxBlue 指定随机颜色的最大值，默认为1.0
         * @param options.green 如果指定该参数，则是用该参数代替随机值
         * @param options.minGreen 指定随机颜色的最小值，默认为0.0
         * @param options.maxGreen 指定随机颜色的最大值，默认为1.0
         * @param options.alpha 如果指定该参数，则是用该参数代替随机值
         * @param options.minAlpha 指定随机颜色的最小值，默认为0.0
         * @param options.maxAlpha 指定随机颜色的最大值，默认为1.0
         * @param result 一个可选的颜色对象，用于输出存储结果
         */
        static fromRandom(options, result) {
            function random(v, min, max) {
                if (Cegore.TypeCheck.isNumber(v)) {
                    return v;
                }
                else {
                    min = Cegore.TypeCheck.defaultValue(min, 0.0);
                    max = Cegore.TypeCheck.defaultValue(max, 1.0);
                    return Cegore.GeoMath.random(min, max);
                }
            }
            if (!Cegore.TypeCheck.isInstanceOf(result, Color)) {
                result = Color.BLACK;
            }
            result.r = random(options.red, options.minRed, options.maxRed);
            result.g = random(options.green, options.minGreen, options.maxGreen);
            result.b = random(options.blue, options.minBlue, options.maxBlue);
            result.a = random(options.alpha, options.minAlpha, options.maxAlpha);
            return result;
        }
        /**
         * 将当前颜色转成 CSS 颜色字符串
         * @return 返回一个表示的颜色的CSS字符串
         */
        toCssColor() {
            return new Cesium.Color(this._r, this._g, this._b, this._a).toCssColorString();
        }
        /**
         * 将当前颜色转成 字节数组 [r, g, b, a] , 颜色值为 [0,255]
         * @param result 一个可选的数组对象，用来存储输出值
         * @return 返回一个数组，存储颜色字节
         */
        toBytes(result) {
            if (!Cegore.TypeCheck.isArray(result)) {
                result = [];
            }
            result[0] = Math.floor(this._r * 255);
            result[1] = Math.floor(this._g * 255);
            result[2] = Math.floor(this._b * 255);
            result[3] = Math.floor(this._a * 255);
            return result;
        }
        /**
         * 将当前的颜色转为一个32位的 RGBA 整数
         */
        toRGBA32() {
            let bytes = this.toBytes();
            Color.UnionUint8[0] = bytes[0];
            Color.UnionUint8[1] = bytes[1];
            Color.UnionUint8[2] = bytes[2];
            Color.UnionUint8[3] = bytes[3];
            return Color.UnionUint32[0];
        }
        /**
         * @private
         */
        toCZColor() {
            return new Cesium.Color(this._r, this._g, this._b, this._a);
        }
    }
    /**
     * 红色 <span class="colorSwath" style="background: #FF0000;"></span>
     */
    Color.RED = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#FF0000'));
    /**
     * 绿色 <span class="colorSwath" style="background: #00FF00;"></span>
     */
    Color.GREEN = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#00FF00'));
    /**
     * 蓝色 <span class="colorSwath" style="background: #0000FF;"></span>
     */
    Color.BLUE = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#0000FF'));
    /**
     * 黑色 <span class="colorSwath" style="background: #000000;"></span>
     */
    Color.BLACK = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#000000'));
    /**
     * 白色 <span class="colorSwath" style="background: #FFFFFF;"></span>
     */
    Color.WHITE = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#FFFFFF'));
    /**
     * 黄色 <span class="colorSwath" style="background: #FFFF00;"></span>
     */
    Color.YELLOW = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#FFFF00'));
    /**
     * 青色 <span class="colorSwath" style="background: #00FFFF;"></span>
     */
    Color.AUQA = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#00FFFF'));
    /**
     * 品红 <span class="colorSwath" style="background: #FF00FF;"></span>
     */
    Color.FUCHSIA = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#FF00FF'));
    /**
     * 灰色 <span class="colorSwath" style="background: #808080;"></span>
     */
    Color.GRAY = Cegore.TypeCheck.freezeObject(Color.fromCssColor('#808080'));
    /// 共享内存的 32位整数和 8位整数，用于颜色格式转换
    Color.ScratchArrayBuffer = new ArrayBuffer(4);
    Color.UnionUint32 = new Uint32Array(Color.ScratchArrayBuffer);
    Color.UnionUint8 = new Uint8Array(Color.ScratchArrayBuffer);
    Cegore.Color = Color;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Material
 */
var Cegore;
(function (Cegore) {
    /**
     * 材质
     */
    class Material {
    }
    Cegore.Material = Material;
    /**
     * 颜色材质
     */
    class ColorMaterial extends Material {
        /**
         * 构造一个颜色材质
         * @param color
         */
        constructor(color) {
            super();
            this._color = new Cegore.Color(Cegore.Color.WHITE);
            if (!Cegore.TypeCheck.isInstanceOf(color, Cegore.Color)) {
                color = new Cegore.Color(color);
            }
            ///
            this._czmat = new Cesium.ColorMaterialProperty(color.toCZColor());
        }
        /**
         * 获取类型
         */
        get type() { return 'Color'; }
        /**
         * 获取材质
         * @private
         */
        get czmat() { return this._czmat; }
        /**
         * 获取颜色
         */
        get color() { return this._color; }
        /**
         * 设置颜色
         */
        set color(val) {
            this._color.set(val);
            this._czmat.color = this._color.toCZColor();
        }
    }
    Cegore.ColorMaterial = ColorMaterial;
    /**
     * 图片材质
     *
     * 支持 URL，Image，Canvas，Video
     */
    class ImageMaterial extends Material {
        /**
         * 构造一个图像材质
         * @param options 一个可选的参数
         * @param options.image 指定显示的图像，可以是URL，Image，Canvas和Video
         * @param options.repeat 指定图像重复显示的次数，默认值：[1.0, 1.0]
         * @param options.color 指定显示时叠加的颜色，默认值：Color.WHITE
         * @param options.transparent 指定材质是否透明显示，当图片包含透明信息是设置为true
         */
        constructor(options) {
            super();
            this._color = new Cegore.Color(Cegore.Color.WHITE);
            this._repeat = new Cegore.Vector2(1, 1);
            this._transparent = false;
            this._czmat = new Cesium.ImageMaterialProperty();
            this.color = options.color;
            this.image = options.image;
            this.repeat = options.repeat;
            this.transparent = options.transparent;
        }
        /**
         * 获取类型
         */
        get type() { return 'Image'; }
        /**
         * 获取材质
         * @private
         */
        get czmat() { return this._czmat; }
        /**
         * 获取颜色
         */
        get color() { return this._color; }
        /**
         * 设置颜色
         */
        set color(val) {
            this._color.set(val);
            this._czmat.color = this._color.toCZColor();
        }
        /**
         * 获取该材质使用的 Image,URL,Canvas,Video
         */
        get image() { return this._image; }
        /**
         * 设置该材质使用的 Image,URL,Canvas,Video
         */
        set image(img) {
            this._image = img;
            this._czmat.image = img;
        }
        /**
         * 获取图像重复显示的次数，默认值：[1, 1]
         */
        get repeat() { return this._repeat; }
        /**
         * 设置图像重复显示的次数，默认值：[1, 1]
         */
        set repeat(repeat) {
            this._repeat.set(repeat);
            this._czmat.repeat = this._repeat._asCzVector2();
        }
        /**
         * 返回当前材质是否透明
         */
        get transparent() { return this._transparent; }
        /**
         * 设置当前材质是否透明
         */
        set transparent(val) {
            this._transparent = val;
            this._czmat.transparent = val;
        }
    }
    Cegore.ImageMaterial = ImageMaterial;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */
/**
 * end of file
 */ 
/*
 * File of class Event
 */
var Cegore;
(function (Cegore) {
    /**
     * 事件监听器，同事记录回调函数和回调this
     */
    class EventListener {
        /**
         * 构造一个事件监听器
         *
         * @param callback 回调函数，当事件触发时调用的函数
         * @param self 回调函数的this，
         */
        constructor(callback, self) {
            this._callback = callback;
            this._self = self;
        }
        /**
         * 判断两个事件是否相同
         * @param e1 待判断的对象
         * @param e2 待判断的对象
         */
        static equal(e1, e2) {
            return (e1._callback === e2._callback &&
                e1._self === e2._self);
        }
        /**
         * 触发事件
         *
         * @param arg 事件参数
         */
        fire(args) {
            try {
                this._callback.apply(this._self, args);
            }
            catch (error) {
                console.error('fire event error.');
            }
        }
    }
    /**
     * 事件类
     *
     * 一个通用的工具类，用于管理一个特别的事件。
     *
     * @example
     *
     * 示例1
     *
     * function callback(arg1, arg2){
     * }
     *
     * var evt = new Event();
     * evt.on(callback);
     * evt.fire(1, 2);
     * evt.off(callback);
     *
     * 示例2
     * function MyObject(){
     * }
     *
     * MyObject.prototype.callback = function(arg1, arg2){
     *      this.mArg1 = arg1;
     *      this.mArg2 = arg2;
     * }
     *
     * var obj = new MyObject();
     * var evt = new Event();
     * evt.on(obj.callback, obj);
     * evt.fire(1, 2);
     * evt.off(obj.callback, obj);
     *
     */
    class Event {
        constructor() {
            /**
             * 事件监听器列表
             */
            this._listeners = [];
        }
        /**
         * 注册事件
         *
         * 当事件触发时，回调函数将会被调用，当指定self是，self将作为回调函数的<code>this</code>
         *
         * @param callback 事件回调函数，当事件触发时被调用
         * @param self 一个可选的对象，当回调函数被调用时，作为回调函数的 <code>this</code> 指针。
         */
        on(callback, self) {
            if (!Cegore.TypeCheck.isFunction(callback))
                throw "need param 'callback' is Function.";
            let event = new EventListener(callback, self);
            let index = Cegore.ArrayUtil.indexOf(event, this._listeners, EventListener.equal);
            if (index === -1)
                this._listeners.push(event);
        }
        /**
         * 反注册事件
         *
         * 移除之前注册的事件回调函数
         *
         * @param callback 使用 on 注册时传入的 callback
         * @param self 使用 on 注册时传入的 self
         */
        off(callback, self) {
            let event = new EventListener(callback, self);
            let index = Cegore.ArrayUtil.indexOf(event, this._listeners, EventListener.equal);
            if (index !== -1)
                this._listeners.splice(index);
        }
        /**
         * 触发事件，调用所有注册的回调函数
         *
         * @param args 传给事件回调函数的参数列表
         */
        fire(...args) {
            for (let i = 0; i < this._listeners.length; ++i) {
                this._listeners[i].fire(args);
            }
        }
        /**
         * 同函数 <code>on</code>
         * @see
         * Event.on
         */
        addEventListener(callback, self) {
            this.on(callback, self);
        }
        /**
         * 同函数 <code>off</code>
         * @see
         * Event.off
         */
        removeEventListener(callback, self) {
            this.off(callback, self);
        }
    }
    Cegore.Event = Event;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class EventHandle
 */
var Cegore;
(function (Cegore) {
    /**
     * 事件句柄
     */
    class EventHandle {
        /**
         * 构造函数
         * @param options
         */
        constructor(options) {
            this._events = new Cegore.HashMap(function () { return new Cegore.Event; });
            if (Cegore.TypeCheck.isArray(options)) {
                for (let i = 0; i < options.length; ++i) {
                    let ev = options[i];
                    if (Cegore.TypeCheck.isString(ev.type) &&
                        Cegore.TypeCheck.isFunction(ev.callback)) {
                        this.on(ev.type, ev.callback, ev.self);
                    }
                }
            }
            else if (Cegore.TypeCheck.isObject(options)) {
                for (let type in options) {
                    let callback = options[type];
                    if (Cegore.TypeCheck.isFunction(callback))
                        this.on(type, callback);
                }
            }
        }
        /**
         * 注册事件
         * @param type 事件类型
         * @param callback 事件回调
         * @param self 回调的this
         */
        on(type, callback, self) {
            if (!Cegore.TypeCheck.isString(type))
                throw "need param 'type' is string.";
            if (!Cegore.TypeCheck.isFunction(callback))
                throw "need param 'callback' is Function.";
            this._events.getOrCreate(type).on(callback, self);
        }
        /**
         * 反注册事件
         * @param type 事件类型
         * @param callback 事件回调
         * @param self 回调的this
         */
        off(type, callback, self) {
            let handles = this._events.get(type);
            if (!Cegore.TypeCheck.isDefined(handles))
                return;
            handles.off(callback, self);
        }
        /**
         * 触发事件
         * @param type 事件类型
         * @param arg 事件参数
         */
        fire(type, ...args) {
            let handles = this._events.get(type);
            if (!Cegore.TypeCheck.isDefined(handles))
                return;
            handles.fire.apply(handles, args);
        }
    }
    Cegore.EventHandle = EventHandle;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class AutoNames
 */
var Cegore;
(function (Cegore) {
    /**
     * 自动名称
     *
     * 用于自动生成不重复的名称字符串
     */
    class AutoNames {
        /**
         * 生成一个名称
         *
         * 如果指定了名称则使用该名称，未指定则自动使用前缀加序号生成名称
         *
         * @param name 如果指定了名称，则使用该名称
         * @param prefix 自动生成名称的前缀
         */
        static genName(name, prefix) {
            if (Cegore.TypeCheck.isDefined(name))
                return name;
            if (Cegore.TypeCheck.isDefined(prefix))
                return prefix + '-' + AutoNames.NextIndex++;
            else
                return 'AutoName-' + AutoNames.NextIndex++;
        }
    }
    /**
     * 下一个名称的序号
     */
    AutoNames.NextIndex = 0;
    Cegore.AutoNames = AutoNames;
})(Cegore || (Cegore = {}));
/*
 * File of class Clock
 */
var Cegore;
(function (Cegore) {
    /**
     * 一个简单的时钟类，用来模拟时间
     *
     * 该类还记录了一个时间区间，用来指导时间轴的显示
     */
    class Clock {
        /**
         * 构造一个新的时钟类
         * @param viewer
         */
        constructor(viewer) {
            this._onTick = new Cegore.Event();
            this._czClock = viewer._czdata.viewer.clock;
            this._czClock.onTick.addEventListener(() => { this._onTick.fire(this); });
        }
        /**
         * tick 事件，当时间改变时调用
         * @event
         */
        get onTick() {
            return this._onTick;
        }
        /**
         * 获取当前时间
         */
        get currentTime() {
            return Cesium.JulianDate.toDate(this._czClock.currentTime);
        }
        /**
         * 设置当前时间
         */
        set currentTime(value) {
            this._czClock.currentTime = Cesium.JulianDate.fromDate(value);
        }
        /**
         * 获取开始时间
         */
        get startTime() {
            return Cesium.JulianDate.toDate(this._czClock.startTime);
        }
        /**
         * 设置开始时间
         */
        set startTime(value) {
            this._czClock.startTime = Cesium.JulianDate.fromDate(value);
        }
        /**
         * 获取停止时间
         */
        get stopTime() {
            return Cesium.JulianDate.toDate(this._czClock.stopTime);
        }
        /**
         * 设置停止时间
         */
        set stopTime(value) {
            this._czClock.stopTime = Cesium.JulianDate.fromDate(value);
        }
    }
    Cegore.Clock = Clock;
})(Cegore || (Cegore = {}));
/**
 * End of file
 */ 
/*
 * File of class Camera
 */
var Cegore;
(function (Cegore) {
    /**
     * 相机类
     *
     * 通过该接口可以控制相机的位置和方向
     *
     * @example
     * <pre>
     * 移动相机
     * camera.flyTo({
     *     position : [117.16, 32.71, 15000.0]
     * });
     *
     * 使用事件
     * camera.moveStart.on(function() { console.log('moveStart');  });
     * </pre>
     */
    class Camera {
        /**
         * 构造函数
         *
         * 不要调用此构造函数，通过viewer对象获取相机类
         *
         * @param viewer
         */
        constructor(viewer) {
            /// 用于输出位置的内部变量，避免重复new
            this._position = new Cegore.Position();
            this._orientation = new Cegore.HeadingPitchRoll();
            /// 事件绑定
            this._eventChanged = new Cegore.Event;
            this._eventMoveStart = new Cegore.Event;
            this._eventMoveEnd = new Cegore.Event;
            this._viewer = viewer;
            this._czData = viewer._czdata;
            this._czCamera = this._czData.camera;
            /// 绑定事件
            this._czCamera.changed.addEventListener(() => { this._eventChanged.fire(this); });
            this._czCamera.moveStart.addEventListener(() => { this._eventMoveStart.fire(this); });
            this._czCamera.moveEnd.addEventListener(() => { this._eventMoveEnd.fire(this); });
        }
        /**
         * 获取当前相机的位置
         */
        get position() {
            this._position.set(this._czData.camera.positionCartographic);
            return this._position;
        }
        /**
         * 设置相机的当前位置
         */
        set position(pos) {
            if (!Cegore.TypeCheck.isInstanceOf(pos, Cegore.Position)) {
                this._position.set(pos);
                pos = this._position;
            }
            this.setView({ position: pos });
        }
        /**
         * 获取相机的当前姿态
         */
        get orientation() {
            this._orientation.setFromRadius(this._czData.camera.heading, this._czData.camera.pitch, this._czData.camera.roll);
            return this._orientation;
        }
        /**
         * 设置相机的当前姿态
         */
        set orientation(hpr) {
            if (!Cegore.TypeCheck.isInstanceOf(hpr, Cegore.HeadingPitchRoll)) {
                this._orientation.set(hpr);
                hpr = this._orientation;
            }
            this.setView({ orientation: hpr });
        }
        /**
         * 相机改变事件
         *
         * 该事件仅在相机发生一定变化后出发，如有其他需求，请使用 moveStart 和 moveEnd 事件
         * 事件原型 ```function (camera) {};```
         * @event
         */
        get changed() { return this._eventChanged; }
        /**
         * 相机开始移动事件
         *
         * 事件原型 ```function (camera) {};```
         * @event
         */
        get moveStart() { return this._eventMoveStart; }
        /**
         * 相机结束移动事件
         *
         * 事件原型 ```function (camera) {};```
         * @event
         */
        get moveEnd() { return this._eventMoveEnd; }
        /**
         * 设置相机的从当前位置飞行到目标点
         *
         * @param options 包含如下属性
         * @param options.position 指定飞行的目标位置
         * @param options.rect 指定飞行目标矩形范围信息
         * @param options.orientation 指定飞行时的姿态
         * @param options.duration 指定飞行的时长，单位：秒。如果不指定，则自动计算
         * @param options.complete 指定飞行完成后的回调函数
         * @param options.cancel 指定飞行取消后的回调函数
         *
         * @description
         * options.position 和 options.rect 任选一个，如果都没有指定则抛出异常
         *
         * @example
         *
         * ```ts
         * // 1. 飞行到一个位置
         * camera.flyTo({
         *     position : [117.16, 32.71, 15000.0]
         * });
         *
         * // 2. 飞行到一个矩形区域
         * camera.flyTo({
         *     rect : [west, south, east, north]
         * });
         *
         * // 3. 飞行到一个位置并带有角度
         * camera.flyTo({
         *     position : [117.16, 32.71, 15000.0],
         *     heading : Cesium.Math.toRadians(175.0),
         *     pitch : Cesium.Math.toRadians(-35.0),
         *     roll : 0.0
         * });
         * ```
         */
        flyTo(options) {
            /// 构建目标
            let destination;
            let orientation;
            /// 指定坐标
            if (Cegore.TypeCheck.isDefined(options.position))
                destination = this.fromPosition(options.position);
            /// 指定范围
            else if (Cegore.TypeCheck.isDefined(options.rect))
                destination = this.fromRectange(options.rect);
            /// 没有指定坐标或者范围
            else
                throw 'position or rect is need.';
            if (Cegore.TypeCheck.isDefined(options.orientation))
                orientation = this.fromOrientation(options.orientation);
            /// 调用内部对象的接口
            return this._czCamera.flyTo({
                destination: destination,
                orientation: orientation,
                duration: options.duration,
                complete: options.complete,
                cancel: options.cancel,
                endTransform: Cesium.Matrix4.IDENTITY
            });
        }
        /**
         * 飞行到一个位置使当前视图刚好包含整个球
         * @param options 参数
         * @param options.center 球的中心点
         * @param options.radius 球的半径
         * @param options.offset 相机的相对方位
         * @param options.duration 指定飞行的时长，单位：秒。如果不指定，则自动计算
         * @param options.complete 指定飞行完成后的回调函数
         * @param options.cancel 指定飞行取消后的回调函数
         *
         */
        flyToSphere(options) {
            let center = options.center;
            let offset = options.offset;
            if (!Cegore.TypeCheck.isInstanceOf(center, Cegore.Position))
                center = new Cegore.Position(center);
            if (!Cegore.TypeCheck.isInstanceOf(offset, Cegore.HeadingPitchDistance))
                offset = new Cegore.HeadingPitchDistance(offset);
            let bs = new Cesium.BoundingSphere(this.fromPosition(center), options.radius);
            let czoffset;
            if (Cegore.TypeCheck.isDefined(options.offset)) {
                czoffset = offset._asCzObject();
            }
            ///
            this._czCamera.flyToBoundingSphere(bs, {
                offset: czoffset,
                duration: options.duration,
                complete: options.complete,
                cancel: options.cancel,
                endTransform: Cesium.Matrix4.IDENTITY
            });
        }
        /**
         * 停止飞行，相机停止在当前位置
         */
        stopFly() {
            this._czData.camera.cancelFlight();
        }
        /**
         * 设置相机的位置信息
         *
         * 该接口同flyTo类似，不过没有飞行过程
         *
         * @param options 包含如下属性
         * @param options.position 指定一个坐标位置 [lon, lat, height]，分别是经度（度），纬度（度），高度（米）
         * @param options.rect 指定一个矩形范围信息 [west,south,east,north]，单位：度
         * @param options.orientation 指定姿态
         *
         * @description
         * options.position 和 options.rect 任选一个，如果都没有指定则抛出异常
         *
         * @example
         * ```ts
         * // 1. 飞行到一个位置
         * camera.setView({
         *     position : [117.16, 32.71, 15000.0]
         * });
         *
         * // 2. 飞行到一个矩形区域
         * camera.setView({
         *     rect : [west, south, east, north]
         * });
         *
         * // 3. 飞行到一个位置并带有角度
         * camera.setView({
         *     position : [117.16, 32.71, 15000.0],
         *     heading : Cesium.Math.toRadians(175.0),
         *     pitch : Cesium.Math.toRadians(-35.0),
         *     roll : 0.0
         * });
         * ```
         */
        setView(options) {
            /// 构建目标
            let destination;
            let orientation;
            /// 指定坐标
            if (Cegore.TypeCheck.isDefined(options.position))
                destination = this.fromPosition(options.position);
            /// 指定范围
            else if (Cegore.TypeCheck.isDefined(options.rect))
                destination = this.fromRectange(options.rect);
            /// 没有指定坐标或者范围
            else
                throw 'position or rect is need.';
            if (Cegore.TypeCheck.isDefined(options.orientation))
                orientation = this.fromOrientation(options.orientation);
            /// 调用内部对象的接口
            return this._czData.camera.setView({
                destination: destination,
                orientation: orientation,
                endTransform: Cesium.Matrix4.IDENTITY
            });
        }
        /**
         * 获取当前相机的位置信息
         */
        getView() {
            return {
                position: this.position,
                orientation: this.orientation
            };
        }
        /**
         *
         * 通过目标点和相对位置设置相机的位置和方向
         *
         * lookAt操作会锁定交互中心为目标点，恢复地心交互请使用clearLookAt()
         *
         * @param target
         * @param offset
         */
        lookAt(target, offset) {
            if (!Cegore.TypeCheck.isInstanceOf(target, Cegore.Position))
                target = new Cegore.Position(target);
            if (!Cegore.TypeCheck.isInstanceOf(offset, Cegore.HeadingPitchDistance))
                offset = new Cegore.HeadingPitchDistance(offset);
            this._czCamera.lookAt(this.fromPosition(target), offset._asCzObject());
        }
        /**
         * 通过视点和目标点设置相机的位置和方向
         *
         * lookAt操作会锁定交互中心为目标点，恢复地心交互请使用clearLookAt()
         *
         * @param eye 视点
         * @param target 目标点
         */
        lookAtFromTo(eye, target) {
            if (!Cegore.TypeCheck.isInstanceOf(target, Cegore.Position))
                target = new Cegore.Position(target);
            if (!Cegore.TypeCheck.isInstanceOf(eye, Cegore.Position))
                eye = new Cegore.Position(eye);
            let ceye = this.fromPosition(eye);
            let ctar = this.fromPosition(target);
            /// 计算变换矩阵
            var trans = Cesium.Transforms.eastNorthUpToFixedFrame(ctar, Cesium.Ellipsoid.WGS84);
            var invTrans = Cesium.Matrix4.inverse(trans, new Cesium.Matrix4());
            /// 通过逆矩阵计算偏移信息
            var offset = Cesium.Matrix4.multiplyByPoint(invTrans, ceye, new Cesium.Cartesian3());
            this._czCamera.lookAtTransform(trans, offset);
        }
        /**
         * 清除lookAt
         */
        clearLookAt() {
            this._czCamera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        }
        /**
         * xyz 转 Cesium.Cartesian3
         * @param pos
         */
        fromRectange(rect) {
            if (!Cegore.TypeCheck.isInstanceOf(rect, Cegore.Rectangle))
                rect = new Cegore.Rectangle(rect);
            return Cesium.Rectangle.fromDegrees(rect.minx, rect.miny, rect.maxx, rect.maxy);
        }
        /**
         * Position 转 Cesium.Cartesian3
         * @param pos
         */
        fromPosition(pos) {
            if (!Cegore.TypeCheck.isInstanceOf(pos, Cegore.Position))
                pos = new Cegore.Position(pos);
            return Cesium.Cartesian3.fromDegrees(pos.x, pos.y, pos.z, this._czData.ellipsoid);
        }
        /**
         * @private
         * @param ori
         */
        fromOrientation(ori) {
            if (!Cegore.TypeCheck.isInstanceOf(ori, Cegore.HeadingPitchRoll))
                ori = new Cegore.HeadingPitchRoll(ori);
            return {
                heading: Cegore.GeoMath.toRadian(ori.heading),
                pitch: Cegore.GeoMath.toRadian(ori.pitch),
                roll: Cegore.GeoMath.toRadian(ori.roll),
            };
        }
    }
    Cegore.Camera = Camera;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    /**
     * 相机控制器
     * @alias CameraController
     * @constructor
     *
     * @param scene The scene.
     */
    class CameraController {
        set viewRectange(range) {
            this._viewRectange = range.clone(this._viewRectange);
            if (range) {
                const center = Cesium.Rectangle.center(range);
                center.height = 0;
                this._viewCenter = Cesium.Cartographic.toCartesian(center, undefined, this._viewCenter);
            }
        }
        get viewRectange() { return this._viewRectange; }
        constructor(scene) {
            /**
             * 是否启用交互操作
             * @default true
             */
            this.enableInputs = true;
            /**
             * 是否启用平移操作
             * @default true
             */
            this.enableTranslate = true;
            /**
             * 是否启用缩放操作
             * @default true
             */
            this.enableZoom = true;
            /**
             * 是否启用旋转操作
             * @default true
             */
            this.enableRotate = true;
            /**
             * 是否启用倾斜操作
             * @default true
             */
            this.enableTilt = true;
            /**
             * 是否启用升降
             */
            this.enableUpDown = true;
            /**
             * 是否启用自由操作
             * @default true
             */
            this.enableLook = true;
            /**
             * 旋转惯性 `[0, 1)`
             * @default 0.9
             */
            this.inertiaSpin = 0.9;
            /**
             * 平移惯性 `[0, 1)`
             * @default 0.9
             */
            this.inertiaTranslate = 0.9;
            /**
             * 缩放惯性 `[0, 1)`
             * @default 0.8
             */
            this.inertiaZoom = 0.8;
            /**
             * A parameter in the range `[0, 1)` used to limit the range
             * of various user inputs to a percentage of the window width/height per animation frame.
             * This helps keep the camera under control in low-frame-rate situations.
             * @default 0.1
             */
            this.maximumMovementRatio = 0.1;
            /**
             * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.
             * @default 3.0
             */
            this.bounceAnimationTime = 3.0;
            /**
             * 缩放时的最小距离，单位：米
             * @default 1.0
             */
            this.minimumZoomDistance = 1.0;
            /**
             * 缩放时的最大距离：单位：米
             * @default Number.POSITIVE_INFINITY
             */
            this.maximumZoomDistance = 20000000;
            /**
             * 倾斜时最小弧度，单位：弧度
             * @default 1.0
             */
            this.minimumPitch = Cesium.Math.toRadians(0);
            /**
             * 倾斜时最大弧度：单位：弧度
             * @default Number.POSITIVE_INFINITY
             */
            this.maximumPitch = Cesium.Math.toRadians(90);
            /**
             * 倾斜时最小弧度，单位：弧度
             * @default 1.0
             */
            this.lookViewMinimumPitch = Cesium.Math.toRadians(0);
            /**
             * 倾斜时最大弧度：单位：弧度
             * @default Number.POSITIVE_INFINITY
             */
            this.lookViewMaximumPitch = Cesium.Math.toRadians(90);
            /**
             * 平移操作事件
             * @default Cesium.CameraEventType.LEFT_DRAG
             */
            this.translateEventTypes = Cesium.CameraEventType.LEFT_DRAG;
            /**
             * 缩放操作事件
             * @default [Cesium.CameraEventType.WHEEL,Cesium.CameraEventType.PINCH]
             */
            this.zoomEventTypes = [Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH];
            /**
             * 旋转操作的事件
             * @default Cesium.CameraEventType.LEFT_DRAG
             */
            this.rotateEventTypes = Cesium.CameraEventType.LEFT_DRAG;
            /**
             * 倾斜操作事件
             */
            this.tiltEventTypes = [
                Cesium.CameraEventType.RIGHT_DRAG,
                Cesium.CameraEventType.PINCH,
                { eventType: Cesium.CameraEventType.LEFT_DRAG, modifier: Cesium.KeyboardEventModifier.CTRL }
            ];
            /**
             * 升降事件
             */
            this.upDownEventTypes = { eventType: Cesium.CameraEventType.LEFT_DRAG, modifier: Cesium.KeyboardEventModifier.ALT };
            /**
             * 自由观看事件
             * @default {eventType:CameraEventType.LEFT_DRAG,modifier:KeyboardEventModifier.SHIFT}
             */
            this.lookEventTypes = {
                eventType: Cesium.CameraEventType.LEFT_DRAG,
                modifier: Cesium.KeyboardEventModifier.SHIFT
            };
            /**
             * Enables or disables camera collision detection with terrain.
             * @default true
             */
            this.enableCollisionDetection = true;
            /**
             * 是否启用平面模式
             */
            this.enableFlatMode = false;
            /**
             * 平面交互高程
             */
            this.flatModeHeight = 0;
            /**
             * 交互平面偏移值
             */
            this.flatModeOffset = 0;
            ///
            this._lastInertiaSpinMovement = undefined;
            this._lastInertiaZoomMovement = undefined;
            this._lastInertiaTranslateMovement = undefined;
            this._lastInertiaTiltMovement = undefined;
            this._horizontalRotationAxis = undefined;
            // Constants, Make any of these public?
            this._zoomFactor = 5.0;
            this._maximumRotateRate = 1.77;
            this._minimumRotateRate = 1.0 / 5000.0;
            this._minimumZoomRate = 20.0;
            this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.
            if (!Cesium.defined(scene)) {
                throw new Cesium.DeveloperError('scene is required.');
            }
            /// 事件聚合
            this._scene = scene;
            this._aggregator = new Cesium.CameraEventAggregator(scene.canvas);
        }
        /**
         *
         */
        isDestroyed() {
            return false;
        }
        /**
         * @example
         * controller = controller && controller.destroy();
         */
        destroy() {
            this._aggregator = this._aggregator && this._aggregator.destroy();
            return Cesium.destroyObject(this);
        }
        /**
         * 更新交互状态
         */
        update() {
            /// 
            const scene = this._scene;
            const mode = scene.mode;
            ///
            if (mode === Cesium.SceneMode.SCENE2D) {
                this.update2D();
            }
            else if (mode === Cesium.SceneMode.COLUMBUS_VIEW) {
                this._horizontalRotationAxis = Cesium.Cartesian3.UNIT_Z;
                this.updateCV();
            }
            else if (mode === Cesium.SceneMode.SCENE3D) {
                this._horizontalRotationAxis = undefined;
                this.update3D();
            }
            ///
            this._aggregator.reset();
        }
        onMap() {
            return true;
        }
        _checkLimit(active, oldPos, newPos, oldHpr, newHpr) {
            const globe = this._scene.globe;
            if (this.enableCollisionDetection && globe && globe.show) {
                const ray = checkLimitRay;
                const dir = newPos.clone(ray.direction);
                Cesium.Cartesian3.normalize(dir, dir);
                const coll = globe.pick(ray, this._scene, checkLimitHist);
                if (Cesium.defined(coll) && Cesium.Cartesian3.magnitudeSquared(newPos) < Cesium.Cartesian3.magnitudeSquared(coll)) {
                    return false;
                }
            }
            /// 限制视图范围
            if (this._viewRectange && !Cesium.Cartesian3.equals(oldPos, newPos) && active === this.spin3D) {
                const oldCart = Cesium.Cartographic.fromCartesian(oldPos, undefined, this._temp_view_c0);
                const newCart = Cesium.Cartographic.fromCartesian(newPos, undefined, this._temp_view_c1);
                /// 在视图范围内
                if (Cesium.Rectangle.contains(this._viewRectange, newCart)) {
                    console.info('范围内');
                    return true;
                }
                /// 
                oldCart.height = 0;
                newCart.height = 0;
                const oldvv = Cesium.Cartographic.toCartesian(oldCart, undefined, this._temp_view_p0);
                const newvv = Cesium.Cartographic.toCartesian(newCart, undefined, this._temp_view_p1);
                const d1 = Cesium.Cartesian3.distanceSquared(this._viewCenter, oldvv);
                const d2 = Cesium.Cartesian3.distanceSquared(this._viewCenter, newvv);
                console.info('范围外', d2 - d1);
                /// 越来越远
                if (d2 > d1)
                    return false;
            }
            return true;
        }
        /**
         * 获取系统椭球体
         */
        getEllipsoid() {
            return Cesium.defined(this._scene.globe) ? this._scene.globe.ellipsoid : this._scene.mapProjection.ellipsoid;
        }
        update2D() { }
        updateCV() { }
        update3D() {
            this.reactToInput(this.enableRotate, this.rotateEventTypes, this.spin3D, this.inertiaSpin, '_lastInertiaSpinMovement');
            this.reactToInput(this.enableZoom, this.zoomEventTypes, this.zoom3D, this.inertiaZoom, '_lastInertiaZoomMovement');
            this.reactToInput(this.enableTilt, this.tiltEventTypes, this.tilt3D, this.inertiaSpin, '_lastInertiaTiltMovement');
            this.reactToInput(this.enableLook, this.lookEventTypes, this.look3D);
            this.reactToInput(this.enableUpDown, this.upDownEventTypes, this.upDown);
        }
        /// 根据输入事件分发操作到对应的处理程序
        reactToInput(enabled, eventTypes, action, inertiaConstant, inertiaStateName) {
            /// 未指定事件
            if (!Cesium.defined(eventTypes))
                return;
            /// 操作被禁用
            if (!this.enableInputs || !enabled)
                return;
            /// 事件聚合
            const aggregator = this._aggregator;
            const scene = this._scene;
            const camera = scene.camera;
            /// 事件类型
            let eventTypeArray = eventTypes;
            if (!Array.isArray(eventTypeArray)) {
                scratchEventTypeArray[0] = eventTypes;
                eventTypeArray = scratchEventTypeArray;
            }
            /// 
            const pos = Cesium.Cartesian3.clone(camera.positionWC, checkLimitCameraPos);
            const hpr = getViewPose(scene, camera, checkLimitCameraHPR);
            ///
            const length = eventTypeArray.length;
            for (let i = 0; i < length; ++i) {
                const eventType = eventTypeArray[i];
                const type = (Cesium.defined(eventType.eventType) ? eventType.eventType : eventType);
                const modifier = eventType.modifier;
                ///
                const movement = aggregator.isMoving(type, modifier) && aggregator.getMovement(type, modifier);
                const startPosition = aggregator.getStartMousePosition(type, modifier);
                ////
                if (movement) {
                    try {
                        action.call(this, startPosition, movement);
                    }
                    catch (e) { }
                }
                else if (inertiaConstant < 1.0) {
                    maintainInertia(aggregator, type, modifier, inertiaConstant, action, this, inertiaStateName);
                }
            }
            /// 
            const pos2 = Cesium.Cartesian3.clone(camera.positionWC, checkLimitCameraPos2);
            const hpr2 = getViewPose(scene, camera, checkLimitCameraHPR2);
            if (!this._checkLimit(action, pos, pos2, hpr, hpr2)) {
                camera.setView({ destination: pos, orientation: hpr });
            }
        }
        pickReal(mousePosition, result) {
            const scene = this._scene;
            const globe = scene.globe;
            const camera = scene.camera;
            const ray = camera.getPickRay(mousePosition, scratch_PickGlobe_Ray);
            /// 
            let depthPick, rayPick;
            /// 拾取场景
            if (scene.pickPositionSupported) {
                if (scene.pick(mousePosition))
                    depthPick = scene.pickPosition(mousePosition, scratch_PickGlobe_DepthIntersection);
            }
            /// 拾取地球
            if (globe && globe.show) {
                rayPick = globe.pick(ray, scene, scratch_PickGlobe_RayIntersection);
            }
            /// 
            const pickDistance = Cesium.defined(depthPick) ? Cesium.Cartesian3.distance(depthPick, camera.positionWC) : Number.POSITIVE_INFINITY;
            const rayDistance = Cesium.defined(rayPick) ? Cesium.Cartesian3.distance(rayPick, camera.positionWC) : Number.POSITIVE_INFINITY;
            /// 返回比较近的
            if (pickDistance < rayDistance) {
                return Cesium.Cartesian3.clone(depthPick, result);
            }
            if (rayDistance != Number.POSITIVE_INFINITY) {
                return Cesium.Cartesian3.clone(rayPick, result);
            }
            ///
            return undefined;
        }
        pickFlat(mousePosition, result) {
            const scene = this._scene;
            const camera = scene.camera;
            const ray = camera.getPickRay(mousePosition, scratch_PickGlobe_Ray);
            /// 
            const ellipsoid = this.getEllipsoid();
            const scale = 1 + (this.flatModeHeight + this.flatModeOffset) / ellipsoid.maximumRadius;
            const radii = Cesium.Cartesian3.multiplyByScalar(ellipsoid.radii, scale, scratch_PickGlobe_Radii);
            const newEllipsoid = Cesium.Ellipsoid.fromCartesian3(radii, scratch_PickGlobe_Ellipsoid);
            const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, newEllipsoid);
            if (!Cesium.defined(intersection))
                return undefined;
            ///
            if (intersection.start > 0.0) {
                return Cesium.Ray.getPoint(ray, intersection.start, result);
            }
            if (intersection.start == 0) {
                const inverseRadii = ellipsoid.oneOverRadii;
                const q = Cesium.Cartesian3.multiplyComponents(inverseRadii, ray.origin, radii);
                const q2 = Cesium.Cartesian3.magnitudeSquared(q);
                if (q2 < 1.0) {
                    return Cesium.Ray.getPoint(ray, intersection.stop, result);
                }
                return Cesium.Ray.getPoint(ray, 1, result);
            }
            return undefined;
        }
        /// 拾取
        pickPosition(mousePosition, result) {
            if (this.enableFlatMode) {
                return this.pickFlat(mousePosition, result);
            }
            else {
                return this.pickReal(mousePosition, result);
            }
        }
        rotate3D(startPosition, movement, options) {
            options = Cesium.defaultValue(options, {});
            const rotateOnlyVertical = Cesium.defaultValue(options.onlyVertical, false);
            const rotateOnlyHorizontal = Cesium.defaultValue(options.onlyHorizontal, false);
            const minimumPitch = Cesium.defaultValue(options.minimumPitch, -180);
            const maximumPitch = Cesium.defaultValue(options.maximumPitch, 180);
            const scene = this._scene;
            var camera = scene.camera;
            var canvas = scene.canvas;
            ///
            const dir = camera.direction;
            const front = Cesium.Cartesian3.cross(Cesium.Cartesian3.UNIT_Z, camera.right, new Cesium.Cartesian3());
            ///
            const acos = Cesium.Cartesian3.dot(front, dir);
            let rr = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
            if (acos < 0)
                rr = -rr;
            ///
            const pitch = -Math.atan2(dir.z, rr);
            const rotateRate = this._maximumRotateRate;
            ///
            let phiWindowRatio = (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;
            let thetaWindowRatio = (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;
            phiWindowRatio = Math.min(phiWindowRatio, this.maximumMovementRatio);
            thetaWindowRatio = Math.min(thetaWindowRatio, this.maximumMovementRatio);
            let deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;
            let deltaTheta = rotateRate * thetaWindowRatio * Math.PI;
            ///
            if (pitch - deltaTheta > maximumPitch) {
                deltaTheta = pitch - maximumPitch;
            }
            if (pitch - deltaTheta < minimumPitch) {
                deltaTheta = pitch - minimumPitch;
            }
            if (!rotateOnlyVertical) {
                //camera.rotateRight(deltaPhi);
                camera.rotate(Cesium.Cartesian3.UNIT_Z, -deltaPhi);
            }
            if (!rotateOnlyHorizontal) {
                //camera.rotateUp(deltaTheta);
                camera.rotate(camera.right, -deltaTheta);
            }
        }
        spin3D(startPosition, movement) {
            var scene = this._scene;
            var camera = scene.camera;
            /// lookAt
            if (!Cesium.Matrix4.equals(camera.transform, Cesium.Matrix4.IDENTITY)) {
                this.rotate3D(startPosition, movement, { minimumPitch: this.lookViewMinimumPitch, maximumPitch: this.lookViewMaximumPitch });
                return;
            }
            this.pan3D(startPosition, movement);
        }
        pan3D(startPosition, movement) {
            const scene = this._scene;
            const camera = scene.camera;
            ///
            const startMousePosition = Cesium.Cartesian2.clone(movement.startPosition, pan3DStartMousePosition);
            const endMousePosition = Cesium.Cartesian2.clone(movement.endPosition, pan3DEndMousePosition);
            let p0, p1;
            ///
            p0 = this.pickPosition(startMousePosition, pan3DP0);
            if (!Cesium.defined(p0))
                return;
            ///
            const ray = camera.getPickRay(endMousePosition, pan3DPickRay);
            p1 = pickBySimilar(Cesium.Cartesian3.magnitude(p0), ray, pan3DP1);
            if (!Cesium.defined(p1))
                return;
            ///
            p0 = camera.worldToCameraCoordinates(p0, p0);
            p1 = camera.worldToCameraCoordinates(p1, p1);
            if (!Cesium.defined(camera.constrainedAxis)) {
                Cesium.Cartesian3.normalize(p0, p0);
                Cesium.Cartesian3.normalize(p1, p1);
                const dot = Cesium.Cartesian3.dot(p0, p1);
                const axis = Cesium.Cartesian3.cross(p0, p1, pan3DTemp0);
                /// dot is in [0, 1]
                if (dot < 1.0 && !Cesium.Cartesian3.equalsEpsilon(axis, Cesium.Cartesian3.ZERO, Cesium.Math.EPSILON14)) {
                    const angle = Math.acos(dot);
                    camera.rotate(axis, angle);
                }
            }
            else {
                const basis0 = camera.constrainedAxis;
                const basis1 = Cesium.Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);
                Cesium.Cartesian3.cross(basis1, basis0, basis1);
                Cesium.Cartesian3.normalize(basis1, basis1);
                const basis2 = Cesium.Cartesian3.cross(basis0, basis1, pan3DTemp1);
                const startRho = Cesium.Cartesian3.magnitude(p0);
                const startDot = Cesium.Cartesian3.dot(basis0, p0);
                const startTheta = Math.acos(startDot / startRho);
                const startRej = Cesium.Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);
                Cesium.Cartesian3.subtract(p0, startRej, startRej);
                Cesium.Cartesian3.normalize(startRej, startRej);
                const endRho = Cesium.Cartesian3.magnitude(p1);
                const endDot = Cesium.Cartesian3.dot(basis0, p1);
                const endTheta = Math.acos(endDot / endRho);
                const endRej = Cesium.Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);
                Cesium.Cartesian3.subtract(p1, endRej, endRej);
                Cesium.Cartesian3.normalize(endRej, endRej);
                let startPhi = Math.acos(Cesium.Cartesian3.dot(startRej, basis1));
                if (Cesium.Cartesian3.dot(startRej, basis2) < 0) {
                    startPhi = Cesium.Math.TWO_PI - startPhi;
                }
                let endPhi = Math.acos(Cesium.Cartesian3.dot(endRej, basis1));
                if (Cesium.Cartesian3.dot(endRej, basis2) < 0) {
                    endPhi = Cesium.Math.TWO_PI - endPhi;
                }
                const deltaPhi = startPhi - endPhi;
                let east;
                if (Cesium.Cartesian3.equalsEpsilon(basis0, camera.position, Cesium.Math.EPSILON2)) {
                    east = camera.right;
                }
                else {
                    east = Cesium.Cartesian3.cross(basis0, camera.position, pan3DTemp0);
                }
                const planeNormal = Cesium.Cartesian3.cross(basis0, east, pan3DTemp0);
                const side0 = Cesium.Cartesian3.dot(planeNormal, Cesium.Cartesian3.subtract(p0, basis0, pan3DTemp1));
                const side1 = Cesium.Cartesian3.dot(planeNormal, Cesium.Cartesian3.subtract(p1, basis0, pan3DTemp1));
                let deltaTheta;
                if (side0 > 0 && side1 > 0) {
                    deltaTheta = endTheta - startTheta;
                }
                else if (side0 > 0 && side1 <= 0) {
                    if (Cesium.Cartesian3.dot(camera.position, basis0) > 0) {
                        deltaTheta = -startTheta - endTheta;
                    }
                    else {
                        deltaTheta = startTheta + endTheta;
                    }
                }
                else {
                    deltaTheta = startTheta - endTheta;
                }
                ///
                camera.rotateRight(deltaPhi);
                camera.rotateUp(deltaTheta);
            }
        }
        zoom3D(startPosition, movement) {
            if (Cesium.defined(movement.distance)) {
                movement = movement.distance;
            }
            const scene = this._scene;
            const camera = scene.camera;
            const canvas = scene.canvas;
            ///
            let intersection;
            const lookAtCenter = Cesium.Matrix4.equals(camera.transform, Cesium.Matrix4.IDENTITY);
            if (lookAtCenter) {
                intersection = this.pickReal(startPosition, zoomIntersection);
                ///
                if (this.enableFlatMode) {
                    if (intersection) {
                        const ellipsoid = this.getEllipsoid();
                        const c = Cesium.Cartographic.fromCartesian(intersection, ellipsoid, zoomCartographic);
                        this.flatModeHeight = c.height;
                    }
                    else {
                        intersection = this.pickFlat(startPosition, zoomIntersection);
                    }
                }
            }
            else {
                intersection = Cesium.Matrix4.getTranslation(camera.transform, zoomIntersection);
            }
            ///
            if (!intersection)
                return;
            ///
            const dir = Cesium.Cartesian3.subtract(intersection, camera.positionWC, zoomDirection);
            Cesium.Cartesian3.normalize(dir, dir);
            const distanceMeasure = Cesium.Cartesian3.distance(camera.positionWC, intersection);
            ///
            const minHeight = this.minimumZoomDistance;
            const maxHeight = this.maximumZoomDistance;
            const minDistance = distanceMeasure - minHeight;
            let zoomRate = this._zoomFactor * minDistance;
            zoomRate = Cesium.Math.clamp(zoomRate, this._minimumZoomRate, this._maximumZoomRate);
            const diff = movement.endPosition.y - movement.startPosition.y;
            const rangeWindowRatio = Math.min(diff / canvas.clientHeight, this.maximumMovementRatio);
            let distance = zoomRate * rangeWindowRatio;
            /// 
            if (distanceMeasure - distance < this.minimumZoomDistance) {
                distance = distanceMeasure - this.minimumZoomDistance;
            }
            if (distanceMeasure - distance > this.maximumZoomDistance) {
                distance = distanceMeasure - this.maximumZoomDistance;
            }
            /// 
            if (lookAtCenter) {
                /// 
                Cesium.Cartesian3.multiplyByScalar(dir, distance, zoomTargePosition);
                const target = Cesium.Cartesian3.add(zoomTargePosition, camera.positionWC, zoomTargePosition);
                const pose = getViewPose(scene, camera, zoomHeadingPitchRool);
                camera.setView({ destination: target, orientation: pose, endTransform: camera.transform });
            }
            else
                camera.zoomIn(distance);
        }
        tilt3D(startPosition, movement) {
            const scene = this._scene;
            const camera = scene.camera;
            if (!Cesium.Matrix4.equals(camera.transform, Cesium.Matrix4.IDENTITY)) {
                return;
            }
            if (Cesium.defined(movement.angleAndHeight)) {
                movement = movement.angleAndHeight;
            }
            const canvas = scene.canvas;
            const ellipsoid = this.getEllipsoid();
            /// 
            let center;
            if (Cesium.Cartesian2.equals(this._tiltCenterMousePosition, startPosition)) {
                center = this._tiltCenter;
            }
            else {
                const sc = tilt3DScreenCenter;
                sc.x = canvas.width * 0.5;
                sc.y = canvas.height * 0.5;
                center = this.pickPosition(sc, tile3DCenter);
                if (!Cesium.defined(center))
                    center = this.pickPosition(startPosition, tile3DCenter);
                if (Cesium.defined(center)) {
                    this._tiltCenter = center;
                    this._tiltCenterMousePosition = startPosition.clone(this._tiltCenterMousePosition);
                }
            }
            if (!Cesium.defined(center)) {
                return;
            }
            /// 锁定
            const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);
            const oldTransform = Cesium.Matrix4.clone(camera.transform, tilt3DOldTransform);
            camera._setTransform(transform);
            ///
            this.rotate3D(startPosition, movement, { minimumPitch: this.minimumPitch, maximumPitch: this.maximumPitch });
            /// 还原
            camera._setTransform(oldTransform);
        }
        look3D(startPosition, movement, rotationAxis) {
            const scene = this._scene;
            const camera = scene.camera;
            let startPos = look3DStartPos;
            startPos.x = movement.startPosition.x;
            startPos.y = 0.0;
            let endPos = look3DEndPos;
            endPos.x = movement.endPosition.x;
            endPos.y = 0.0;
            let startRay = camera.getPickRay(startPos, look3DStartRay);
            let endRay = camera.getPickRay(endPos, look3DEndRay);
            let angle = 0.0;
            let start, end;
            if (camera.frustum instanceof Cesium.OrthographicFrustum) {
                start = startRay.origin;
                end = endRay.origin;
                Cesium.Cartesian3.add(camera.direction, start, start);
                Cesium.Cartesian3.add(camera.direction, end, end);
                Cesium.Cartesian3.subtract(start, camera.position, start);
                Cesium.Cartesian3.subtract(end, camera.position, end);
                Cesium.Cartesian3.normalize(start, start);
                Cesium.Cartesian3.normalize(end, end);
            }
            else {
                start = startRay.direction;
                end = endRay.direction;
            }
            var dot = Cesium.Cartesian3.dot(start, end);
            if (dot < 1.0) { // dot is in [0, 1]
                angle = Math.acos(dot);
            }
            angle = (movement.startPosition.x > movement.endPosition.x) ? -angle : angle;
            var horizontalRotationAxis = this._horizontalRotationAxis;
            if (Cesium.defined(rotationAxis)) {
                camera.look(rotationAxis, -angle);
            }
            else if (Cesium.defined(horizontalRotationAxis)) {
                camera.look(horizontalRotationAxis, -angle);
            }
            else {
                camera.lookLeft(angle);
            }
            startPos.x = 0.0;
            startPos.y = movement.startPosition.y;
            endPos.x = 0.0;
            endPos.y = movement.endPosition.y;
            startRay = camera.getPickRay(startPos, look3DStartRay);
            endRay = camera.getPickRay(endPos, look3DEndRay);
            angle = 0.0;
            if (camera.frustum instanceof Cesium.OrthographicFrustum) {
                start = startRay.origin;
                end = endRay.origin;
                Cesium.Cartesian3.add(camera.direction, start, start);
                Cesium.Cartesian3.add(camera.direction, end, end);
                Cesium.Cartesian3.subtract(start, camera.position, start);
                Cesium.Cartesian3.subtract(end, camera.position, end);
                Cesium.Cartesian3.normalize(start, start);
                Cesium.Cartesian3.normalize(end, end);
            }
            else {
                start = startRay.direction;
                end = endRay.direction;
            }
            dot = Cesium.Cartesian3.dot(start, end);
            if (dot < 1.0) { // dot is in [0, 1]
                angle = Math.acos(dot);
            }
            angle = (movement.startPosition.y > movement.endPosition.y) ? -angle : angle;
            rotationAxis = Cesium.defaultValue(rotationAxis, horizontalRotationAxis);
            if (Cesium.defined(rotationAxis)) {
                var direction = camera.direction;
                var negativeRotationAxis = Cesium.Cartesian3.negate(rotationAxis, look3DNegativeRot);
                var northParallel = Cesium.Cartesian3.equalsEpsilon(direction, rotationAxis, Cesium.Math.EPSILON2);
                var southParallel = Cesium.Cartesian3.equalsEpsilon(direction, negativeRotationAxis, Cesium.Math.EPSILON2);
                if ((!northParallel && !southParallel)) {
                    dot = Cesium.Cartesian3.dot(direction, rotationAxis);
                    var angleToAxis = Cesium.Math.acosClamped(dot);
                    if (angle > 0 && angle > angleToAxis) {
                        angle = angleToAxis - Cesium.Math.EPSILON4;
                    }
                    dot = Cesium.Cartesian3.dot(direction, negativeRotationAxis);
                    angleToAxis = Cesium.Math.acosClamped(dot);
                    if (angle < 0 && -angle > angleToAxis) {
                        angle = -angleToAxis + Cesium.Math.EPSILON4;
                    }
                    var tangent = Cesium.Cartesian3.cross(rotationAxis, direction, look3DTan);
                    camera.look(tangent, angle);
                }
                else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {
                    camera.look(camera.right, -angle);
                }
            }
            else {
                camera.lookUp(angle);
            }
        }
        upDown(startPosition, movement) {
            if (Cesium.defined(movement.distance)) {
                movement = movement.distance;
            }
            const scene = this._scene;
            const camera = scene.camera;
            const canvas = scene.canvas;
            if (!Cesium.Matrix4.equals(camera.transform, Cesium.Matrix4.IDENTITY)) {
                return;
            }
            ///
            let intersection;
            const lookAtCenter = Cesium.Matrix4.equals(camera.transform, Cesium.Matrix4.IDENTITY);
            if (lookAtCenter) {
                intersection = this.pickPosition(startPosition, zoomIntersection);
            }
            else {
                intersection = Cesium.Matrix4.getTranslation(camera.transform, zoomIntersection);
            }
            ///
            if (!intersection)
                return;
            const rayUpDwon = upDownRay;
            camera.positionWC.clone(rayUpDwon.origin);
            const dirUpDown = rayUpDwon.direction;
            Cesium.Cartesian3.subtract(Cesium.Cartesian3.ZERO, camera.positionWC, dirUpDown);
            Cesium.Cartesian3.normalize(dirUpDown, dirUpDown);
            ///
            const minHeight = this.minimumZoomDistance;
            const maxHeight = this.maximumZoomDistance;
            const dir = Cesium.Cartesian3.subtract(intersection, camera.positionWC, zoomDirection);
            Cesium.Cartesian3.normalize(dir, dir);
            const distanceMeasure = Cesium.Cartesian3.distance(camera.positionWC, intersection);
            ///
            const minDistance = distanceMeasure - minHeight;
            let zoomRate = this._zoomFactor * minDistance;
            zoomRate = Cesium.Math.clamp(zoomRate, this._minimumZoomRate, this._maximumZoomRate);
            const diff = movement.endPosition.y - movement.startPosition.y;
            const rangeWindowRatio = Math.min(diff / canvas.clientHeight, this.maximumMovementRatio);
            const distance = zoomRate * rangeWindowRatio;
            ///
            camera.move(dirUpDown, -distance);
            /// 
            if (this.enableFlatMode) {
                this.flatModeHeight += distance;
            }
        }
    }
    Cegore.CameraController = CameraController;
    /// for reactToInput
    const scratchEventTypeArray = [];
    /// 拾取
    const scratch_PickGlobe_Ray = new Cesium.Ray();
    const scratch_PickGlobe_Radii = new Cesium.Cartesian3();
    const scratch_PickGlobe_Ellipsoid = new Cesium.Ellipsoid();
    const scratch_PickGlobe_Intersection = new Cesium.Interval();
    const scratch_PickGlobe_DepthIntersection = new Cesium.Cartesian3();
    const scratch_PickGlobe_RayIntersection = new Cesium.Cartesian3();
    /// 衰减函数
    function decay(time, coefficient) {
        if (time < 0) {
            return 0.0;
        }
        var tau = (1.0 - coefficient) * 25.0;
        return Math.exp(-tau * time);
    }
    function sameMousePosition(movement) {
        return Cesium.Cartesian2.equalsEpsilon(movement.startPosition, movement.endPosition, Cesium.Math.EPSILON14);
    }
    // If the time between mouse down and mouse up is not between
    // these thresholds, the camera will not move with inertia.
    // This value is probably dependent on the browser and/or the
    // hardware. Should be investigated further.
    const inertiaMaxClickTimeThreshold = 0.4;
    function maintainInertia(aggregator, type, modifier, decayCoef, action, object, lastMovementName) {
        var movementState = object[lastMovementName]; // as MovementState;
        if (!Cesium.defined(movementState)) {
            movementState = object[lastMovementName] = {
                startPosition: new Cesium.Cartesian2(),
                endPosition: new Cesium.Cartesian2(),
                motion: new Cesium.Cartesian2(),
                active: false
            };
        }
        var ts = aggregator.getButtonPressTime(type, modifier);
        var tr = aggregator.getButtonReleaseTime(type, modifier);
        var threshold = ts && tr && ((tr.getTime() - ts.getTime()) / 1000.0);
        var now = new Date();
        var fromNow = tr && ((now.getTime() - tr.getTime()) / 1000.0);
        ///
        if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {
            var d = decay(fromNow, decayCoef);
            if (!movementState.active) {
                var lastMovement = aggregator.getLastMovement(type, modifier);
                if (!Cesium.defined(lastMovement) || sameMousePosition(lastMovement)) {
                    return;
                }
                movementState.motion.x = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
                movementState.motion.y = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
                movementState.startPosition = Cesium.Cartesian2.clone(lastMovement.startPosition, movementState.startPosition);
                movementState.endPosition = Cesium.Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);
                movementState.endPosition = Cesium.Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);
                movementState.active = true;
            }
            else {
                movementState.startPosition = Cesium.Cartesian2.clone(movementState.endPosition, movementState.startPosition);
                movementState.endPosition = Cesium.Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);
                movementState.endPosition = Cesium.Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);
                movementState.motion = Cesium.Cartesian2.clone(Cesium.Cartesian2.ZERO, movementState.motion);
            }
            // If value from the decreasing exponential function is close to zero,
            // the end coordinates may be NaN.
            if (isNaN(movementState.endPosition.x) || isNaN(movementState.endPosition.y) || Cesium.Cartesian2.distance(movementState.startPosition, movementState.endPosition) < 0.5) {
                movementState.active = false;
                return;
            }
            if (!aggregator.isButtonDown(type, modifier)) {
                var startPosition = aggregator.getStartMousePosition(type, modifier);
                action.call(object, startPosition, movementState);
            }
        }
        else {
            movementState.active = false;
        }
    }
    function getHeading(direction, up) {
        let heading = 0;
        if (!Cesium.Math.equalsEpsilon(Math.abs(direction.z), 1.0, Cesium.Math.EPSILON3)) {
            heading = Math.atan2(direction.y, direction.x) - Cesium.Math.PI_OVER_TWO;
        }
        else {
            heading = Math.atan2(up.y, up.x) - Cesium.Math.PI_OVER_TWO;
        }
        return Cesium.Math.TWO_PI - Cesium.Math.zeroToTwoPi(heading);
    }
    function getPitch(direction) {
        return Cesium.Math.PI_OVER_TWO - Cesium.Math.acosClamped(direction.z);
    }
    function getRoll(direction, up, right) {
        let roll = 0.0;
        if (!Cesium.Math.equalsEpsilon(Math.abs(direction.z), 1.0, Cesium.Math.EPSILON3)) {
            roll = Math.atan2(-right.z, up.z);
            roll = Cesium.Math.zeroToTwoPi(roll + Cesium.Math.TWO_PI);
        }
        return roll;
    }
    ///
    const scratchViewPoseMatrix1 = new Cesium.Matrix4();
    const scratchViewPoseMatrix2 = new Cesium.Matrix4();
    function getViewPose(scene, camera, hpr) {
        if (scene.mode !== Cesium.SceneMode.MORPHING) {
            const ellipsoid = scene.mapProjection.ellipsoid;
            const oldTransform = Cesium.Matrix4.clone(camera.transform, scratchViewPoseMatrix1);
            const transform = Cesium.Transforms.eastNorthUpToFixedFrame(camera.positionWC, ellipsoid, scratchViewPoseMatrix2);
            camera._setTransform(transform);
            /// 
            if (!(hpr instanceof Cesium.HeadingPitchRoll)) {
                hpr = new Cesium.HeadingPitchRoll();
            }
            ///
            hpr.heading = getHeading(camera.direction, camera.up);
            hpr.pitch = getPitch(camera.direction);
            hpr.roll = getRoll(camera.direction, camera.up, camera.right);
            ///
            camera._setTransform(oldTransform);
            ///
            return hpr;
        }
        return undefined;
    }
    const pickBySimilarSphere = new Cesium.BoundingSphere();
    function pickBySimilar(radius, ray, result) {
        ///
        ///
        const sphere = pickBySimilarSphere;
        sphere.radius = radius;
        const intersection = Cesium.IntersectionTests.raySphere(ray, sphere);
        if (!Cesium.defined(intersection))
            return undefined;
        ///
        if (intersection.start > 0.0) {
            return Cesium.Ray.getPoint(ray, intersection.start, result);
        }
        if (intersection.start == 0) {
            return Cesium.Ray.getPoint(ray, intersection.stop, result);
        }
        return undefined;
    }
    const lastPickPosition = new Cesium.Cartesian3();
    const checkLimitRay = new Cesium.Ray();
    const checkLimitHist = new Cesium.Cartesian3();
    const checkLimitCameraPos = new Cesium.Cartesian3();
    const checkLimitCameraPos2 = new Cesium.Cartesian3();
    const checkLimitCameraHPR = new Cesium.HeadingPitchRoll();
    const checkLimitCameraHPR2 = new Cesium.HeadingPitchRoll();
    ///
    const pan3DP0 = Cesium.Cartesian4.clone(Cesium.Cartesian4.UNIT_W);
    const pan3DP1 = Cesium.Cartesian4.clone(Cesium.Cartesian4.UNIT_W);
    const pan3DPickRay = new Cesium.Ray();
    const pan3DTemp0 = new Cesium.Cartesian3();
    const pan3DTemp1 = new Cesium.Cartesian3();
    const pan3DTemp2 = new Cesium.Cartesian3();
    const pan3DTemp3 = new Cesium.Cartesian3();
    const pan3DStartMousePosition = new Cesium.Cartesian2();
    const pan3DEndMousePosition = new Cesium.Cartesian2();
    ///
    const zoomTargePosition = new Cesium.Cartesian3();
    const zoomIntersection = new Cesium.Cartesian3();
    const zoomDirection = new Cesium.Cartesian3();
    const zoomCartographic = new Cesium.Cartographic();
    const zoomHeadingPitchRool = new Cesium.HeadingPitchRoll();
    //
    const tile3DCenter = new Cesium.Cartesian3();
    const tilt3DTransform = new Cesium.Matrix4();
    const tilt3DOldTransform = new Cesium.Matrix4();
    const tilt3DScreenCenter = new Cesium.Cartesian2();
    //
    const look3DStartPos = new Cesium.Cartesian2();
    const look3DEndPos = new Cesium.Cartesian2();
    const look3DStartRay = new Cesium.Ray();
    const look3DEndRay = new Cesium.Ray();
    const look3DNegativeRot = new Cesium.Cartesian3();
    const look3DTan = new Cesium.Cartesian3();
    const upDownRay = new Cesium.Ray();
    const upDownDir = new Cesium.Ray();
    const upDonwPosition = new Cesium.Cartesian3();
    ///
    //Cesium.New_ScreenSpaceCameraController = ScreenSpaceCameraController;
})(Cegore || (Cegore = {}));
/*
 * File of class Renderable
 */
var Cegore;
(function (Cegore) {
    /**
     * 可绘制对象
     */
    class Renderable {
        /**
         * 构造函数
         * @param options
         */
        constructor() {
            /// 位置
            this._position = new Cegore.Position();
            /// 方位
            this._orientation = new Cegore.HeadingPitchRoll();
        }
        /**
         * 应用属性
         * @param o 设置属性的对象
         * @param keys 属性名列表
         * @param props 属性值对象
         */
        static applyProps(o, keys, props) {
            for (var i = 0; i < keys.length; ++i) {
                let val = props[keys[i]];
                if (Cegore.TypeCheck.isDefined(val))
                    o[keys[i]] = val;
            }
        }
        /**
         * 应用属性给当前对象
         *
         * @param options 属性列表
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        applyProps(options) {
            Renderable.applyProps(this, Renderable.RenderablePropList, options);
        }
        /**
         * 获取对象的id
         */
        get id() {
            return this._czRenderable.id;
        }
        /**
         * 设置标准是否可见
         */
        set visible(visible) { this._czRenderable.show = visible; }
        /**
         * 获取当前对象是否可见
         */
        get visible() { return this._czRenderable.show; }
        /**
         * 获取位置信息
         */
        get position() { return this._position; }
        /**
         * 设置位置信息
         */
        set position(pos) { this._position.set(pos); this.applyPose(); }
        /**
         * 获取模型的方位
         */
        get orientation() { return this._orientation; }
        /**
         * 设置模型的方位
         */
        set orientation(o) { this._orientation.set(o); this.applyPose(); }
        /**
         * 更新模型的姿态信息
         * @private
         */
        applyPose() {
            /// 计算位置
            let position = Cesium.Cartesian3.fromDegrees(this._position.lon, this._position.lat, this._position.altitude);
            /// 计算 HeadingPitchRoll
            let hpr = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(this._orientation.heading), Cesium.Math.toRadians(this._orientation.pitch), Cesium.Math.toRadians(this._orientation.roll));
            /// 计算旋转
            let orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
            /// 应用更新
            this._czRenderable.position = position;
            this._czRenderable.orientation = orientation;
        }
    }
    /**
     * 可设置的属性
     */
    Renderable.RenderablePropList = ['visible', 'position', 'orientation'];
    Cegore.Renderable = Renderable;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Provider
 */
var Cegore;
(function (Cegore) {
    /**
     * Provide 提供器集合
     */
    class ProviderCollection {
        constructor(def) {
            this.mFactories = new Cegore.HashMap();
            this.mDefaultFac = def;
        }
        /**
         * 注册提供器工厂
         * @param provider
         */
        regFactory(type, provider) {
            this.mFactories.put(type, provider);
        }
        /**
         * 反注册提供器工厂
         * @param provider
         */
        unregFactory(type) {
            this.mFactories.remove(type);
        }
        /**
         * 创建提供器
         * @param options
         */
        createProvider(type, options) {
            type = Cegore.TypeCheck.defaultValue(type, this.mDefaultFac);
            let provider = this.mFactories.get(type);
            if (provider)
                return provider.createProvider(options);
            //// 
            return;
        }
    }
    Cegore.ProviderCollection = ProviderCollection;
    /**
     *
     */
    class Providers {
    }
    /**
     * 地形提供器集合
     */
    Providers.TerrainProviders = new ProviderCollection('ZMapTerrain');
    /**
     * 影像提供器集合
     */
    Providers.ImageProviders = new ProviderCollection('ZMapImage');
    Cegore.Providers = Providers;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class ImageLayer
 */
var Cegore;
(function (Cegore) {
    /**
     * 影像图层
     */
    class ImageLayer {
        /**
         * 构造影像图层
         *
         * @param options 包含如下属性
         * @param options.name 指定图层的名称
         * @param options.type 指定地形数据类型，包括（ZMapImage等）
         *
         * @example
         * ``` ts
         *  new ImageLayer({
         *  	name: 'GoogleLayer',
         *  	type: 'ZMapImage',
         *  	// 数据的地址
         *  	url :'http://localhost:9081/zs/data/tdtonline/image',
         *  	// 设置最大显示层级
         *  	minimumLevel: 0,
         *  	maximumLevel: 18
         *  });
         * ```
         */
        constructor(options) {
            /// 判断是否为一个对象
            if (!Cegore.TypeCheck.isObject(options)) {
                throw 'Invalid iamge info';
            }
            var provider = this.createProvider(options);
            if (!Cegore.TypeCheck.isDefined(provider)) {
                throw 'Can not create image layer by type : "' + options.type + '"';
            }
            ///
            this._name = Cegore.AutoNames.genName(options.name, "ImageLayer");
            this._type = options.type;
            this._provider = provider;
            this._czLayer = new Cesium.ImageryLayer(provider, {
                rectangle: Cegore.Rectangle.toCZRectangle(options.rectangle),
                show: Cegore.TypeCheck.defaultValue(options.visible, true),
                alpha: Cegore.TypeCheck.defaultValue(options.alpha, 1.0),
                brightness: Cegore.TypeCheck.defaultValue(options.brightness, 1)
            });
            this._czLayer.brightness = Cegore.TypeCheck.defaultValue(options.brightness, 1);
            this._czLayer['_ZMapLayer'] = this;
        }
        /**
         * @internal
         */
        get _czlayer() { return this._czLayer; }
        /**
         * 图层名称
         */
        get name() { return this._name; }
        /**
         * Provider的类型
         */
        get type() { return this._type; }
        /**
         * 图层可见性
         */
        set visible(value) { this._czLayer.show = value; }
        /**
         * 设置图层可见性
         */
        get visible() { return this._czLayer.show; }
        /**
         * 透明度
         */
        set alpha(value) { this._czLayer.alpha = value; }
        /**
         * 设置透明度
         */
        get alpha() { return this._czLayer.alpha; }
        /** 亮度 */
        set brightness(value) { this._czLayer.brightness = value; }
        get brightness() { return this._czLayer.brightness; }
        get provider() { return this._provider; }
        /**
         * 根据options 创建provider
         * @param options
         */
        createProvider(options) {
            let copy = {};
            for (var key in options) {
                if (this.hasOwnProperty(key))
                    continue;
                copy[key] = options[key];
            }
            if (Cegore.TypeCheck.isDefined(copy.scheme)) {
                if (copy.scheme === 'WebMercator') {
                    copy.tilingScheme = new Cesium.WebMercatorTilingScheme({ ellipsoid: copy.ellipsoid });
                }
                else {
                    if (copy.scheme.endsWith('level-0'))
                        copy.tilingScheme = new Cesium.GeographicTilingScheme({
                            ellipsoid: copy.ellipsoid,
                        });
                    else
                        copy.tilingScheme = new Cesium.GeographicTilingScheme({
                            ellipsoid: copy.ellipsoid,
                            numberOfLevelZeroTilesX: 8,
                            numberOfLevelZeroTilesY: 4
                        });
                }
            }
            return Cegore.Providers.ImageProviders.createProvider(options.type, copy);
        }
    }
    Cegore.ImageLayer = ImageLayer;
})(Cegore || (Cegore = {}));
/*
 * File of class ImageLayerCollection
 */
var Cegore;
(function (Cegore) {
    /**
     * 影像图层集合
     */
    class ImageLayerCollection {
        /**
         * 构造函数，构造一个新的图层管理器
         *
         * @param viewer 主视图
         */
        constructor(globe) {
            this._layers = new Cegore.HashMap();
            this._globe = globe;
            this._czLayers = this._globe._czglobe.imageryLayers;
        }
        /**
         * 获取影像图层的数量
         *
         * @return {Number}
         */
        get length() { return this._czLayers.length; }
        /**
         * 添加影像图层
         *
         * @param {ImageLayer} layer 影像图层
         * @param {Number} [index] 索引
         */
        add(layer, index) {
            if (!Cegore.TypeCheck.isInstanceOf(layer, Cegore.ImageLayer)) {
                layer = new Cegore.ImageLayer(layer);
            }
            if (this._layers.exist(layer.name)) {
                throw "image layer named :" + layer.name + " allready exist.";
            }
            this._czLayers.add(layer._czlayer, index);
            this._layers.put(layer.name, layer);
        }
        /**
         * 获取影像图层
         * @param {String|Number} id 指定影像图层的序号或者名称
         */
        get(id) {
            if (Cegore.TypeCheck.isNumber(id)) {
                var czlayer = this._czLayers.get(id);
                if (czlayer)
                    return czlayer._ZMapLayer;
            }
            else if (Cegore.TypeCheck.isString(id)) {
                return this._layers.get(id);
            }
            else
                throw "id must be string or number";
        }
        /**
         * 移除影像图层
         *
         * @param {Number|String|ImageLayer} id 可以是图层的索引、名称或者图层对象
         */
        remove(id) {
            if (Cegore.TypeCheck.isNumber(id) || Cegore.TypeCheck.isString(id)) {
                this.remove(this.get(id));
            }
            else if (Cegore.TypeCheck.isInstanceOf(id, Cegore.ImageLayer)) {
                var layer = id;
                this._czLayers.remove(layer._czlayer);
                this._layers.remove(id.name);
            }
            else
                throw "id must be string or number or ImageLayer";
        }
        /**
         * 移除所有图层
         */
        removeAll() {
            this._czLayers.removeAll();
            this._layers.removeAll();
        }
        /**
         * 移除所有图层
         */
        clear() {
            this.removeAll();
        }
    }
    Cegore.ImageLayerCollection = ImageLayerCollection;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Globe
 */
var Cegore;
(function (Cegore) {
    /**
     * 地球类
     */
    class Globe {
        /**
         * 构造函数
         * @param scene
         */
        constructor(scene) {
            this._scene = scene;
            this._czData = scene._czdata;
            this._czGlobe = this._czData.globe;
            this._images = new Cegore.ImageLayerCollection(this);
        }
        /**
         * 设置地形数据源
         *
         * @param options 包含如下属性
         * @param options.type 指定地形数据类型，包括（ZMapTerrain等）
         * @param options.data 指定地形数据
         */
        setTerrain(options) {
            var provider = this.createProvider(options);
            if (provider == null) {
                throw 'Invalid terrain info';
            }
            ///
            this._czData.globe.terrainProvider = provider;
        }
        /**
         * @private
         */
        get _czglobe() { return this._czGlobe; }
        /**
         * 获取影像图层集合
         */
        get images() { return this._images; }
        /**
         * 地球上没有影像时的基本颜色
         */
        get baseColor() { return new Cegore.Color(this._czGlobe.baseColor); }
        /**
         * 地球上没有影像时的基本颜色
         */
        set baseColor(val) {
            if (!Cegore.TypeCheck.isInstanceOf(val, Cegore.Color))
                val = new Cegore.Color(val);
            this._czGlobe.baseColor = val.toCZColor();
        }
        /**
         * 是否启用深度监测
         */
        get enableDepthTest() { return this._czGlobe.depthTestAgainstTerrain; }
        /**
         * 设置是否启用深度监测
         */
        set enableDepthTest(val) { this._czGlobe.depthTestAgainstTerrain = val; }
        /**
         * 获取是否启用光照
         */
        get enableLighting() { return this._czGlobe.enableLighting; }
        /**
         * 设置是否启用光照
         */
        set enableLighting(enable) { this._czGlobe.enableLighting = enable; }
        /**
         * 获取是否启用水体效果
         */
        get enableWaterEffect() { return this._czGlobe.showWaterEffect; }
        /**
         * 设置是否启用水体效果
         */
        set enableWaterEffect(enable) { this._czGlobe.showWaterEffect = enable; }
        /**
         * 瓦片缓存大小，默认值：100
         */
        get tileCacheSize() { return this._czGlobe.tileCacheSize; }
        /**
         * 瓦片缓存大小，默认值：100
         */
        set tileCacheSize(val) { this._czGlobe.tileCacheSize = val; }
        /**
         * 瓦片加载事件，当瓦片队列发生变化（增加或者减少）时触发事件。事件传递出瓦片队列的长度。
         * 事件原型 ``` function(length) {} ```
         */
        get tileLoadProgress() {
            if (!Cegore.TypeCheck.isDefined(this._tileLoadProgress)) {
                this._tileLoadProgress = new Cegore.Event();
                this._czGlobe.tileLoadProgressEvent.addEventListener((length) => {
                    this._tileLoadProgress.fire(length);
                });
            }
            ///
            return this._tileLoadProgress;
        }
        /**
         * 根据options 创建provider
         * @param options
         */
        createProvider(options) {
            return Cegore.Providers.TerrainProviders.createProvider(options.type, options);
        }
    }
    Cegore.Globe = Globe;
    (function () {
        const scale = 1.001;
        const scratchCartesian = new Cesium.Cartesian3();
        if (!Cesium.EllipsoidalOccluder.prototype.isScaledSpacePointVisibleOld) {
            Cesium.EllipsoidalOccluder.prototype.isScaledSpacePointVisibleOld = Cesium.EllipsoidalOccluder.prototype.isScaledSpacePointVisible;
            Cesium.EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (occludeeScaledSpacePosition) {
                Cesium.Cartesian3.multiplyByScalar(occludeeScaledSpacePosition, scale, scratchCartesian);
                return this.isScaledSpacePointVisibleOld(scratchCartesian);
            };
        }
    })();
})(Cegore || (Cegore = {}));
/*
 * File of class Model
 */
var Cegore;
(function (Cegore) {
    /**
     * 抽象模型管理类，不能直接构造该对象
     */
    class Model extends Cegore.Renderable {
        /**
         * 构造函数，构造一个新的Model对象
         */
        constructor() {
            super();
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
        }
        /**
         * 获取模型的名称
         */
        get name() { return this._name; }
        /**
         * 设置模型的名称
         */
        set name(name) { this._name = name; }
        /**
         * 获取父对象
         */
        get parent() { return this._parent; }
        /**
         * 获取子对象列表，始终返回空数组
         */
        get children() { return Cegore.ArrayUtil.EmptyArray; }
        /**
         * 是否叶子对象，始终返回ture
         */
        get isLeaf() { return true; }
        /**
         * 当被添加到ModelGroup中时调用，内部接口不要再外部调用
         * @private
         */
        onAdded(parent) {
            this._parent = parent;
        }
        /**
         * 当被添从ModelGroup中移除时调用，内部接口不要再外部调用
         * @private
         */
        onRemoved() {
            this._parent = null;
        }
        /**
         * 当连接到根节点时调用，内部接口不要再外部调用
         * @private
         */
        onAttachRoot() {
            this._parent.models._onAddModel(this);
        }
        /**
         * 当与根节点断开时调用，内部接口不要再外部调用
         * @private
         */
        onDetachRoot() {
            this._parent.models._onRemoveModel(this);
        }
    }
    /**
     * 模型可设置的属性
     */
    Model.ModelPropList = ['name'];
    Cegore.Model = Model;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class ModelGroup
 */
var Cegore;
(function (Cegore) {
    /**
     * 模型组
     *
     * 管理模型分组
     */
    class ModelGroup {
        /**
         * 构造一个新的模型组
         * @param modelCollection
         */
        constructor(options) {
            this._children = [];
            options = Cegore.TypeCheck.defaultValue(options, {});
            this._name = Cegore.TypeCheck.defaultValue(options.name, '未命名');
        }
        /**
         * 获取模型集合
         */
        get models() { return this._models; }
        /**
         * 获取模型名称
         */
        get name() { return this._name; }
        /**
         * 获取父节点
         */
        get parent() { return this._parent; }
        /**
         * 获取子节点列表
         */
        get children() { return this._children; }
        /**
         * 返回是否叶子节点，对于模型组，该返回值总是 false
         */
        get isLeaf() { return false; }
        /**
         * 添加模型到该模型组中
         * @param m
         */
        add(m) {
            if (m.parent === this)
                return;
            if (m.parent)
                m.parent.remove(m);
            this._children.push(m);
            m.onAdded(this);
            if (this._models)
                m.onAttachRoot();
        }
        /**
         * 从模型组中移除该模型
         * @param m
         */
        remove(m) {
            if (m.parent !== this)
                return;
            let index = this._children.indexOf(m);
            this._children.splice(index);
            m.onDetachRoot();
            m.onRemoved();
        }
        /**
         * 移除该模型组中所有模型
         */
        removeAll() {
            for (var i = 0; i < this._children.length; ++i) {
                this._children[i].onDetachRoot();
                this._children[i].onRemoved();
            }
            this._children = [];
        }
        /**
         * @private
         * @param modelCollection
         */
        setModelCollection(modelCollection) {
            this._models = modelCollection;
        }
        /**
         * @private
         * @param parent
         */
        onAdded(parent) {
            this._parent = parent;
            this._models = parent._models;
            ///
            if (this._models)
                this.onAttachRoot();
        }
        /**
         * @private
         */
        onRemoved() {
            if (this._models)
                this.onDetachRoot();
            ///
            this._parent = null;
            this._models = null;
        }
        /**
         * @private
         * 与根节点断开
         */
        onAttachRoot() {
            for (var i = 0; i < this._children.length; ++i) {
                this._children[i].onAttachRoot();
            }
        }
        /**
         * @private
         * 连接到根节点
         */
        onDetachRoot() {
            for (var i = 0; i < this._children.length; ++i) {
                this._children[i].onDetachRoot();
            }
        }
        /**
         *
         * @param mg
         * @param ms
         */
        static getAllModels(mg, ms) {
            for (var i = 0; i < mg.children.length; ++i) {
                let ti = mg.children[i];
                if (Cegore.TypeCheck.isInstanceOf(ti, ModelGroup))
                    ModelGroup.getAllModels(ti, ms);
                else
                    ms.push(ti);
            }
            return ms;
        }
    }
    Cegore.ModelGroup = ModelGroup;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class ModelCollection.ts
 */
var Cegore;
(function (Cegore) {
    /**
     * 模型集合
     */
    class ModelCollection {
        /**
         * 构造函数
         * @param scene
         */
        constructor(scene) {
            this._models = new Cegore.HashMap();
            this._czData = scene._czdata;
            this._DataSource = new Cesium.CustomDataSource("ModelCollection");
            this._czData.viewer.dataSources.add(this._DataSource);
            this._entities = this._DataSource.entities;
            this._root = new Cegore.ModelGroup({ name: '根节点' });
            this._root.setModelCollection(this);
        }
        /**
         * 获取根节点
         */
        get root() { return this._root; }
        /**
         * 添加模型到根节点
         * @param m
         */
        add(m) {
            this._root.add(m);
        }
        /**
         * 从根节点删除模型
         */
        remove(m) {
            this._root.remove(m);
        }
        /**
         * private
         * @param model
         */
        _onAddModel(model) {
            this._models.put(model.id, model);
            this._entities.add(model._czRenderable);
        }
        /**
         * private
         * @param model
         */
        _onRemoveModel(model) {
            this._models.remove(model.id);
            this._entities.remove(model._czRenderable);
        }
    }
    Cegore.ModelCollection = ModelCollection;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class GltfModel
 */
var Cegore;
(function (Cegore) {
    /**
     * Gltf模型
     */
    class GltfModel extends Cegore.Model {
        /**
         * 构造函数，构造一个新的 GltfModel 对象
         * @param options 模型的参数
        
         * @param options.name 模型的名称，用户自定义，便于识别的标识符
         * @param options.uri 模型数据的uri，必须是gltf格式的
         * @param options.enablePick 是否允许拾取
         * @param options.minPixelSize 最小可见像素大小
         * @param options.color 模型显示的叠加颜色
         * @param options.outlineColor 轮廓线颜色
         * @param options.outlineSize 轮廓线宽度
         *
         * ///
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
            this._enablePcik = true;
            this._color = new Cegore.Color(Cegore.Color.WHITE);
            this._outlineColor = new Cegore.Color(Cegore.Color.BLACK);
            this._outlineSize = 0.0;
            //
            this._czEntity = new Cesium.Entity();
            this._czModel = new Cesium.ModelGraphics();
            this._czEntity.model = this._czModel;
            /// 应用属性
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, GltfModel.GltfModelPropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * 获取类型，返回 Model
         */
        get type() { return 'GltfModel'; }
        /**
         * 获取模型的数据的URI
         */
        get uri() { return this._uri; }
        /**
         * 指定模型数据的URI
         */
        set uri(uri) { this._uri = uri; this._czModel.uri = uri; }
        /**
         * 是否允许拾取
         */
        get enablePick() { return this._enablePcik; }
        /**
         * 允许拾取
         */
        set enablePick(enable) { this._enablePcik = enable; this._czModel.allowPicking = enable; }
        /**
         * 获取模型显示的最小像素大小，当模型在屏幕上小于该值后将不再显示
         */
        get minPixelSize() { return this._minPixelSize; }
        /**
         * 设置模型显示的最小像素大小，当模型在屏幕上小于该值后将不再显示
         */
        set minPixelSize(size) { this._minPixelSize = size; this._czModel.minimumPixelSize = size; }
        /**
         * 获取模型颜色
         */
        get color() { return this._color; }
        /**
         * 设置模型颜色
         */
        set color(color) {
            this._color.set(color);
            this._czModel.color = this._color.toCZColor();
        }
        /**
         * 获取模型轮廓线颜色
         */
        get outlineColor() { return this._outlineColor; }
        /**
         * 设置模型轮廓线颜色
         */
        set outlineColor(color) {
            this._outlineColor.set(color);
            this._czModel.silhouetteColor = this._outlineColor.toCZColor();
        }
        /**
         * 获取模型轮廓线宽度
         */
        get outlineSize() { return this._outlineSize; }
        /**
         * 设置模型轮廓线宽度
         */
        set outlineSize(size) {
            this._outlineSize = size;
            this._czModel.silhouetteSize = size;
        }
    }
    /**
     * 模型可设置的属性
     */
    GltfModel.GltfModelPropList = ['uri', 'enablePick', 'minPixelSize', 'color', 'outlineColor', 'outlineSize'];
    Cegore.GltfModel = GltfModel;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Shape
 */
var Cegore;
(function (Cegore) {
    /**
     * 图形的抽象基类，不能直接构造该对象
     */
    class Shape extends Cegore.Model {
        /**
         * 构造一个新的Shape对象
         */
        constructor() {
            super();
            this._fill = true;
            this._outline = false;
            this._outlineColor = new Cegore.Color(Cegore.Color.BLACK);
            this._outlineWidth = 1.0;
            this._shadows = Cegore.ShadowMode.DISABLED;
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, Shape.ShapePropList, props);
        }
        /**
         * 获取是否填充，默认值：true
         */
        get fill() { return this._fill; }
        /**
         * 设置是否填充，默认值：true
         */
        set fill(fill) {
            this._fill = fill;
            this._czShape.fill = fill;
        }
        /**
         * 获取当前图形的材质
         */
        get material() { return this._material; }
        /**
         * 设置当前图形的材质
         */
        set material(mat) {
            let mm = mat;
            if (Cegore.TypeCheck.isInstanceOf(mm, Cegore.Material))
                this._material = mm;
            else if (Cegore.TypeCheck.isInstanceOf(mm, Cegore.Color))
                this._material = new Cegore.ColorMaterial(mm);
            else if (Cegore.TypeCheck.isString(mm) ||
                Cegore.TypeCheck.isInstanceOf(mm, HTMLImageElement) ||
                Cegore.TypeCheck.isInstanceOf(mm, HTMLCanvasElement) ||
                Cegore.TypeCheck.isInstanceOf(mm, HTMLVideoElement))
                this._material = new Cegore.ImageMaterial({ image: mm });
            else if (Cegore.TypeCheck.isObject(mm))
                this._material = new Cegore.ImageMaterial(mm);
            this._czShape.material = this._material.czmat;
        }
        /**
         * 获取是否显示轮廓，默认值：false
         */
        get outline() { return this._outline; }
        /**
         * 设置是否显示轮廓，默认值：false
         */
        set outline(val) {
            this._outline = val;
            this._czShape.outline = val;
        }
        /**
         * 获取轮廓线颜色，默认值：Color.BLACK
         */
        get outlineColor() { return new Cegore.Color(this._czShape.outlineColor); }
        /**
         * 设置轮廓线颜色，默认值：Color.BLACK
         */
        set outlineColor(val) {
            this._outlineColor.set(val);
            this._czShape.outlineColor = this._outlineColor.toCZColor();
        }
        /**
         * 获取轮廓线宽度，默认值：1.0
         */
        get outlineWidth() { return this._czShape.outlineWidth; }
        /**
         * 设置轮廓线宽度，默认值：1.0
         */
        set outlineWidth(val) {
            this._outlineWidth = val;
            this._czShape.outlineWidth = val;
        }
        /**
         * 获取阴影模式，指出模型是否产生或者接受阴影，默认值：ShadowMode.DISABLE
         */
        get shadows() { return this._czShape.shadows; }
        /**
         * 设置阴影模式，指出模型是否产生或者接受阴影，默认值：ShadowMode.DISABLE
         */
        set shadows(mode) {
            this._shadows = mode;
            this._czShape.shadows = mode;
        }
        get displayDistance() { return this._displayDistance; }
        set displayDistance(distance) {
            this._displayDistance = distance;
            this._czShape.distanceDisplayCondition = distance;
        }
    }
    Shape.ShapePropList = ['material', 'fill', 'outline', 'outlineColor', 'outlineWidth', 'shadows', 'displayDistance'];
    Cegore.Shape = Shape;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class Shape
 */
var Cegore;
(function (Cegore) {
    /**
     * 可以挤压成体的图形的抽象基类，不能直接构造该对象
     */
    class ShapeExtruded extends Cegore.Shape {
        /**
         * 构造一个ShapeExtruded对象
         * @param options 一个可选的参数对象
         * @param options.height 距离地表的高度，默认值：0
         * @param options.extrudedHeight 挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         * @param options.rotation 从正北方向逆时针旋转的角度，默认值：0
         *
         * Shape
         * @param options.fill 是否填充显示，默认值：是
         * @param options.material 填充的材质，默认值：Color.WHITE
         * @param options.outline 是否显示轮廓线，默认值：不显示
         * @param options.outlineColor 轮廓线的颜色，默认值：黑色
         * @param options.outlineWidth 轮廓线的宽度，默认值：1.0
         * @param options.shadows 阴影模式，默认值：ShadowMode.DISABLE
         * @param options.displayDistance 显示距离，控制在多大范围内显示该模型
         *
         * Renderable 的参数
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, ShapeExtruded.ShapeExtrudedPropList, props);
        }
        /**
         * 获取椭圆距离地表的高度，默认值：0
         */
        get height() { return this._height; }
        /**
         * 设置椭圆距离地表的高度，默认值：0
         */
        set height(height) {
            this._height = height;
            this._czShape.height = height;
        }
        /**
         * 获取椭圆的挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         */
        get extrudedHeight() { return this._extrudedHeight; }
        /**
         * 设置椭圆的挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         */
        set extrudedHeight(exheight) {
            this._extrudedHeight = exheight;
            this._czShape.extrudedHeight = exheight;
        }
        /**
         * 获取椭圆从正北方向逆时针旋转的角度，默认值：0
         */
        get rotation() { return this._rotation; }
        /**
         * 设置椭圆从正北方向逆时针旋转的角度，默认值：0
         */
        set rotation(r) {
            this._rotation = r;
            this._czShape.rotation = Cegore.GeoMath.toRadian(r);
        }
    }
    ShapeExtruded.ShapeExtrudedPropList = ['height', 'extrudedHeight', 'rotation'];
    Cegore.ShapeExtruded = ShapeExtruded;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * file of class BoxModel
 */
var Cegore;
(function (Cegore) {
    /**
     * 立方体模型对象
     */
    class BoxModel extends Cegore.Shape {
        /**
         * 构造一个立方体对象
         * @param options 一个可选的参数对象
         * @param options.dimensions 模型的尺寸，可以是数组`[x, y, z]`或者对象`{x: 1,y:1, z:1}`
         *
         * /// Shape 的参数
         * @param options.fill 是否填充显示，默认值：是
         * @param options.material 填充的材质，默认值：Color.WHITE
         * @param options.outline 是否显示轮廓线，默认值：不显示
         * @param options.outlineColor 轮廓线的颜色，默认值：黑色
         * @param options.outlineWidth 轮廓线的宽度，默认值：1.0
         * @param options.shadows 阴影模式，默认值：ShadowMode.DISABLE
         * @param options.displayDistance 显示距离，控制在多大范围内显示该模型
         *
         * /// Renderable 的参数
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
            this._dimensions = new Cegore.Vector3();
            //
            this._czEntity = new Cesium.Entity();
            this._czBox = new Cesium.BoxGraphics();
            this._czEntity.box = this._czBox;
            /// 
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, BoxModel.BoxPropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * @private
         */
        get _czShape() { return this._czBox; }
        /**
         * 获取对象的类型
         */
        get type() { return "BoxModel"; }
        /**
         * 获取模型的尺寸，返回值是一个Vector3，分别是立方体的长宽高，不要再外部修改该对象
         */
        get dimensions() { return this._dimensions; }
        /**
         * 设置立方体的尺寸
         */
        set dimensions(dimensions) {
            this._dimensions.set(dimensions);
            this._czBox.dimensions = this._dimensions._asCzVector3();
        }
    }
    BoxModel.BoxPropList = ['dimensions'];
    Cegore.BoxModel = BoxModel;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */
/*
 * file of class CylinderModel
 */
var Cegore;
(function (Cegore) {
    /**
     * 圆柱模型对象
     */
    class CylinderModel extends Cegore.Shape {
        /**
         * 构造一个圆柱体对象
         * @param options 一个可选的参数对象
         * @param options.length 圆柱体的长度
         * @param options.topRadius 圆柱体顶面半径
         * @param options.bottomRadius 圆柱体底面变径
         * @param options.slices 圆柱体边的数目，默认值：128,
         * @param options.verticalLines 垂直线的数目，该参数用于轮廓线显示，默认值：16
         *
         * ///
         * @param options.fill 是否填充显示，默认值：是
         * @param options.material 填充的材质，默认值：Color.WHITE
         * @param options.outline 是否显示轮廓线，默认值：不显示
         * @param options.outlineColor 轮廓线的颜色，默认值：黑色
         * @param options.outlineWidth 轮廓线的宽度，默认值：1.0
         * @param options.shadows 阴影模式，默认值：ShadowMode.DISABLE
         * @param options.displayDistance 显示距离，控制在多大范围内显示该模型
         *
         * /// Renderable 的参数
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
            //
            this._czEntity = new Cesium.Entity();
            this._czCylinder = new Cesium.CylinderGraphics();
            this._czEntity.cylinder = this._czCylinder;
            /// 
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, CylinderModel.CylinderPropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * @private
         */
        get _czShape() { return this._czCylinder; }
        /**
         * 获取对象的类型
         */
        get type() { return "CylinderModel"; }
        /**
         * 获取圆柱体的长度
         */
        get length() { return this._length; }
        /**
         * 设置圆柱体的长度
         */
        set length(length) {
            this._length = length;
            this._czCylinder.length = length;
        }
        /**
         * 获取圆柱体的顶面变径
         */
        get topRadius() { return this._topRadius; }
        /**
         * 设置圆柱体的顶面半径
         */
        set topRadius(radius) {
            this._topRadius = radius;
            this._czCylinder.topRadius = radius;
        }
        /**
         * 获取圆柱体的底面变径
         */
        get bottomRadius() { return this._bottomRadius; }
        /**
         * 设置圆柱体的底面半径
         */
        set bottomRadius(radius) {
            this._bottomRadius = radius;
            this._czCylinder.bottomRadius = radius;
        }
        /**
         * 获取圆柱体边的数量，默认值：128
         */
        get slices() { return this._slices; }
        /**
         * 设置圆柱体边的数量，默认值：128
         */
        set slices(slices) {
            this._slices = slices;
            this._czCylinder.slices = slices;
        }
        /**
         * 获取垂直线的数目，该参数用于轮廓线显示，默认值：16
         */
        get verticalLines() { return this._verticalLines; }
        /**
         * 获取垂直线的数目，该参数用于轮廓线显示，默认值：16
         */
        set verticalLines(num) {
            this._verticalLines = num;
            this._czCylinder.numberOfVerticalLines = num;
        }
    }
    CylinderModel.CylinderPropList = ['length', 'topRadius', 'bottomRadius', 'slices', 'verticalLines'];
    Cegore.CylinderModel = CylinderModel;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */
/*
 * file of class EllipseModel
 */
var Cegore;
(function (Cegore) {
    /**
     * 椭圆模型对象
     */
    class EllipseModel extends Cegore.ShapeExtruded {
        /**
         * 构造一个椭圆对象
         * @param options 一个可选的参数对象
         * @param options.semiMajorAxis 椭圆长半轴长度
         * @param options.semiMinorAxis 椭圆短半轴长度
         * @param options.slices 椭圆边的数目，默认值：128,
         * @param options.verticalLines 垂直线的数目，该参数用于轮廓线显示，默认值：16
         *
         * Extruded
         * @param options.height 椭圆距离地表的高度，默认值：0
         * @param options.extrudedHeight 椭圆的挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         * @param options.rotation 椭圆从正北方向逆时针旋转的角度，默认值：0
         *
         * Shape
         * @param options.fill 是否填充显示，默认值：是
         * @param options.material 填充的材质，默认值：Color.WHITE
         * @param options.outline 是否显示轮廓线，默认值：不显示
         * @param options.outlineColor 轮廓线的颜色，默认值：黑色
         * @param options.outlineWidth 轮廓线的宽度，默认值：1.0
         * @param options.shadows 阴影模式，默认值：ShadowMode.DISABLE
         * @param options.displayDistance 显示距离，控制在多大范围内显示该模型
         *
         * Renderable 的参数
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
            //
            this._czEntity = new Cesium.Entity();
            this._czEllipse = new Cesium.EllipseGraphics();
            this._czEntity.ellipse = this._czEllipse;
            /// 
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, EllipseModel.EllipsePropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * @private
         */
        get _czShape() { return this._czEllipse; }
        /**
         * 获取对象的类型
         */
        get type() { return "EllipseModel"; }
        /**
         * 获取椭圆的长半轴长度
         */
        get semiMajorAxis() { return this._semiMajorAxis; }
        /**
         * 设置椭圆的长半轴长度
         */
        set semiMajorAxis(len) {
            this._semiMajorAxis = len;
            this._czEllipse.semiMajorAxis = len;
        }
        /**
         * 获取椭圆的短半轴长度
         */
        get semiMinorAxis() { return this._semiMinorAxis; }
        /**
         * 设置椭圆的短半轴长度
         */
        set semiMinorAxis(len) {
            this._semiMinorAxis = len;
            this._czEllipse.semiMinorAxis = len;
        }
        /**
         * 获取圆柱体边的数量，默认值：128
         */
        get slices() { return this._slices; }
        /**
         * 设置圆柱体边的数量，默认值：128
         */
        set slices(slices) {
            this._slices = slices;
            this._czEllipse.granularity = (Math.PI / 4.0) / slices;
        }
        /**
         * 获取垂直线的数目，该参数用于轮廓线显示，默认值：16
         */
        get verticalLines() { return this._verticalLines; }
        /**
         * 获取垂直线的数目，该参数用于轮廓线显示，默认值：16
         */
        set verticalLines(num) {
            this._verticalLines = num;
            this._czEllipse.numberOfVerticalLines = num;
        }
    }
    EllipseModel.EllipsePropList = ['semiMajorAxis', 'semiMinorAxis', 'slices', 'verticalLines'];
    Cegore.EllipseModel = EllipseModel;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */
/*
 * file of class EllipsoidModel
 */
var Cegore;
(function (Cegore) {
    /**
     * 椭球模型对象
     */
    class EllipsoidModel extends Cegore.Shape {
        /**
         * 构造一个圆柱体对象
         * @param options 一个可选的参数对象
         * @param options.semiMajorAxis 椭圆长半轴长度
         * @param options.semiMinorAxis 椭圆短半轴长度
         * @param options.height 椭圆距离地表的高度，默认值：0
         * @param options.extrudedHeight 椭圆的挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         * @param options.rotation 椭圆从正北方向逆时针旋转的角度，默认值：0
         * @param options.slices 椭圆边的数目，默认值：128,
         * @param options.verticalLines 垂直线的数目，该参数用于轮廓线显示，默认值：16
         *
         * ///
         * @param options.fill 是否填充显示，默认值：是
         * @param options.material 填充的材质，默认值：Color.WHITE
         * @param options.outline 是否显示轮廓线，默认值：不显示
         * @param options.outlineColor 轮廓线的颜色，默认值：黑色
         * @param options.outlineWidth 轮廓线的宽度，默认值：1.0
         * @param options.shadows 阴影模式，默认值：ShadowMode.DISABLE
         * @param options.displayDistance 显示距离，控制在多大范围内显示该模型
         *
         * /// Renderable 的参数
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
            //
            this._czEntity = new Cesium.Entity();
            this._czEllipsoid = new Cesium.EllipsoidGraphics();
            this._czEntity.ellipsoid = this._czEllipsoid;
            /// 
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, EllipsoidModel.EllipsoidPropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * @private
         */
        get _czShape() { return this._czEllipsoid; }
        /**
         * 获取对象的类型
         */
        get type() { return "EllipsoidModel"; }
        /**
         * 获取椭圆的长半轴长度
         */
        get semiMajorAxis() { return this._semiMajorAxis; }
        /**
         * 设置椭圆的长半轴长度
         */
        set semiMajorAxis(len) {
            this._semiMajorAxis = len;
            this._czEllipsoid.semiMajorAxis = len;
        }
        /**
         * 获取椭圆的短半轴长度
         */
        get semiMinorAxis() { return this._semiMinorAxis; }
        /**
         * 设置椭圆的短半轴长度
         */
        set semiMinorAxis(len) {
            this._semiMinorAxis = len;
            this._czEllipsoid.semiMinorAxis = len;
        }
        /**
         * 获取椭圆距离地表的高度，默认值：0
         */
        get height() { return this._height; }
        /**
         * 设置椭圆距离地表的高度，默认值：0
         */
        set height(height) {
            this._height = height;
            this._czEllipsoid.height = height;
        }
        /**
         * 获取椭圆的挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         */
        get extrudedHeight() { return this._extrudedHeight; }
        /**
         * 设置椭圆的挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         */
        set extrudedHeight(exheight) {
            this._extrudedHeight = exheight;
            this._czEllipsoid.extrudedHeight = exheight;
        }
        /**
         * 获取椭圆从正北方向逆时针旋转的角度，默认值：0
         */
        get rotation() { return this._rotation; }
        /**
         * 设置椭圆从正北方向逆时针旋转的角度，默认值：0
         */
        set rotation(r) {
            this._rotation = r;
            this._czEllipsoid.rotation = Cegore.GeoMath.toRadian(r);
        }
        /**
         * 获取圆柱体边的数量，默认值：128
         */
        get slices() { return this._slices; }
        /**
         * 设置圆柱体边的数量，默认值：128
         */
        set slices(slices) {
            this._slices = slices;
            this._czEllipsoid.granularity = (Math.PI / 4.0) / slices;
        }
        /**
         * 获取垂直线的数目，该参数用于轮廓线显示，默认值：16
         */
        get verticalLines() { return this._verticalLines; }
        /**
         * 获取垂直线的数目，该参数用于轮廓线显示，默认值：16
         */
        set verticalLines(num) {
            this._verticalLines = num;
            this._czEllipsoid.numberOfVerticalLines = num;
        }
    }
    EllipsoidModel.EllipsoidPropList = ['semiMajorAxis', 'semiMinorAxis', 'height', 'extrudedHeight', 'slices', 'rotation', 'verticalLines'];
    Cegore.EllipsoidModel = EllipsoidModel;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */
/*
 * file of class PolylineModel
 */
var Cegore;
(function (Cegore) {
    /**
     * 多边形样式类型
     */
    let PolylineStyle;
    (function (PolylineStyle) {
        /**
         * 普通样式
         */
        PolylineStyle[PolylineStyle["NONE"] = 0] = "NONE";
        /**
         * 炽热样式
         */
        PolylineStyle[PolylineStyle["GLOW"] = 1] = "GLOW";
        /**
         * 轮库线样式
         */
        PolylineStyle[PolylineStyle["OUTLINE"] = 2] = "OUTLINE";
        /**
         * 点划线样式
         */
        PolylineStyle[PolylineStyle["DASH"] = 3] = "DASH";
        /**
         * 箭头样式
         */
        PolylineStyle[PolylineStyle["ARROW"] = 4] = "ARROW";
    })(PolylineStyle = Cegore.PolylineStyle || (Cegore.PolylineStyle = {}));
    /**
     * 折线对象
     */
    class PolylineModel extends Cegore.Model {
        /**
         *
         * @param options 折线参数列表
         * @param options.positions 折线顶点列表
         * @param options.dynamic 是否动态线
         * @param options.followSuface 是否贴在地表
         * @param options.color 颜色
         * @param options.width 宽度
         * @param options.style 样式
         * @param options.glow 炽热度，仅用于GLOW样式
         * @param options.outlineWidth 轮廓线宽度，仅用于OUTLINE样式
         * @param options.outlineColor 轮廓线颜色，仅用于OUTLINE样式
         * @param options.shadows 阴影模式
         * @param options.displayDistance 显示距离
         */
        constructor(options) {
            super();
            this._dynamic = false;
            this._color = new Cegore.Color(Cegore.Color.WHITE);
            this._style = PolylineStyle.NONE;
            this._outlineColor = new Cegore.Color(Cegore.Color.BLACK);
            this._outlineWidth = 1.0;
            this._shadows = Cegore.ShadowMode.DISABLED;
            //
            this._czEntity = new Cesium.Entity();
            this._czPolyline = new Cesium.PolylineGraphics();
            this._czEntity.polyline = this._czPolyline;
            this._dynamic = Cegore.TypeCheck.defaultValue(options.dynamic, false);
            /// 
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, PolylineModel.PolylinePropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * @private
         */
        get _czShape() { return this._czPolyline; }
        /**
         * 获取对象的类型
         */
        get type() { return "PolylineModel"; }
        /**
         * 获取顶点列表
         */
        get positions() { return this._positions; }
        /**
         * 设置顶点列表
         */
        set positions(points) {
            this._positions = [];
            this._czPositions = [];
            for (var i = 0; i < points.length; ++i) {
                var pt = new Cegore.Position(points[i]);
                this._positions.push(pt);
                this._czPositions.push(Cesium.Cartesian3.fromDegrees(pt.lon, pt.lat, pt.altitude));
            }
            var pos = this._czPositions;
            if (this._dynamic && !Cegore.TypeCheck.isInstanceOf(this._czShape.positions, Cesium.CallbackProperty))
                this._czShape.positions = new Cesium.CallbackProperty(function (time, result) { return pos; }, false);
            else
                this._czShape.positions = pos;
        }
        /**
         * 获取是否贴附地表
         */
        get followSurface() { return this._followSurface; }
        /**
         * 设置是否贴附地表
         */
        set followSurface(follow) { this._followSurface = follow; this._czShape.followSuface = follow; }
        /**
         * 获取颜色
         */
        get color() { return this._color; }
        /**
         * 设置颜色
         */
        set color(color) {
            this._color.set(color);
            if (this._style == PolylineStyle.NONE)
                this._czShape.material = color.toCZColor();
            else
                this._czShape.material.color = color.toCZColor();
        }
        /**
         * 获取颜色
         */
        get color2() { return this._color2; }
        /**
         * 设置颜色
         */
        set color2(color) {
            if (!this._color2) {
                this._color2 = new Cegore.Color(Cegore.Color.WHITE);
            }
            this._color2.set(color);
            //if (this._style == PolylineStyle.NONE)
            this._czShape.depthFailMaterial = color.toCZColor();
        }
        /**
         * 设置线宽
         */
        get width() { return this._width; }
        /**
         * 获取线宽
         */
        set width(width) { this._width = width; this._czShape.width = width; }
        /**
         * 获取样式
         */
        get style() { return this._style; }
        /**
         * 设置样式
         */
        set style(style) {
            if (this._style == style)
                return;
            ///
            this._style = style;
            var czColor = this._color.toCZColor();
            switch (style) {
                case PolylineStyle.GLOW:
                    this._czShape.material = new Cesium.PolylineGlowMaterialProperty({
                        color: czColor, glowPower: this._glow
                    });
                    break;
                case PolylineStyle.DASH:
                    this._czShape.material = new Cesium.PolylineDashMaterialProperty({ color: czColor });
                    break;
                case PolylineStyle.ARROW:
                    this._czShape.material = new Cesium.PolylineArrowMaterialProperty(czColor);
                    break;
                case PolylineStyle.OUTLINE:
                    this._czShape.material = new Cesium.PolylineOutlineMaterialProperty({
                        color: czColor,
                        outlineWidth: this._outlineWidth,
                        outlineColor: this._outlineColor.toCZColor()
                    });
                    break;
                case PolylineStyle.NONE:
                default:
                    this._czShape.material = this._color.toCZColor();
                    break;
            }
        }
        /**
         * 获取炽热度
         */
        get glow() { return this._glow; }
        /**
         * 设置炽热度
         */
        set glow(glow) {
            if (this._style == PolylineStyle.GLOW) {
                this._czShape.material.glowPower = glow;
            }
        }
        /**
         * 获取轮廓线颜色，默认值：Color.BLACK
         */
        get outlineColor() { return this._outlineColor; }
        /**
         * 设置轮廓线颜色，默认值：Color.BLACK
         */
        set outlineColor(val) {
            this._outlineColor.set(val);
            if (this._style == PolylineStyle.OUTLINE) {
                this._czShape.material.outlineColor = this._outlineColor.toCZColor();
            }
        }
        /**
         * 获取轮廓线宽度，默认值：1.0
         */
        get outlineWidth() { return this._outlineWidth; }
        /**
         * 设置轮廓线宽度，默认值：1.0
         */
        set outlineWidth(val) {
            this._outlineWidth = val;
            if (this._style == PolylineStyle.OUTLINE)
                this._czShape.material.outlineWidth = val;
        }
        /**
         * 获取阴影模式，指出模型是否产生或者接受阴影，默认值：ShadowMode.DISABLE
         */
        get shadows() { return this._shadows; }
        /**
         * 设置阴影模式，指出模型是否产生或者接受阴影，默认值：ShadowMode.DISABLE
         */
        set shadows(mode) {
            this._shadows = mode;
            this._czShape.shadows = mode;
        }
        get displayDistance() { return this._displayDistance; }
        set displayDistance(distance) {
            this._displayDistance = distance;
            this._czShape.distanceDisplayCondition = distance;
        }
    }
    PolylineModel.PolylinePropList = ['positions', 'followSurface', 'width',
        'style', 'color', 'color2', 'glow', 'outlineWidth', 'outlineColor', 'shadows', 'displayDistance'
    ];
    Cegore.PolylineModel = PolylineModel;
})(Cegore || (Cegore = {}));
/*
 * file of class PolygonModel
 */
var Cegore;
(function (Cegore) {
    /**
     * 多边形的结构
     */
    class PolygonHierarchy {
    }
    Cegore.PolygonHierarchy = PolygonHierarchy;
    /**
     * 多边形对象
     */
    class PolygonModel extends Cegore.ShapeExtruded {
        /**
         * 构造一个多边形对象
         *
         * @param options 一个可选的参数对象
         * @param options.positions 多边形的顶点
         * @param options.dynamic 是否为动态对象，默认值：false
         * @param options.usePositionHeight 是否使用每一个顶点的高程信息，默认值：false
         * @param options.closeTop 是否封闭顶面，默认值：true
         * @param options.closeBottom 是否封闭底面，默认值：true
         *
         * ShapeExtruded
         * @param options.height 距离地表的高度，默认值：0
         * @param options.extrudedHeight 挤出高度，当设置这个参数后，椭圆将变成一个椭圆柱体
         * @param options.rotation 从正北方向逆时针旋转的角度，默认值：0
         *
         * Shape
         * @param options.fill 是否填充显示，默认值：是
         * @param options.material 填充的材质，默认值：Color.WHITE
         * @param options.outline 是否显示轮廓线，默认值：不显示
         * @param options.outlineColor 轮廓线的颜色，默认值：黑色
         * @param options.outlineWidth 轮廓线的宽度，默认值：1.0
         * @param options.shadows 阴影模式，默认值：ShadowMode.DISABLE
         * @param options.displayDistance 显示距离，控制在多大范围内显示该模型
         *
         * Renderable 的参数
         * @param options.visible 是否可见
         * @param options.position 位置
         * @param options.orientation 方向
         */
        constructor(options) {
            super();
            this._dynamic = false;
            this._usePositionHeight = false;
            this._closeTop = true;
            this._closeBottom = true;
            //
            this._czEntity = new Cesium.Entity();
            this._czPolygon = new Cesium.PolygonGraphics();
            this._czEntity.polygon = this._czPolygon;
            this._dynamic = Cegore.TypeCheck.defaultValue(options.dynamic, false);
            /// 
            this.applyProps(options);
        }
        /**
         * 应用属性给当前对象
         */
        applyProps(props) {
            super.applyProps(props);
            Cegore.Renderable.applyProps(this, PolygonModel.PolygonPropList, props);
        }
        /**
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * @private
         */
        get _czShape() { return this._czPolygon; }
        /**
         * 获取对象的类型
         */
        get type() { return "PolygonModel"; }
        /**
         * 获取顶点列表
         */
        get positions() { return this._positions; }
        /**
         * 设置顶点列表
         */
        set positions(polygon) {
            this._positions = [];
            var pts, holes = [];
            for (var i = 0; i < polygon.length; ++i) {
                var ring = polygon[i];
                var sring = [], czring = [];
                for (var j = 0; j < ring.length; ++j) {
                    var pt = new Cegore.Position(ring[j]);
                    sring.push(pt);
                    ///
                    czring.push(Cesium.Cartesian3.fromDegrees(pt.lon, pt.lat, pt.altitude));
                }
                this._positions(sring);
                if (i == 0)
                    pts = czring;
                else
                    holes.push(new Cesium.PolygonHierarchy(czring));
            }
            this._czPositions = new Cesium.PolygonHierarchy(pts, holes);
            var pos = this._czPositions;
            if (this._dynamic && !Cegore.TypeCheck.isInstanceOf(this._czShape.positions, Cesium.CallbackProperty))
                this._czShape.positions = new Cesium.CallbackProperty(function (time, result) { return pos; }, false);
            else
                this._czShape.positions = pos;
        }
        /**
         * 获取是否使用顶点的高程值，默认值：false
         */
        get usePositionHeight() { return this._usePositionHeight; }
        /**
         * 设置是否使用定点高程值
         */
        set usePositionHeight(use) { this._usePositionHeight = use; this._czShape.perPositionHeight = use; }
        /**
         * 获取是否封闭顶面
         */
        get closeTop() { return this._closeTop; }
        /**
         * 设置是否封闭顶面
         */
        set closeTop(close) { this._closeTop = close; this._czShape.closeTop = close; }
        /**
         * 获取是否封闭底面
         */
        get closeBottom() { return this._closeBottom; }
        /**
         * 设置是否封闭底面
         */
        set closeBottom(close) { this._closeBottom = close; this._czShape.closeBottom = close; }
    }
    PolygonModel.PolygonPropList = ['positions', 'usePositionHeight', 'closeTop', 'closeBottom'];
    Cegore.PolygonModel = PolygonModel;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    class PrimitiveModel extends Cegore.Renderable {
    }
    Cegore.PrimitiveModel = PrimitiveModel;
})(Cegore || (Cegore = {}));
/*
 * File of class Label
 */
var Cegore;
(function (Cegore) {
    /**
     * 标注类
     */
    class Label extends Cegore.Renderable {
        /**
         * 构建一个新的标注对象
         *
         * @param options
         */
        constructor(options) {
            super();
            this._layer = "";
            /// 
            this.mAutoOffset = true;
            if (!Cegore.TypeCheck.isDefined(options.text) && !Cegore.TypeCheck.isDefined(options.icon))
                throw "need options.text or options.icon";
            /// 
            this._name = Cegore.AutoNames.genName(options.name, 'Label');
            this._layer = Cegore.TypeCheck.defaultValue(options.layer, '');
            this._events = new Cegore.EventHandle(options.labelevent);
            /// 构建 entity
            this._czEntity = new Cesium.Entity({ name: this._layer + ' ' + this._name });
            this._czEntity._zMapRenderable = this;
            /// 文字
            this.setText(options.text);
            /// 图标
            this.setIcon(options.icon);
            ///
            super.applyProps({
                position: options.pos,
                visible: options.visible
            });
        }
        /**
         * 内部接口
         * @private
         */
        get _czRenderable() { return this._czEntity; }
        /**
         * 返回类型，返回‘Type’
         */
        get type() { return 'Label'; }
        /**
         * 获取标注的名称
         */
        get name() { return this._name; }
        /**
         * 获取标注所在图层
         */
        get layer() { return this._layer; }
        /**
         * 获取标注文本
         */
        get text() {
            if (Cegore.TypeCheck.isDefined(this._czText))
                return this._czText.text;
        }
        /**
         * 设置标注文本
         */
        set text(value) {
            this.setText({ title: value });
        }
        /**
         * 获取图标
         */
        get icon() {
            if (Cegore.TypeCheck.isDefined(this._czIcon))
                return this._czIcon.image.src;
        }
        /**
         * 设置图标
         */
        set icon(value) {
            this.setIcon({ img: value });
        }
        /**
         * 获取事件
         */
        get events() { return this._events; }
        /**
         * 应用属性
         * @param val 属性值
         * @param tar 目标
         * @param name 目标属性名
         * @param type 属性类型
         */
        _applyProp(val, tar, name, type) {
            if (!Cegore.TypeCheck.isDefined(val))
                return;
            let propval;
            switch (type) {
                case 'Cartesian2':
                    propval = new Cesium.Cartesian2(val[0], val[1]);
                    break;
                case 'Color':
                    propval = Cesium.Color.fromCssColorString(val);
                    break;
                default: propval = val;
            }
            tar[name] = propval;
        }
        /**
         * 应用文本属性
         * @private
         *
         * @param val
         * @param name
         * @param type
         */
        _applyTextProp(val, name, type) {
            this._applyProp(val, this._czText, name, type);
        }
        /**
         * 应用文本属性
         * @private
         *
         * @param val
         * @param name
         * @param type
         */
        _applyIconProp(val, name, type) {
            this._applyProp(val, this._czIcon, name, type);
        }
        /**
         * 设置文字
         * @param text 文本信息
         */
        setText(text) {
            if (!Cegore.TypeCheck.isDefined(text))
                return;
            if (!Cegore.TypeCheck.isDefined(this._czText)) {
                this._czText = new Cesium.LabelGraphics();
                this._czEntity.label = this._czText;
            }
            if (Cegore.TypeCheck.isDefined(text.font) || Cegore.TypeCheck.isDefined(text.size)) {
                let fontname = Cegore.TypeCheck.defaultValue(text.font, 'sans-serif');
                let fontsize = Cegore.TypeCheck.defaultValue(text.size, '10');
                this._czText.font = fontsize + 'px ' + fontname;
            }
            this._applyTextProp(text.title, 'text');
            this._applyTextProp(text.color, 'fillColor', 'Color');
            if (Cegore.TypeCheck.isDefined(text.border)) {
                this._applyTextProp(text.border.color, 'outlineColor', 'Color');
                this._applyTextProp(text.border.width, 'outlineWidth');
            }
            /// 
            if (Cegore.TypeCheck.isDefined(text.unit)) {
                this._applyTextProp(text.unit.offset, 'pixelOffset', 'Cartesian2');
                if (Cegore.TypeCheck.isDefined(text.unit.offset))
                    this.mAutoOffset = false;
            }
        }
        /**
         * 设置图标
         * @param icon
         */
        setIcon(icon) {
            if (!Cegore.TypeCheck.isDefined(icon))
                return;
            if (!Cegore.TypeCheck.isDefined(this._czIcon)) {
                this._czIcon = new Cesium.BillboardGraphics();
                this._czEntity.billboard = this._czIcon;
            }
            let imgurl;
            if (Cegore.TypeCheck.isString(icon.img)) {
                imgurl = icon.img;
            }
            else if (Cegore.TypeCheck.isArray(icon.img) && icon.img.length > 0) {
                imgurl = icon.img[0];
                ;
            }
            if (Cegore.TypeCheck.isDefined(imgurl)) {
                let _self = this;
                let img = new Image();
                img.src = imgurl;
                img.onload = function () {
                    _self._czIcon.image = img;
                    /// 自动根据图标的大小计算文字偏移
                    if (_self.mAutoOffset && Cegore.TypeCheck.isDefined(_self._czText)) {
                        let scale = _self._czIcon.scale ? _self._czIcon.scale.getValue() : 1;
                        let off = img.height * scale;
                        _self._czText.pixelOffset = new Cesium.Cartesian2(0, -off);
                    }
                };
            }
            this._applyIconProp(icon.scale, 'scale');
            this._applyIconProp(icon.color, 'color', 'Color');
            /// 
            if (Cegore.TypeCheck.isDefined(icon.unit)) {
                this._applyIconProp(icon.unit.offset, 'pixelOffset', 'Cartesian2');
            }
        }
    }
    Cegore.Label = Label;
})(Cegore || (Cegore = {}));
/*
 * File of class LabelCollection
 */
var Cegore;
(function (Cegore) {
    /**
     * 标注集合
     */
    class LabelCollection {
        /**
         * 构造函数
         *
         * @param viewer
         */
        constructor(scene) {
            this._layers = new Cegore.HashMap(function () { return new Cegore.HashMap(); });
            this.mLabelEvent = new Cegore.EventHandle();
            this._scene = scene;
            this._czData = scene._czdata;
            this._czDataSource = new Cesium.CustomDataSource("LabelCollection");
            this._czData.viewer.dataSources.add(this._czDataSource);
            this._czEntities = this._czDataSource.entities;
            var self = this;
            this.mCZHandle = new Cesium.ScreenSpaceEventHandler(this._czData.scene.canvas);
            this.mCZHandle.setInputAction((movement) => { this.onLabelMoveEvent(movement); }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this.mCZHandle.setInputAction((movement) => { this.onLabelClickEvent(movement); }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }
        // 标注鼠标移动事件
        onLabelMoveEvent(movement) {
        }
        // 标注点击事件
        onLabelClickEvent(movement) {
            var label = this.pick(movement.position);
            if (!Cegore.TypeCheck.isDefined(label))
                return;
            ///
            label.events.fire('onclick', label, movement.position);
            this.mLabelEvent.fire('onclick', label, movement.position);
        }
        /**
         * 获取对象
         * @private
         */
        _getOrCreateLayer(layerName) {
            return this._layers.getOrCreate(layerName, null);
        }
        /**
         * 获取对象
         * @private
         */
        _getLayer(layerName) {
            return this._layers.get(layerName);
        }
        /**
         * 获取全局标注事件
         */
        get events() { return this.mLabelEvent; }
        /**
         * 添加标注
         * @param label 标注对象
         */
        add(label) {
            /// 删除旧的标注图层
            this.remove(label);
            if (!Cegore.TypeCheck.isInstanceOf(label, Cegore.Label)) {
                label = new Cegore.Label(label);
            }
            this._getOrCreateLayer(label.layer).put(label.name, label);
            this._czEntities.add(label._czRenderable);
            return label;
        }
        /**
         * 获取标注对象
         *
         * @param {String} name 标注的名称
         * @param {String} layer 标注的图层
         */
        get(name, layer) {
            layer = Cegore.TypeCheck.defaultValue(layer, '');
            var lyr = this._getLayer(layer);
            if (!Cegore.TypeCheck.isDefined(lyr))
                return;
            return lyr.get(name);
        }
        pick(p1, p2) {
            var pt;
            /// 传入的是数组 pick([1, 2]);
            if (Cegore.TypeCheck.isArray(p1)) {
                var arr = p1;
                pt = new Cesium.Cartesian2(arr[0], arr[1]);
            }
            /// 传入的是 Cesium.Cartesian2
            else if (p1 instanceof Cesium.Cartesian2) {
                pt = p1;
            }
            /// 传入的是对象 pick({x:1, y:2})
            else if (Cegore.TypeCheck.isObject(p1)) {
                var obj = p1;
                pt = new Cesium.Cartesian2(obj.x, obj.y);
            }
            else {
                pt = new Cesium.Cartesian2(p1, p2);
            }
            ///
            var pickObj = this._czData.scene.pick(pt);
            if (Cegore.TypeCheck.isDefined(pickObj)) {
                var id = Cegore.TypeCheck.defaultValue(pickObj.id, pickObj.primitive.id);
                if ((id instanceof Cesium.Entity) && (id['_zMapRenderable'] instanceof Cegore.Label)) {
                    return id['_zMapRenderable'];
                }
            }
        }
        remove(p1, p2) {
            let label;
            if (Cegore.TypeCheck.isString(p1)) {
                label = this.get(p1, p2);
            }
            else if (Cegore.TypeCheck.isInstanceOf(p1, Cegore.Label)) {
                label = p1;
            }
            else if (Cegore.TypeCheck.isObject(p1)) {
                label = this.get(p1.name, p1.layer);
            }
            else {
                throw "invaild param!";
            }
            if (!Cegore.TypeCheck.isInstanceOf(label, Cegore.Label)) {
                return;
            }
            /// 
            var entity = label._czRenderable;
            this._czEntities.remove(entity);
            ///
            var layer = this._getLayer(label.layer);
            if (Cegore.TypeCheck.isDefined(layer)) {
                layer.remove(label.name);
            }
        }
        /**
         * 移除标注图层
         *
         * @param {String} layerName 图层的名称
         */
        removeLayer(layerName) {
            var layer = this._getLayer(layerName);
            if (!Cegore.TypeCheck.isDefined(layer))
                return;
            var labels = layer.keys();
            for (var i = 0; i < labels.length; ++i) {
                var entity = layer.get(labels[i]);
                this._czEntities.remove(entity);
            }
            this._layers.remove(layerName);
        }
        /**
         * 移除所有标注
         */
        removeAll() {
            this._czEntities.removeAll();
            this._layers.clear();
        }
        /**
         * 移除所有标注
         */
        clear() {
            this.removeAll();
        }
    }
    Cegore.LabelCollection = LabelCollection;
})(Cegore || (Cegore = {}));
/**
 * end of file LabelCollection
 */
/*
 * File of class Scene
 */
var Cegore;
(function (Cegore) {
    /**
     * 场景的显示模式模式
     */
    let SceneMode;
    (function (SceneMode) {
        /**
         * 哥伦布视图模式。
         * 一个2.5D透视视图。
         */
        SceneMode[SceneMode["COLUMBUS_VIEW"] = 1] = "COLUMBUS_VIEW";
        /**
         * 正在变形中
         */
        SceneMode[SceneMode["MORPHING"] = 0] = "MORPHING";
        /**
         * 2D模式，使用从上向下的正射投影
         */
        SceneMode[SceneMode["SCENE2D"] = 2] = "SCENE2D";
        /**
         * 3D模式，一个传统的三维透视视图和地球
         */
        SceneMode[SceneMode["SCENE3D"] = 3] = "SCENE3D";
    })(SceneMode = Cegore.SceneMode || (Cegore.SceneMode = {}));
    /**
     * 阴影模式
     */
    let ShadowMode;
    (function (ShadowMode) {
        /**
         * 禁用阴影，不产生也不接受阴影
         */
        ShadowMode[ShadowMode["DISABLED"] = 0] = "DISABLED";
        /**
         * 启用阴影，产生和接受阴影
         */
        ShadowMode[ShadowMode["ENABLED"] = 1] = "ENABLED";
        /**
         * 仅产生阴影
         */
        ShadowMode[ShadowMode["CAST_ONLY"] = 2] = "CAST_ONLY";
        /**
         * 仅接受阴影
         */
        ShadowMode[ShadowMode["RECEIVE_ONLY"] = 3] = "RECEIVE_ONLY";
    })(ShadowMode = Cegore.ShadowMode || (Cegore.ShadowMode = {}));
    /**
     * 场景管理器
     *
     * 场景管理器负责管理所有的三维图形对象和状态，场景管理器不需要直接创建，通过 Viewer.scene 获取场景管理器对象
     *
     * @see
     * Viewer
     */
    class Scene {
        /**
         * 构造函数，构造一个新的场景对象
         *
         * 不要自己构造 Scene 对象，通过Viewer.scene获取场景对象
         *
         * @param viewer 视图类
         */
        constructor(viewer) {
            this._isUnderWater = false;
            this._viewer = viewer;
            this._czData = viewer._czdata;
            this._czScene = this._czData.scene;
            this._globe = new Cegore.Globe(this);
            this._labels = new Cegore.LabelCollection(this);
            this._models = new Cegore.ModelCollection(this);
        }
        /**
         * @private
         */
        get _czdata() { return this._czData; }
        /**
         * 获取当前场景的显示模式
         */
        get mode() { return this._czScene.mode; }
        /**
         * 设置当前场景的显示模式
         */
        set mode(mode) { this._czScene.mode = mode; }
        /**
         * 获取全球对象
         */
        get globe() { return this._globe; }
        /**
         * 获取模型集合
         */
        get models() { return this._models; }
        /**
         * 获取标注集合
         */
        get labels() { return this._labels; }
        /**
         * 是否启用雾效，默认值：true
         */
        get enableFog() { return this._czScene.fog.enabled; }
        /**
         * 是否启用雾效，默认值：true
         */
        set enableFog(enable) { this._czScene.fog.enabled = enable; }
        /**
         * 雾的浓度，默认值：2.0e-4
         */
        get fogDensity() { return this._czScene.fog.density; }
        /**
         * 雾的浓度，默认值：2.0e-4
         */
        set fogDensity(value) { this._czScene.fog.density = value; }
        /**
         * 是否启用全屏抗锯齿，默认值：true
         */
        get enableFXAA() { return this._czScene.fxaa; }
        /**
         * 是否启用全屏抗锯齿，默认值：true
         */
        set enableFXAA(enable) { this._czScene.fxaa = enable; }
        /**
         * 地形缩放系数
         */
        get terrainScale() { return this._czScene.terrainExaggeration; }
        /**
         * 地形缩放系数
         */
        set terrainScale(scale) { this._czScene.terrainExaggeration = scale; }
        /**
         * 准备绘制事件，事件传递出当前时间
         * 事件原型 `function(time) {}`
         * @event
         */
        get preRender() {
            if (!Cegore.TypeCheck.isDefined(this._preRender)) {
                this._preRender = new Cegore.Event();
                this._czScene.preRender.addEventListener((sc, t) => { this._preRender.fire(Cesium.JulianDate.toDate(t)); });
            }
            return this._preRender;
        }
        /**
         * 绘制后事件，事件传递出当前时间
         * 事件原型 `function(time) {}`
         * @event
         */
        get postRender() {
            if (!Cegore.TypeCheck.isDefined(this._poseRender)) {
                this._poseRender = new Cegore.Event();
                this._czScene.poseRender.addEventListener((sc, t) => { this._poseRender.fire(Cesium.JulianDate.toDate(t)); });
            }
            return this._poseRender;
        }
        /**
         * 获取是否水下模式
         */
        get underWater() {
            return this._isUnderWater;
        }
        /**
         * 设置是否启用水下模式
         */
        set underWater(enable) {
            if (!Cegore.TypeCheck.isDefined(this._UnderWaterMaterial)) {
                this._UnderWaterMaterial = new Cesium.Material({
                    fabric: {
                        type: 'GlobeFog',
                        uniforms: {
                            fogColor: Cesium.Color.fromBytes(44, 59, 103)
                        },
                        source: Scene._GlobeFog
                    },
                    translucent: function (material) {
                        return false;
                    }
                });
            }
            if (enable) {
                this._czScene.globe.material = this._UnderWaterMaterial;
                var globeps = Cesium._shaders.GlobeFS;
                var pos = globeps.indexOf("czm_material material = czm_getMaterial(materialInput);\n");
                globeps = globeps.substr(0, pos) +
                    "materialInput.positionToEyeEC = v_positionEC;\n" +
                    globeps.substr(pos);
                this._czScene.globe._surfaceShaderSet.baseFragmentShaderSource.sources[1] = globeps;
            }
            else {
                this._czScene.globe.material = undefined;
            }
            /// 水下模式关闭地形雾效
            this.enableFog = !enable;
            this._isUnderWater = enable;
        }
        pick(v0, v1) {
            let pt = Scene.asCartesian2(v0, v1);
            var pickObj = this._czScene.pick(pt);
            if (!Cegore.TypeCheck.isDefined(pickObj))
                return undefined;
            var id = Cegore.TypeCheck.defaultValue(pickObj.id, pickObj.primitive.id);
            if ((id instanceof Cesium.Entity) && (id['_zMapRenderable'] instanceof Cegore.Renderable)) {
                return id['_zMapRenderable'];
            }
            return undefined;
        }
        pickMulti(v0, v1, max) {
            let picks = [];
            let pt = Scene.asCartesian2(v0, v1);
            let objs = this._czScene.pick(pt);
            if (!Cegore.TypeCheck.isArray(objs))
                return picks;
            for (let i = 0; i < objs.length; ++i) {
                let obj = objs[i];
                var id = Cegore.TypeCheck.defaultValue(objs.id, objs.primitive.id);
                if ((id instanceof Cesium.Entity) && (id['_zMapRenderable'] instanceof Cegore.Renderable)) {
                    picks.push(id['_zMapRenderable']);
                }
            }
            return picks;
        }
        pickPosition(v0, v1) {
            let pos2d = Scene.asCartesian2(v0, v1);
            let pos3d = this._czScene.pickPosition(pos2d);
            let posgeo = Cesium.Cartographic.fromCartesian(pos3d);
            return new Cegore.Position(posgeo);
        }
        /**
         * 计算平面距离
         *
         * @param pts 点列表，数据格式：
         * ```
         *  [[x1,y1],[x2,y2],...]
         *  [{x:x1, y:y1}, {x:x2, y:y2}, ...]
         *  [Position, Position, Position]
         * ```
         *  等
         */
        calcDistance(pts) {
            return Cegore.GeoMath.surfaceDistance(pts, this._czData.ellipsoid.x);
        }
        /**
         * 计算地球表面上多边形的投影面积
         * @param pts 多边形的点序列，数据格式：
         * ```
         *  [[x1,y1],[x2,y2],...]
         *  [{x:x1, y:y1}, {x:x2, y:y2}, ...]
         *  [Position, Position, Position]
         * ```
         *  等
         */
        calcArea(pts) {
            return Cegore.GeoMath.surfaceArea(pts, this._czData.ellipsoid.x);
        }
        /**
         * 解析二维坐标
         * @param p1
         * @param p2
         */
        static asCartesian2(p1, p2) {
            if (Cegore.TypeCheck.isInstanceOf(p1, Cesium.Cartesian2))
                return p1;
            let x, y;
            switch (Cegore.TypeCheck.typeOf(p1)) {
                case 'number':
                    if (Cegore.TypeCheck.isNumber(p2)) {
                        x = p1;
                        y = p2;
                    }
                    break;
                case 'array':
                    x = Cegore.StringUtil.parseFloat(p1[0]);
                    y = Cegore.StringUtil.parseFloat(p1[1]);
                    break;
                case 'object':
                    x = Cegore.StringUtil.parseFloat(p1.x);
                    y = Cegore.StringUtil.parseFloat(p1.y);
                    break;
            }
            if (!Cegore.TypeCheck.isDefined(x) ||
                !Cegore.TypeCheck.isDefined(y) ||
                isNaN(x) || isNaN(y)) {
                throw 'error params!';
            }
            return new Cesium.Cartesian2(x, y);
        }
    }
    Scene._GlobeFog = "\
        uniform vec4 fogColor;\n\
        czm_material czm_getMaterial(czm_materialInput materialInput)\n\
        {\n\
            czm_material material = czm_getDefaultMaterial(materialInput);\n\
            float distanceToCamera = length(materialInput.positionToEyeEC);\n\
            float scalar = distanceToCamera * 0.00005;\n\
            float fog = 1.0 - exp(-(scalar * scalar));\n\
            material.diffuse = fogColor.rgb;\n\
            material.alpha = fog;\n\
            return material;\n\
        }\n";
    Cegore.Scene = Scene;
})(Cegore || (Cegore = {}));
/**
 * End of file
 */ 
/*
 * File of class Viewer
 */
var Cegore;
(function (Cegore) {
    /**
     *
     */
    class CesiumData {
        constructor(viewer) {
            this.mViewer = viewer;
        }
        get viewer() { return this.mViewer; }
        get scene() { return this.mViewer.scene; }
        get camera() { return this.mViewer.camera; }
        get globe() { return this.mViewer.scene.globe; }
        get ellipsoid() { return this.mViewer.scene.globe.ellipsoid; }
    }
    Cegore.CesiumData = CesiumData;
    /**
     * 视图类
     *
     * 用来构建应用最基本的类
     *
     * @example
     * ```ts
     *  var viewer = new Cesium.Viewer('Container', {
     *      /// 指定地形数据
     *      terrain: {
     *          url: 'http://localhost:9081/zs/data/tdt/dem'
     *      },
     *      /// 指定影像数据
     *      images:[{
     *              name : 'TdtImage',
     *              url: 'http://localhost:9081/zs/data/tdtonline/image'
     *          }
     *      ],
     *      /// 指定当前的时间
     *      currentTime: new Date(2017,12,26,12,0,0),
     *      /// 指定是否显示全屏按钮
     *      fullscreenButton: true,
     *      /// 指定全屏显示的DOM
     *      fullscreenElement: 'Container',
     *  });
     * ```
     */
    class Viewer {
        /**
         * 获取版本信息
         */
        static get version() { return '1.1.0'; }
        /**
         *
         * @param container 用做显示的DOM对象的或者ID
         * @param options 可选的参数
         * @param options.terrain 地形数据源，具体定义参见 Globe.setTerrain()
         * @param options.images 地图影像图层数组，具体定义参见 Globe.addImage()
         * @param options.currentTime 当前时间，默认为系统时间
         * @param options.shadows 是否生成阴影，默认值：false
         * @param options.fullscreenButton 是否显示“全屏显示按钮”，默认值为true
         * @param options.fullscreenElement 用作全屏显示的DOM对象或者ID，默认值为container
         * @param
         */
        constructor(container, options) {
            if (!options)
                options = {};
            var defOptions = options.czops || {};
            defOptions.shouldAnimate = options.shouldAnimate ? true : false;
            defOptions.animation = options.animation ? true : false;
            defOptions.baseLayerPicker = options.baseLayerPicker ? true : false;
            defOptions.homeButton = options.homeButton ? true : false;
            defOptions.geocoder = options.geocoder ? true : false;
            defOptions.navigationHelpButton = options.navigationHelpButton ? true : false;
            defOptions.imageryProvider = options.imageryProvider ? true : false;
            defOptions.timeline = options.timeline ? true : false;
            defOptions.sceneModePicker = options.sceneModePicker ? true : false;
            defOptions.selectionIndicator = options.selectionIndicator ? true : false;
            defOptions.infoBox = options.infoBox ? true : false;
            defOptions.fullscreenButton = Cegore.TypeCheck.defaultValue(options.fullscreenButton, true);
            defOptions.fullscreenElement = Cegore.TypeCheck.defaultValue(options.fullscreenElement, container);
            var defContextOpts = defOptions.contextOptions || {};
            var defWebGl = defContextOpts.webgl || {};
            ///
            defWebGl.preserveDrawingBuffer = Cegore.TypeCheck.defaultValue(defWebGl.preserveDrawingBuffer, true);
            ///
            defContextOpts.webgl = defWebGl;
            defOptions.contextOptions = defContextOpts;
            /// 构造Cesium的Viewer
            const czviewer = new Cesium.Viewer(container, defOptions);
            const creditContainer = czviewer.cesiumWidget.creditContainer;
            creditContainer.style.display = "none";
            /// 高动态
            czviewer.scene.highDynamicRange = Cegore.TypeCheck.defaultValue(options.highDynamicRange, false);
            /// 保存一些对象
            this._czData = new CesiumData(czviewer);
            /// 
            this._camera = new Cegore.Camera(this);
            this._clock = new Cegore.Clock(this);
            this._scene = new Cegore.Scene(this);
            this._controller = new Cegore.CameraController(czviewer.scene);
            this._controller.enableFlatMode = false;
            this._controller.enableInputs = false;
            const ctrl = czviewer.scene.screenSpaceCameraController;
            ctrl.minimumCollisionTerrainHeight = 150000;
            /// 倾斜使用右键拖拽，触摸
            ctrl.tiltEventTypes = [Cesium.CameraEventType.RIGHT_DRAG, Cesium.CameraEventType.PINCH];
            /// 缩放使用滚轮，触摸，和左键+Ctrl
            ctrl.zoomEventTypes = [Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH, {
                    eventType: Cesium.CameraEventType.LEFT_DRAG,
                    modifier: Cesium.KeyboardEventModifier.CTRL
                }];
            ///
            this._cesium_controller = ctrl;
            /// 修改默认操作模式
            if (!window['USE_CESIUM_CAMERA_CONTROLLER']) {
                ///
                this._cesium_controller.enableInputs = false;
                this._controller.enableInputs = true;
                czviewer.scene['_screenSpaceCameraController'] = this._controller;
            }
            /// 初始化地形
            if (Cegore.TypeCheck.isObject(options.terrain)) {
                this.globe.setTerrain(options.terrain);
            }
            /// 初始化图层
            if (Cegore.TypeCheck.isArray(options.images)) {
                for (var i = 0; i < options.images.length; ++i) {
                    this.globe.images.add(options.images[i]);
                }
            }
            if (Cegore.TypeCheck.isDefined(options.currentTime)) {
                this._clock.currentTime = options.currentTime;
            }
        }
        /**
         * @private
         * @inner
         */
        get _czdata() { return this._czData; }
        /**
         * 获取相机
         */
        get camera() { return this._camera; }
        /**
         * 获取场景管理器
         */
        get scene() { return this._scene; }
        /**
         * 获取模型集合
         */
        get models() { return this._scene.models; }
        /**
         * 获取标注集合
         */
        get labels() { return this._scene.labels; }
        /**
         * 获取球对象
         */
        get globe() { return this._scene.globe; }
        /**
         * 获取影像图层
         */
        get images() { return this.globe.images; }
        /**
         * 获取时钟对象
         */
        get clock() { return this._clock; }
        /**
         * 获取用于绘图的Canvas元素
         */
        get canvas() { return this._czData.viewer.canvas; }
        /**
         * 获取控制器
         */
        get cameraController() { return this._controller; }
        /**
         * 获取根url
         */
        static getBaseUrlFromScript() {
            var scripts = document.getElementsByTagName('script');
            for (var i = 0, len = scripts.length; i < len; ++i) {
                var src = scripts[i].getAttribute('src');
                var result = Viewer.cesiumScriptRegex.exec(src);
                if (result !== null) {
                    return result[1];
                }
            }
            return undefined;
        }
    }
    /**
     * 自定义cesium脚本路径，否则Cesium会初始化失败
     */
    Viewer.cesiumScriptRegex = /((?:.*\/)|^)depmain[\w-]*\.js(?:\W|$)/i;
    Cegore.Viewer = Viewer;
    CESIUM_BASE_URL = Viewer.getBaseUrlFromScript();
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    /**
     * 抽象影像Provider
     */
    class AbstractImageProvider {
        constructor() {
            this._readyPromise = Cesium.when.resolve(true);
            this._tileWidth = 256;
            this._tileHeight = 256;
            this._minimumLevel = 0;
            this._maximumLevel = 18;
            this._errorEvent = new Cesium.Event();
            this._hasAlphaChannel = false;
        }
        ;
        /**
         * 表示当前Provider是否准备好了
         */
        get ready() { return this._ready; }
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         * @memberof ImageryProvider.prototype
         * @type {Promise.<Boolean>}
         * @readonly
         */
        get readyPromise() { return this._readyPromise; }
        /**
         * 获取数据的范围信息
         */
        get rectangle() {
            if (!Cegore.TypeCheck.isDefined(this._rectangle))
                this._rectangle = Cesium.Rectangle.MAX_VALUE;
            ///
            return this._rectangle;
        }
        /**
         * 获取每个瓦片的像素宽度
         */
        get tileWidth() { return this._tileWidth; }
        /**
         * 获取每个瓦片的像素高度
         */
        get tileHeight() { return this._tileHeight; }
        /**
         * 获取当前Provider支持的最笑级别
         */
        get minimumLevel() { return this._minimumLevel; }
        /**
         * 获取当前Provider支持的最大级别
         */
        get maximumLevel() { return this._maximumLevel; }
        /**
         * 获取当前瓦片的切片方案
         */
        get tilingScheme() {
            if (!Cegore.TypeCheck.isDefined(this._tilingScheme))
                this._tilingScheme = new Cesium.GeographicTilingScheme();
            ///
            return this._tilingScheme;
        }
        get tileDiscardPolicy() { return this._tileDiscardPolicy; }
        get errorEvent() { return this._errorEvent; }
        get credit() { return this._credit; }
        /**
         * 获取代理信息
         */
        get proxy() { return this._proxy; }
        /**
         * 获取当前图层是否包含透明信息
         */
        get hasAlphaChannel() { return this._hasAlphaChannel; }
        /////////////////
        getTileCredits(x, y, level) { return undefined; }
        /**
         * 拾取要素数据
         * @param x
         * @param y
         * @param level
         * @param longitude
         * @param latitude
         */
        pickFeatures(x, y, level, longitude, latitude) { return undefined; }
    }
    Cegore.AbstractImageProvider = AbstractImageProvider;
})(Cegore || (Cegore = {}));
var Cegore;
(function (Cegore) {
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('ArcGisMapServer', { createProvider: function (options) {
            return new Cesium.ArcGisMapServerImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('BingMaps', { createProvider: function (options) {
            return new Cesium.BingMapsImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('Grid', { createProvider: function (options) {
            return new Cesium.GridImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('Mapbox', { createProvider: function (options) {
            return new Cesium.MapboxImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('SingleTile', { createProvider: function (options) {
            return new Cesium.SingleTileImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('WMS', { createProvider: function (options) {
            return new Cesium.WebMapServiceImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('WMTS', { createProvider: function (options) {
            return new Cesium.WebMapTileServiceImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('UrlTemplate', { createProvider: function (options) {
            return new Cesium.UrlTemplateImageryProvider(options);
        } });
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('TileCoordinates', { createProvider: function (options) {
            return new Cesium.TileCoordinatesImageryProvider(options);
        } });
})(Cegore || (Cegore = {}));
/*
 * File of class ZMapImageProvider
 */
var Cegore;
(function (Cegore) {
    /**
     * 兆图地服务Provider
     */
    class ZMapImageProvider {
        /**
         * 构造函数
         * @param opt
         */
        constructor(opt) {
            /**
             *
             */
            this.getTileCredits = function (x, y, level) {
                return undefined;
            };
            /**
             *
             */
            this.requestImage = function (x, y, level) {
                if (!this._ready) {
                    throw new Cesium.DeveloperError('requestImage must not be called before the imagery provider is ready.');
                }
                var url = ZMapImageProvider.buildImageUrl(this, x, y, level);
                return Cesium.ImageryProvider.loadImage(this, url);
            };
            var trailingSlashRegex = /\/$/;
            var defaultCredit = new Cesium.Credit('WMTS');
            opt = Cesium.defaultValue(opt, {});
            /// 数据url
            var url = Cesium.defaultValue(opt.url, 'http://localhost:88/wmts');
            if (!trailingSlashRegex.test(url)) {
            }
            this._url = url;
            if (this._url.indexOf('?') == -1) {
                if (!Cegore.StringUtil.endsWidth(this._url, '/tile/map', true))
                    this._url += '/tile/map';
                ///
                this._url += '?';
            }
            ///
            this._url += '&origin=left|top';
            this._proxy = opt.proxy;
            this._tileDiscardPolicy = opt.tileDiscardPolicy;
            this._scheme = Cesium.defaultValue(opt.scheme, 'Geographic');
            this._tilingScheme = Cesium.defaultValue(opt.tilingScheme, new Cesium.WebMercatorTilingScheme());
            this._tileWidth = 256;
            this._tileHeight = 256;
            this._minimumLevel = Cesium.defaultValue(opt.minimumLevel, 0);
            this._maximumLevel = Cesium.defaultValue(opt.maximumLevel, 18);
            this._rectangle = Cesium.defaultValue(Cegore.Rectangle.toCZRectangle(opt.rectangle), this._tilingScheme.rectangle);
            this._errorEvent = new Cesium.Event();
            this._ready = true;
            var credit = Cesium.defaultValue(opt.credit, defaultCredit);
            if (typeof credit === 'string') {
                credit = new Cesium.Credit(credit);
            }
            this._credit = credit;
        }
        get url() { return this._url; }
        get hasAlphaChannel() { return true; }
        get proxy() { return this._proxy; }
        get tileWidth() { return this._tileWidth; }
        get tileHeight() { return this._tileHeight; }
        get maximumLevel() { return this._maximumLevel; }
        get minimumLevel() { return this._minimumLevel; }
        get tilingScheme() { return this._tilingScheme; }
        get rectangle() { return this._rectangle; }
        get ileDiscardPolicy() { return this._tileDiscardPolicy; }
        get errorEvent() { return this._errorEvent; }
        get ready() { return this._ready; }
        get credit() { return this._credit; }
        ///
        static buildImageUrl(provider, x, y, level) {
            var olevel = level;
            var proxy = provider._proxy;
            if (provider._scheme !== 'WebMercator') {
                if (provider._scheme.endsWith('level-0'))
                    level = level + 1;
                else
                    level = level;
            }
            var rect = new Cegore.Rectangle(provider._tilingScheme.tileXYToRectangle(x, y, olevel));
            var url = provider._url +
                '&id=' + level + ',' + y + ',' + x +
                '&range=' + rect.west + ',' + rect.south + ',' + rect.east + ',' + rect.north;
            if (Cesium.defined(proxy)) {
                url = proxy.getURL(url);
            }
            return url;
        }
    }
    /**
     * 兆图地图影像数据服务 Provider 工厂
     */
    class ZMapImageProviderFactory {
        createProvider(options) {
            return new ZMapImageProvider(options);
        }
    }
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('ZMapImage', new ZMapImageProviderFactory());
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of class ZMapImageProvider
 */
var Cegore;
(function (Cegore) {
    /**
     * 兆图地服务Provider
     */
    class ZMapDemImageProvider {
        /**
         * 构造函数
         * @param opt
         */
        constructor(opt) {
            var trailingSlashRegex = /\/$/;
            var defaultCredit = new Cesium.Credit('WMTS');
            opt = Cegore.TypeCheck.defaultValue(opt, {});
            /// 数据url
            var url = Cesium.defaultValue(opt.url, 'http://localhost:88/wmts');
            if (!trailingSlashRegex.test(url)) {
            }
            this._url = url;
            if (this._url.indexOf('?') == -1) {
                if (!Cegore.StringUtil.endsWidth(this._url, '/tile/dem', true))
                    this._url += '/tile/dem';
                ///
                this._url += '?';
            }
            ///
            this._url += '&origin=left|top';
            this._proxy = opt.proxy;
            this._scheme = Cesium.defaultValue(opt.scheme, 'Geographic');
            if (this._scheme === 'WebMercator') {
                this._tilingScheme = new Cesium.WebMercatorTilingScheme({ ellipsoid: opt.ellipsoid });
            }
            else {
                if (this._scheme.endsWith('level-0'))
                    this._tilingScheme = new Cesium.GeographicTilingScheme({ ellipsoid: opt.ellipsoid });
                else
                    this._tilingScheme = new Cesium.GeographicTilingScheme({
                        ellipsoid: opt.ellipsoid,
                        numberOfLevelZeroTilesX: 8,
                        numberOfLevelZeroTilesY: 4
                    });
            }
            this._tileWidth = Cegore.TypeCheck.defaultValue(opt.tileWidth, 128);
            this._tileHeight = Cegore.TypeCheck.defaultValue(opt.tileHeight, 128);
            this._minVal = Cegore.TypeCheck.defaultValue(opt.minVal, 0);
            this._maxVal = Cegore.TypeCheck.defaultValue(opt.maxVal, 1000);
            this._minimumLevel = Cesium.defaultValue(opt.minimumLevel, 0);
            this._maximumLevel = Cesium.defaultValue(opt.maximumLevel, 18);
            //this._extent = Cesium.defaultValue(opt.extent, this._tilingScheme.extent);
            this._rectangle = Cesium.defaultValue(Cegore.Rectangle.toCZRectangle(opt.rectangle), this._tilingScheme.rectangle);
            this._errorEvent = new Cesium.Event();
            this._ready = true;
            var credit = Cesium.defaultValue(opt.credit, defaultCredit);
            if (typeof credit === 'string') {
                credit = new Cesium.Credit(credit);
            }
            this._credit = credit;
        }
        get url() { return this._url; }
        get hasAlphaChannel() { return true; }
        get proxy() { return this._proxy; }
        get tileWidth() { return this._tileWidth; }
        get tileHeight() { return this._tileHeight; }
        get maximumLevel() { return this._maximumLevel; }
        get minimumLevel() { return this._minimumLevel; }
        get tilingScheme() { return this._tilingScheme; }
        //get extent () { return this._extent; }
        get rectangle() { return this._rectangle; }
        get ileDiscardPolicy() { return undefined; }
        get errorEvent() { return this._errorEvent; }
        get ready() { return this._ready; }
        get credit() { return this._credit; }
        /**
         *
         */
        getTileCredits(x, y, level) {
            return undefined;
        }
        ;
        /**
         *
         */
        requestImage(x, y, level) {
            if (!this._ready) {
                throw new Cesium.DeveloperError('requestImage must not be called before the imagery provider is ready.');
            }
            var url = this.buildImageUrl(x, y, level);
            return Cesium.ImageryProvider.loadImage(this, url);
        }
        ;
        ///
        buildImageUrl(x, y, level) {
            const rectangle = this._tilingScheme.tileXYToRectangle(x, y, level);
            if (this._scheme !== 'WebMercator') {
                if (this._scheme.endsWith('level-0'))
                    level = level + 1;
                else
                    level = level;
            }
            var bbox = [
                Cesium.Math.toDegrees(rectangle.west),
                Cesium.Math.toDegrees(rectangle.south),
                Cesium.Math.toDegrees(rectangle.east),
                Cesium.Math.toDegrees(rectangle.north)
            ];
            var url = this._url;
            url += '&id=' + level + ',' + y + ',' + x;
            url += '&size=' + this._tileWidth + '%2C' + this._tileHeight;
            url += '&range=' + bbox.join(',');
            url += '&style=image&min=' + this._minVal + '&max=' + this._maxVal;
            ///
            return url;
        }
    }
    /**
     * 兆图地图影像数据服务 Provider 工厂
     */
    class ZMapImageProviderFactory {
        createProvider(options) {
            return new ZMapDemImageProvider(options);
        }
    }
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('ZMapDemImage', new ZMapImageProviderFactory());
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
/*
 * File of Class
 */
var Cegore;
(function (Cegore) {
    /**
     * 兆图地形数据源
     */
    class ZMapTerrainProvider {
        ///
        constructor(options) {
            this._tileWidth = 65;
            this._tileHeight = 65;
            this._heightOffset = 0;
            this._heightScale = 1;
            this._heightScaleOffset = 0;
            /// 
            this._qmesh = true;
            this._clipHeight = 0;
            this._clipInner = true;
            this._clipWall = true;
            this._clipFloor = true;
            this._url = options.url;
            if (this._url.indexOf('?') == -1) {
                if (!Cegore.StringUtil.endsWidth(this._url, '/tile/dem', true))
                    this._url += '/tile/dem';
                ///
                this._url += '?';
            }
            ///
            //this._url += '&origin=left|top'
            this._token = options.token;
            this._qmesh = Cegore.TypeCheck.defaultValue(options.qmesh, false);
            this._clip = options.clip;
            this._clipHeight = Cegore.TypeCheck.defaultValue(options.clipHeight, 0);
            this._clipInner = Cegore.TypeCheck.defaultValue(options.clipInner, true);
            this._clipFloor = Cegore.TypeCheck.defaultValue(options.clipFloor, true);
            this._clipWall = Cegore.TypeCheck.defaultValue(options.clipWall, true);
            this._waterMask = Cegore.TypeCheck.defaultValue(options.waterMask, false);
            this._waterHeight = Cegore.TypeCheck.defaultValue(options.waterHeight, 0);
            /// 瓦片的高宽
            this._tileWidth = Cegore.TypeCheck.defaultValue(options.tileWidth, 20);
            this._tileHeight = Cegore.TypeCheck.defaultValue(options.tileHeight, 20);
            ///
            this._heightOffset = Cegore.TypeCheck.defaultValue(options.heightOffset, 0);
            this._heightScale = Cegore.TypeCheck.defaultValue(options.heightScale, 1);
            this._heightScaleOffset = Cegore.TypeCheck.defaultValue(options.heightScaleOffset, 0);
            this._tilingScheme = options.tilingScheme;
            if (!Cesium.defined(this._tilingScheme)) {
                this._tilingScheme = new Cesium.GeographicTilingScheme({
                    ellipsoid: Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84)
                });
            }
            this._levelZeroMaximumGeometricError = 62617.21357121639;
            //this._levelZeroMaximumGeometricError = Cesium.TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(
            //    this._tilingScheme.ellipsoid, this._tileWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0));
            this._proxy = options.proxy;
            this._dataStruct = {
                heightScale: 1,
                heightOffset: 0,
                elementsPerHeight: 1,
                stride: 1,
                elementMultiplier: 256.0,
                isBigEndian: false
            };
            this._errorEvent = new Cesium.Event();
            var credit = options.credit;
            if (typeof credit === 'string') {
                credit = new Cesium.Credit(credit);
            }
            this._credit = credit;
            this._readyPromise = Cesium.when.resolve(true);
        }
        /**
         * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
         * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
         * are passed an instance of {@link TileProviderError}.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {Event}
         */
        get errorEvent() { return this._errorEvent; }
        /**
         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
         * the source of the terrain.  This function should not be called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {Credit}
         */
        get credit() { return this._credit; }
        /**
         * Gets the tiling scheme used by this provider.  This function should
         * not be called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {GeographicTilingScheme}
         */
        get tilingScheme() { return this._tilingScheme; }
        /**
         * Gets a value indicating whether or not the provider is ready for use.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {Boolean}
         */
        get ready() { return true; }
        /**
         * Gets a promise that resolves to true when the provider is ready for use.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {Promise.<Boolean>}
         * @readonly
         */
        get readyPromise() { return this._readyPromise; }
        /**
         * Gets a value indicating whether or not the provider includes a water mask.  The water mask
         * indicates which areas of the globe are water rather than land, so they can be rendered
         * as a reflective surface with animated waves.  This function should not be
         * called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {Boolean}
         */
        get hasWaterMask() { return this._waterMask; }
        /**
         * Gets a value indicating whether or not the requested tiles include vertex normals.
         * This function should not be called before {@link ArcGisImageServerTerrainProvider#ready} returns true.
         * @memberof ArcGisImageServerTerrainProvider.prototype
         * @type {Boolean}
         */
        get hasVertexNormals() { return false; }
        /**
         * Requests the geometry for a given tile.  This function should not be called before
         * {@link ArcGisImageServerTerrainProvider#ready} returns true.  The result includes terrain
         * data and indicates that all child tiles are available.
         *
         * @param {Number} x The X coordinate of the tile for which to request geometry.
         * @param {Number} y The Y coordinate of the tile for which to request geometry.
         * @param {Number} level The level of the tile for which to request geometry.
         * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
         *          returns undefined instead of a promise, it is an indication that too many requests are already
         *          pending and the request will be retried later.
         */
        requestTileGeometry(x, y, level, request) {
            var rectangle = this._tilingScheme.tileXYToRectangle(x, y, level);
            // Each pixel in the heightmap represents the height at the center of that
            // pixel.  So expand the rectangle by half a sample spacing in each direction
            // so that the first height is on the edge of the rectangle we need rather than
            // half a sample spacing into the rectangle.
            const xSpacing = (rectangle.east - rectangle.west) / (this._tileWidth - 1);
            const ySpacing = (rectangle.north - rectangle.south) / (this._tileHeight - 1);
            rectangle.west -= xSpacing * 0.5;
            rectangle.east += xSpacing * 0.5;
            rectangle.south -= ySpacing * 0.5;
            rectangle.north += ySpacing * 0.5;
            const bbox = [
                Cesium.Math.toDegrees(rectangle.west),
                Cesium.Math.toDegrees(rectangle.south),
                Cesium.Math.toDegrees(rectangle.east),
                Cesium.Math.toDegrees(rectangle.north)
            ];
            const url = this._url;
            const data = {
                id: `${level},${y},${x}`,
                size: `${this._tileWidth},${this._tileHeight}`,
                range: bbox.join(','),
                style: this._qmesh ? 'qmesh' : 'float',
                origin: 'left|top',
                scale: this._heightScale,
                scaleOffset: this._heightScaleOffset,
                offset: this._heightOffset,
            };
            /*
            url += '&id=' + level + ',' + y + ',' + x;
            url += '&size=' + this._tileWidth + '%2C' + this._tileHeight;
            url += '&range=' + bbox.join(',');
            url += '&style=' + (this._qmesh ? 'qmesh' : 'float');
            */
            if (this._qmesh && this._clip) {
                data.clip = this._clip;
                data['clip-h'] = this._clipHeight;
                data['clip-inner'] = this._clipInner;
                data['clip-wall'] = this._clipWall;
                data['clip-floor'] = this._clipFloor;
            }
            const body = Cegore.StringUtil.toPostFormBody(data);
            const promise = Cesium.Resource.post({
                url,
                proxy: this._proxy,
                data: body,
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                request,
                responseType: 'arraybuffer'
            });
            if (!Cesium.defined(promise)) {
                return undefined;
            }
            ///var that = this;
            return Cesium.when(promise, (image) => {
                if (this._qmesh)
                    return this.loadQMesh(image, x, y, level);
                ///
                return this.loadHeightmap(image);
            });
        }
        /**
         * Gets the maximum geometric error allowed in a tile at a given level.
         *
         * @param {Number} level The tile level for which to get the maximum geometric error.
         * @returns {Number} The maximum geometric error.
         */
        getLevelMaximumGeometricError(level) {
            return this._levelZeroMaximumGeometricError / (1 << level);
        }
        /**
         * Determines whether data for a tile is available to be loaded.
         *
         * @param {Number} x The X coordinate of the tile for which to request geometry.
         * @param {Number} y The Y coordinate of the tile for which to request geometry.
         * @param {Number} level The level of the tile for which to request geometry.
         * @returns {Boolean} Undefined if not supported, otherwise true or false.
         */
        getTileDataAvailable(x, y, level) {
            return undefined;
        }
        /**
         * 加载高程图
         * @param image
         * @returns
         */
        loadHeightmap(image) {
            const length = this._tileWidth * this._tileHeight;
            const byteFloatNum = length * 4;
            const byteDoubelNum = length * 8;
            let water, buffer;
            ///
            if (this._waterMask)
                water = new Uint8Array(length);
            if (image.byteLength == byteFloatNum) {
                buffer = new Float32Array(image);
                for (let i = 0; i < length; ++i) {
                    if (buffer[i] <= -100000)
                        buffer[i] = 0;
                }
            }
            else if (image.byteLength == byteDoubelNum) {
                /// 处理无效值
                buffer = new Float32Array(length);
                let data = new Float64Array(image);
                for (let i = 0; i < length; ++i) {
                    buffer[i] = data[i];
                    if (data[i] <= -100000)
                        buffer[i] = 0;
                }
            }
            else {
                buffer = new Float32Array(length);
            }
            if (this._waterMask) {
                for (let i = 0; i < length; ++i) {
                    if (buffer[i] < this._waterHeight)
                        water[i] = 255;
                    else
                        water[i] = 0;
                }
            }
            return new Cesium.HeightmapTerrainData({
                buffer: buffer,
                width: this._tileWidth,
                height: this._tileWidth,
                childTileMask: 15,
                waterMask: water,
                structure: this._dataStruct
            });
        }
        loadQMesh(image, x, y, level) {
            let pos = 0;
            const cartesian3Elements = 3;
            const boundingSphereElements = cartesian3Elements + 1;
            const cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;
            const boundingSphereLength = Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;
            const encodedVertexElements = 3;
            const encodedVertexLength = Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;
            const triangleElements = 3;
            const view = new DataView(image);
            /// 中心坐标
            const center = readCartesian3(view, pos);
            pos += cartesian3Length;
            /// 
            const range = [
                view.getFloat64(pos, true),
                view.getFloat64(pos + 8, true),
                view.getFloat64(pos + 16, true),
                view.getFloat64(pos + 24, true),
            ];
            pos += Float64Array.BYTES_PER_ELEMENT * 4;
            /// 最小最大高程
            const minimumHeight = view.getFloat32(pos, true);
            pos += Float32Array.BYTES_PER_ELEMENT;
            const maximumHeight = view.getFloat32(pos, true);
            pos += Float32Array.BYTES_PER_ELEMENT;
            /// 包围球
            const boundingSphere = new Cesium.BoundingSphere(readCartesian3(view, pos), view.getFloat64(pos + cartesian3Length, true));
            pos += boundingSphereLength;
            /// 水平遮挡点
            const horizonOcclusionPoint = readCartesian3(view, pos);
            pos += cartesian3Length;
            /// 顶点数据
            const vertexCount = view.getUint32(pos, true);
            pos += Uint32Array.BYTES_PER_ELEMENT;
            const encodedVertexBuffer = new Uint16Array(image, pos, vertexCount * 3);
            pos += vertexCount * encodedVertexLength;
            /// 索引数据
            const indices = readIndices(view, pos, triangleElements);
            pos += Uint32Array.BYTES_PER_ELEMENT + indices.byteLength;
            /// 边界数据
            const westIndices = readIndices(view, pos, 1);
            pos += Uint32Array.BYTES_PER_ELEMENT + westIndices.byteLength;
            const southIndices = readIndices(view, pos, 1);
            pos += Uint32Array.BYTES_PER_ELEMENT + southIndices.byteLength;
            const eastIndices = readIndices(view, pos, 1);
            pos += Uint32Array.BYTES_PER_ELEMENT + eastIndices.byteLength;
            const northIndices = readIndices(view, pos, 1);
            pos += Uint32Array.BYTES_PER_ELEMENT + northIndices.byteLength;
            const skirtHeight = this.getLevelMaximumGeometricError(level) * 5.0;
            const rectangle = this._tilingScheme.tileXYToRectangle(x, y, level);
            let orientedBoundingBox;
            if (rectangle.width < Cesium.Math.PI_OVER_TWO + Cesium.Math.EPSILON5) {
                // Here, rectangle.width < pi/2, and rectangle.height < pi
                // (though it would still work with rectangle.width up to pi)
                // The skirt is not included in the OBB computation. If this ever
                // causes any rendering artifacts (cracks), they are expected to be
                // minor and in the corners of the screen. It's possible that this
                // might need to be changed - just change to `minimumHeight - skirtHeight`
                // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.
                orientedBoundingBox = Cesium.OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, this._tilingScheme.ellipsoid);
            }
            if (vertexCount == 0) {
                throw new Error('blank');
            }
            ///
            return new Cesium.QuantizedMeshTerrainData({
                //center : center,
                minimumHeight: minimumHeight,
                maximumHeight: maximumHeight,
                boundingSphere: boundingSphere,
                orientedBoundingBox: orientedBoundingBox,
                horizonOcclusionPoint: horizonOcclusionPoint,
                quantizedVertices: encodedVertexBuffer,
                //encodedNormals : encodedNormalBuffer,
                indices: indices,
                westIndices: westIndices,
                southIndices: southIndices,
                eastIndices: eastIndices,
                northIndices: northIndices,
                westSkirtHeight: skirtHeight,
                southSkirtHeight: skirtHeight,
                eastSkirtHeight: skirtHeight,
                northSkirtHeight: skirtHeight,
                childTileMask: 15 //this.availability.computeChildMaskForTile(level, x, y),
                //waterMask: waterMaskBuffer,
                //credits: this._tileCredits
            });
        }
    }
    function readCartesian3(view, pos) {
        return new Cesium.Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));
    }
    function readIndices(view, pos, elements) {
        const iCount = view.getUint32(pos, true);
        pos += Uint32Array.BYTES_PER_ELEMENT;
        return new Uint16Array(view.buffer, pos, iCount * elements);
    }
    /**
     * 兆图地形服务Provider工厂
     */
    class ZMapTerrainProviderFactory {
        createProvider(options) {
            return new ZMapTerrainProvider(options);
        }
    }
    /** 注册工厂 */
    Cegore.Providers.TerrainProviders.regFactory('ZMapTerrain', new ZMapTerrainProviderFactory());
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
var Cegore;
(function (Cegore) {
    /**
     * 兆图地服务Provider
     */
    class HeatmapImageProvider extends Cegore.AbstractImageProvider {
        /**
         * 构造函数
         * @param options
         * @param options.data 热力图数据，数据中必须包含坐标和热度信息
         * @param options.xField X坐标字段名称
         * @param options.yField Y坐标字段名称
         * @param options.weightField 热度字段
         * @param options.weightScale 热度缩放参数
         * @param options.weightCalc 热度计算器
         */
        constructor(options) {
            super();
            this._weightScale = 1.0;
            this._shadow = 250;
            ///
            options = Cesium.defaultValue(options, {});
            ///
            this._xfield = options.xField;
            this._yfield = options.yField;
            this._weightField = options.weightField;
            this._weightScale = Cesium.defaultValue(options.weightScale, 1.0);
            this._weightCalc = options.weightCalc;
            this._tilingScheme = new Cesium.GeographicTilingScheme();
            this._minimumLevel = Cesium.defaultValue(options.minimumLevel, 0);
            this._maximumLevel = Cesium.defaultValue(options.maximumLevel, 18);
            this._hasAlphaChannel = true;
            ///
            this.initData(options.data);
            this.setBlurRadius(options.blur, options.radius);
            this.setGradient(options.gradient);
        }
        /**
         * 设置模糊半径
         * @param blur
         * @param radius
         */
        setBlurRadius(blur, radius) {
            this._blur = Cegore.TypeCheck.defaultValue(blur, 15);
            this._radius = Cegore.TypeCheck.defaultValue(radius, 8);
            this._circleImage = this.createCircle();
        }
        /**
         * 设置色阶
         * @param gradient
         */
        setGradient(gradient) {
            this._gradient = Cegore.TypeCheck.defaultValue(gradient, HeatmapImageProvider.DEFAULT_GRADIENT);
            this._colorTable = this.createGradientColorTable(this._gradient);
        }
        /**
         * 初始化数据
         * @param data
         */
        initData(data) {
            this._data = [];
            var rect = new Cegore.Rectangle();
            for (let i = 0; i < data.length; ++i) {
                let o = data[i];
                let v = {
                    x: this.xCoord(o),
                    y: this.yCoord(o),
                    v: this.value(o)
                };
                this._data.push(v);
                rect.merge(v.x, v.y);
            }
            this._rectangle = rect.toCZRectangle();
            this._ready = true;
        }
        /**
         * 给定一个字段列表，获取对象的属性
         * @param o
         * @param fields
         * @param def
         */
        static fieldsValue(o, fields, def) {
            let value = Cegore.TypeCheck.defaultValue(def, 0);
            for (let i = 0; i < fields.length; ++i) {
                let f = fields[i];
                if (!Cegore.TypeCheck.isDefined(f))
                    continue;
                value = o[f];
                if (Cegore.TypeCheck.isDefined(value))
                    break;
            }
            if (!Cegore.TypeCheck.isNumber(value))
                value = Cegore.StringUtil.parseFloat(value);
            return value;
        }
        xCoord(o) {
            return HeatmapImageProvider.fieldsValue(o, [this._xfield, 'x', 'X']);
        }
        yCoord(o) {
            return HeatmapImageProvider.fieldsValue(o, [this._yfield, 'y', 'Y']);
        }
        value(o) {
            if (Cegore.TypeCheck.isFunction(this._weightCalc))
                return this._weightCalc(o);
            else
                return HeatmapImageProvider.fieldsValue(o, [this._weightField, 'value', 'Value', 'VALUE']);
        }
        /**
         * 创建色表变化
         */
        createGradientColorTable(colors) {
            var width = 1;
            var height = 256;
            var context = Cegore.DOM.createContext2D(width, height);
            var gradient = context.createLinearGradient(0, 0, width, height);
            var step = 1 / (colors.length - 1);
            for (var i = 0, ii = colors.length; i < ii; ++i) {
                gradient.addColorStop(i * step, colors[i]);
            }
            context.fillStyle = gradient;
            context.fillRect(0, 0, width, height);
            return context.getImageData(0, 0, width, height).data;
        }
        ;
        /**
         * 创建子图
         */
        createCircle() {
            var radius = this._radius;
            var blur = this._blur;
            var halfSize = radius + blur + 1;
            var size = 2 * halfSize;
            var context = Cegore.DOM.createContext2D(size, size);
            context.shadowOffsetX = context.shadowOffsetY = this._shadow;
            context.shadowBlur = blur;
            context.shadowColor = '#000';
            context.beginPath();
            var center = halfSize - this._shadow;
            context.arc(center, center, radius, 0, Math.PI * 2, true);
            context.fill();
            return context.canvas;
        }
        ;
        /**
         * 请求图像数据
         */
        requestImage(x, y, level) {
            var ctx = Cegore.DOM.createContext2D(this.tileWidth, this.tileHeight);
            var canvas = ctx.canvas;
            var circle = this._circleImage;
            var hw = circle.width / 2;
            var hh = circle.height / 2;
            var pos = new Cegore.Position();
            var rect = new Cegore.Rectangle(this.tilingScheme.tileXYToRectangle(x, y, level));
            var gwidth = rect.width;
            var gheight = rect.height;
            var checkRect = rect.clone();
            checkRect.inflate(rect.width / 2, rect.height / 2);
            for (var i = 0; i < this._data.length; ++i) {
                var o = this._data[i];
                pos.set(o.x, o.y);
                if (!checkRect.contains(pos))
                    continue;
                var ix = (o.x - rect.minx) / gwidth * canvas.width;
                var iy = (rect.maxy - o.y) / gheight * canvas.height;
                ctx.globalAlpha = o.v * this._weightScale;
                ctx.drawImage(circle, ix - hw, iy - hh);
            }
            var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var view8 = image.data;
            var alpha;
            for (var i = 0, ii = view8.length; i < ii; i += 4) {
                alpha = view8[i + 3] * 4;
                if (alpha) {
                    view8[i] = this._colorTable[alpha];
                    view8[i + 1] = this._colorTable[alpha + 1];
                    view8[i + 2] = this._colorTable[alpha + 2];
                }
            }
            ctx.putImageData(image, 0, 0);
            ///
            return canvas;
        }
    }
    HeatmapImageProvider.DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];
    /**
     * 兆图地图影像数据服务 Provider 工厂
     */
    class HeatmapImageProviderFactory {
        createProvider(options) {
            return new HeatmapImageProvider(options);
        }
    }
    /** 注册工厂 */
    Cegore.Providers.ImageProviders.regFactory('Heatmap', new HeatmapImageProviderFactory());
})(Cegore || (Cegore = {}));
/*
 * File of class ZMapModelLoader
 */
var Cegore;
(function (Cegore) {
    class ZMapModelLoader {
        static LoadModel(url, mg, item, options) {
            var offset = new Cegore.Position(options.offset);
            var pos = item.pos.split(',');
            pos[0] = parseFloat(pos[0]) + offset.x;
            pos[1] = parseFloat(pos[1]) + offset.y;
            pos[2] = parseFloat(pos[2]) + offset.z;
            url = url + '/model?style=glb&id=' + encodeURIComponent(item.model);
            var model = new Cegore.GltfModel({
                name: item.name,
                uri: url,
                position: pos,
                minPixelSize: 10
            });
            mg.add(model);
        }
        /**
         * 加载发布的模型数据
         * @param name
         * @param url
         * @param options
         */
        static LoadFromPubModel(name, url, options) {
            var mg = new Cegore.ModelGroup({ name: name });
            Cegore.LoadWithXhr.loadJSON({
                url: url + '/model?filter=detail',
                success: function (data) {
                    for (var i = 0; i < data.items.length; ++i) {
                        ZMapModelLoader.LoadModel(url, mg, data.items[i], options);
                    }
                }
            });
            return mg;
        }
    }
    Cegore.ZMapModelLoader = ZMapModelLoader;
})(Cegore || (Cegore = {}));
/**
 * end of file
 */ 
var CZMAP;
(function (CZMAP) {
    /**
     * Counter for getUid.
     * @type {number}
     * @private
     */
    let _uidCounter = 0;
    /**
     * 获取对象的唯一ID
     *
     * @param {Object} obj 获取唯一ID的对象
     * @return {string} 对象的唯一ID
     * @api
     */
    function getUid(obj) {
        return obj._uid_ || (obj._uid_ = String(++_uidCounter));
    }
    CZMAP.getUid = getUid;
    /**
     * Always returns true.
     * @returns {boolean} true.
     */
    function TRUE() { return true; }
    CZMAP.TRUE = TRUE;
    /**
     * Always returns false.
     * @returns {boolean} false.
     */
    function FALSE() { return false; }
    CZMAP.FALSE = FALSE;
    /**
     * A reusable function, used e.g. as a default for callbacks.
     *
     * @return {void} Nothing.
     */
    function VOID() { }
    CZMAP.VOID = VOID;
    /**
     * 抽象函数
     */
    function abstract(...args) {
        throw new Error('abstract method, not impl!');
    }
    CZMAP.abstract = abstract;
    /**
     * 获取 [start,end)之间的随机整数
     * @param {*} start
     * @param {*} end
     */
    function randomInt(start, end) {
        const count = end - start;
        return start + Math.floor(Math.random() * count);
    }
    CZMAP.randomInt = randomInt;
    /**
     * 获取[start,end)之间的随机数
     * @param {*} start
     * @param {*} end
     */
    function randomFloat(start, end) {
        const count = end - start;
        return start + (Math.random() * count);
    }
    CZMAP.randomFloat = randomFloat;
    /**
     * 深复制
     * @param o 要复制的对象
     * @param t 复制到的对象
     */
    function deepCopy(o, t) {
        if (o === null)
            return o;
        const type = typeof o;
        if (type !== 'object')
            return o;
        function allocArray(t) {
            /// 置空数组
            if (Array.isArray(t)) {
                t.length = 0;
                return t;
            }
            return [];
        }
        function allocObject(t) {
            /// 置空对象
            if (isObject(t)) {
                for (let key in t) {
                    delete t[key];
                }
                return t;
            }
            return {};
        }
        /// 先判断Array
        if (Array.isArray(o)) {
            const atar = allocArray(t);
            for (let i = 0; i < o.length; ++i) {
                atar[i] = deepCopy(o[i], atar[i]);
            }
            return atar;
        }
        else {
            const otar = allocObject(t);
            for (let key in o) {
                otar[key] = deepCopy(o[key], otar[key]);
            }
            return otar;
        }
    }
    CZMAP.deepCopy = deepCopy;
    function asArray(v) {
        if (!CZMAP.defined(v))
            return undefined;
        if (Array.isArray(v)) {
            return v;
        }
        else {
            return [v];
        }
    }
    CZMAP.asArray = asArray;
    function isObject(val) {
        return typeof val === 'function' || (typeof val === 'object' && !Array.isArray(val));
    }
    function isPrimitive(val) {
        return typeof val === 'object' ? val === null : typeof val !== 'function';
    }
    ///
    function deepAssign(target, ...sources) {
        if (target === null || target === undefined) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        const to = Object(target);
        sources.forEach(next => {
            ///
            if (next === null || next === undefined) {
                return;
            }
            for (let nextKey in next) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(next, nextKey)) {
                    const src = next[nextKey];
                    if (!CZMAP.defined(src))
                        continue;
                    const dst = CZMAP.defaultValue(to[nextKey], {});
                    if (isObject(dst) && isObject(src))
                        to[nextKey] = deepAssign(dst, src);
                    else
                        to[nextKey] = src;
                }
            }
        });
        ///
        return to;
    }
    CZMAP.deepAssign = deepAssign;
    /** 版本比较 */
    function compVersion(v1, v2) {
        const v1s = v1.split('.');
        const v2s = v2.split('.');
        const num = Math.max(v1s.length, v2s.length);
        for (let i = 0; i < num; ++i) {
            const s1 = CZMAP.Parse.parseNumber(v1s[i], 0);
            const s2 = CZMAP.Parse.parseNumber(v2s[i], 0);
            if (s1 < s2)
                return -1;
            if (s1 > s2)
                return 1;
        }
        ///
        return 0;
    }
    CZMAP.compVersion = compVersion;
    /**
     * 使用try catch调用函数
     * @param func 函数对象
     * @param args 函数参数
     * @returns
     */
    function tryCatchCall(func, ...args) {
        try {
            if (typeof func === 'function')
                return func.apply(undefined, args);
        }
        catch (ex) {
            console.warn('tryCatchCall:call function exception!', func, ex);
        }
    }
    CZMAP.tryCatchCall = tryCatchCall;
    /**
     * 使用try catch调用函数
     * @param bind_this this
     * @param func 函数对象
     * @param args 函数参数
     * @returns
     */
    function tryCatchCallByThis(bind_this, func, ...args) {
        try {
            if (typeof func === 'function')
                return func.apply(bind_this, args);
        }
        catch (ex) {
            console.warn('tryCatchCall:call function exception!', func, ex);
        }
    }
    CZMAP.tryCatchCallByThis = tryCatchCallByThis;
    /**
     * 依次每前后相邻的两个成员的连续遍历数据
     * @param items 数组对象
     * @param callback 回调函数
     */
    function forEachSegment(items, callback) {
        for (let i = 1; i < items.length; ++i) {
            callback(items[i - 1], items[i], i - 1, i);
        }
    }
    CZMAP.forEachSegment = forEachSegment;
    /**
     * 依次每前后相邻的两个成员的连续调用回调函数，并返回函数结果
     * @param items 数组对象
     * @param callback 回调函数
     */
    function mapEachSegment(items, callback) {
        const result = [];
        for (let i = 1; i < items.length; ++i) {
            result.push(callback(items[i - 1], items[i], i - 1, i));
        }
        return result;
    }
    CZMAP.mapEachSegment = mapEachSegment;
    function makeFirstUpper(str) {
        return str.substr(0, 1).toUpperCase() + str.substr(1);
    }
    /**
     * 转驼峰命名法
     * @param ss 输入参数
     * @returns 如果符合连字符规范，则返回驼峰格式
     */
    function toCamelCase(ss) {
        const parts = ss.split('-');
        if (parts.length == 1)
            return;
        for (let i = 1; i < parts.length; ++i) {
            parts[i] = makeFirstUpper(parts[i]);
        }
        return parts.join('');
    }
    CZMAP.toCamelCase = toCamelCase;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 判断一个变量是否定义
     *
     * @param value 代判断的值
     * @returns 是否定义
     */
    function defined(value) {
        return value !== undefined && value !== null;
    }
    CZMAP.defined = defined;
    /**
     * 返回值或者默认值
     *
     * 判断一个值是否定义，如果定义则，返回这个值，否则返回默认值
     *
     * @param value 待判断的值
     * @param defaultVal 默认值
     */
    function defaultValue(value, defaultVal) {
        if (value !== undefined && value !== null) {
            return value;
        }
        return defaultVal;
    }
    CZMAP.defaultValue = defaultValue;
    /**
     * 从多个输入值中按顺序返回最先定义的值
     * @param vals 待检测的值列表
     * @returns 最先定义的值或者`undefined`
     */
    function defaultValues(...vals) {
        return vals.find(v => defined(v));
    }
    CZMAP.defaultValues = defaultValues;
    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    /**
     * 生成一个随机字符串
     * @param option
     */
    function randomString(option) {
        const codes = [];
        const len = defaultValue(option === null || option === void 0 ? void 0 : option.len, 8);
        for (let i = 0; i < len; ++i) {
            const code = Math.random() * chars.length;
            codes.push(chars[code]);
        }
        let ss = '';
        if (option === null || option === void 0 ? void 0 : option.prefix)
            ss += option.prefix;
        ss += codes.join('');
        if (option === null || option === void 0 ? void 0 : option.postfix)
            ss += option.postfix;
        return ss;
    }
    CZMAP.randomString = randomString;
    /**
     * 类 Types
     *
     * 用于JavaScript 类型检查
     *
     */
    class Types {
        /**
         * 判断一个变量是否为null
         */
        static isNull(value) {
            return value === null;
        }
        /**
         * 这是一个修正的 typeof运算符
         *
         * Undefined 返回 'undefined'
         * null 返回 'null'
         * Boolean 返回 'boolean'
         * Number 返回 'number'
         * String 返回 'string'
         * Symbol 返回 'symbol'
         * 函数   返回  'function'
         * 数组   返回 'array'
         * Object 返回  'object'
         * @param value 带判断类型的值
         * @return 类型名称
         */
        static typeOf(value) {
            ///
            if (Array.isArray(value))
                return 'array';
            ///
            return typeof value;
        }
        /**
         * 判断是否为函数
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个函数，否则false.
         */
        static isFunction(value) {
            return (typeof value === 'function');
        }
        /**
         * 判断是否为函数
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isString(value) {
            return (typeof value === 'string');
        }
        /**
         * 判断是否为数字
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isNumber(value) {
            return (typeof value === 'number') && !Number.isNaN(value);
        }
        /**
         * 判断是否为对象
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isObject(value) {
            return this.typeOf(value) === 'object';
        }
        /**
         * 判断是否为布尔值
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isBool(value) {
            return (typeof value === 'boolean');
        }
        /**
         * 判断是否为数组
         *
         * @param value 要测试的对象
         * @returns 返回true表测试对象是一个字符串对象，否则false.
         */
        static isArray(value) {
            return Array.isArray(value);
        }
        /**
         * 判断是否为某类型
         *
         * @param val
         * @param type
         */
        static isInstanceOf(val, type) {
            return val instanceof type;
        }
    }
    /**
     * @see {defaultValue}
     */
    Types.defaultValue = defaultValue;
    /**
     * @see {defined}
     */
    Types.isDefined = defined;
    CZMAP.Types = Types;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * Disposable
     *
     * @classdesc
     * 用于需要清理的对象
     */
    class Disposable {
        /**
         * 构造函数
         */
        constructor() {
            /**
             * 是否已经丢弃
             */
            this._disposed = false;
        }
        /**
         * 清理
         */
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                this._disposeInternal();
            }
        }
    }
    CZMAP.Disposable = Disposable;
})(CZMAP || (CZMAP = {}));
/// <reference path="Disposable.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 监听对象
     */
    class ListenerObject {
        /**
         * 构造函数
         */
        constructor(target, type, listener, bindto) {
            this.target = target;
            this.type = type;
            this.listener = listener;
            this.bindto = bindto;
        }
    }
    CZMAP.ListenerObject = ListenerObject;
    /**
     * 事件对象
     *
     */
    class EventTarget extends CZMAP.Disposable {
        /**
         * 构造函数
         */
        constructor() {
            super();
            /**
             * 待移除的事件
             * @private
             */
            this._removing = {};
            /**
             * 正在派发的事件
             * @private
             */
            this._dispatching = {};
            /**
             * 事件监听表（回调函数）
             * @private
             */
            this._listeners = {};
        }
        /**
         * 获取指定事件类型的监听对象列表
         *
         * @param {string} type 事件类型
         * @return {Array<function>} 监听对象列表
         */
        getListeners(type) {
            return this._listeners[type];
        }
        /**
         * 是否有指定类型的事件监听器
         *
         * @param {string=} type 事件类型，可以不指定
         * @return {boolean}
         */
        hasListener(type) {
            return type ?
                type in this._listeners :
                Object.keys(this._listeners).length > 0;
        }
        /**
         * 添加事件监听器
         * @param {string} type 事件类型
         * @param {function} listener 事件监听器（回调函数）
         * @param {*} opt_this 可选的this对象
         * @return 返回唯一的监听对象
         */
        addEventListener(type, listener, opt_this) {
            let list = this._listeners[type];
            if (!list) {
                list = this._listeners[type] = [];
            }
            /// 查找监听对象
            const index = this.findListener(list, listener, opt_this);
            if (index != -1)
                return list[index];
            ///
            const lisobj = new ListenerObject(this, type, listener, opt_this);
            ///
            list.push(lisobj);
            return lisobj;
        }
        /**
         * 派发事件
         *
         * 事件参数可以是字符串或者包含type属性的对象
         *
         * @param {{type: string}|Event|string} event 事件对象.
         * @api
         */
        dispatchEvent(event, optData) {
            let propagate;
            ///
            const evt = typeof event === 'string' ? new CZMAP.Event(event) : event;
            const type = evt.type;
            evt.target = this;
            evt.data = optData;
            /// 获取监听列表
            const list = this._listeners[type];
            if (list) {
                /// 构建派发计数
                if (!(type in this._dispatching)) {
                    this._dispatching[type] = 0;
                    this._removing[type] = 0;
                }
                ++this._dispatching[type];
                /// 遍历监听列表
                for (let i = 0, ii = list.length; i < ii; ++i) {
                    const lisobj = list[i];
                    const bindto = lisobj.bindto || lisobj.target;
                    try {
                        if (lisobj.listener.call(bindto, evt) === false || evt.propagationStopped) {
                            propagate = false;
                            break;
                        }
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                /// 
                --this._dispatching[type];
                /// 移除待移除列表中的监听对象
                if (this._dispatching[type] === 0) {
                    let removing = this._removing[type];
                    delete this._removing[type];
                    while (removing--) {
                        this.removeEventListener(type, CZMAP.VOID);
                    }
                    delete this._dispatching[type];
                }
                return propagate;
            }
        }
        /**
         * 移除指定的事件监听器
         * @param {string} type 类型
         * @param {function} listener 监听器（函数）
         */
        removeEventListener(type, listener, opt_this) {
            const list = this._listeners[type];
            if (list) {
                const index = this.findListener(list, listener, opt_this);
                if (index === -1)
                    return; // 找不到泽退出
                if (type in this._removing) {
                    // 标记为一个VOID函数
                    list[index].listener = CZMAP.VOID;
                    ++this._removing[type];
                }
                else {
                    list.splice(index, 1);
                    if (list.length === 0) {
                        delete this._listeners[type];
                    }
                }
            }
        }
        /**
         * 查找事件监听对象
         * @param {*} listener
         * @param {*} opt_this
         */
        findListener(list, listener, opt_this) {
            for (let i = 0; i < list.length; ++i) {
                let it = list[i];
                if (it.listener === listener &&
                    it.bindto === opt_this) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * 移除所有事件监听
         */
        removeAllEventListener() {
            const types = Object.keys(this._listeners);
            for (let type of types) {
                const list = this._listeners[type];
                for (let i = list.length - 1; i >= 0; --i) {
                    let o = list[i];
                    this.removeEventListener(type, o.listener, o.bindto);
                }
            }
        }
        /**
         * @inheritDoc
         * @override
         */
        _disposeInternal() {
            this.removeAllEventListener();
        }
    }
    CZMAP.EventTarget = EventTarget;
})(CZMAP || (CZMAP = {}));
/// <reference path="EventTarget.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 事件
     *
     */
    class Event {
        /**
         * @param {string} type 类型.
         */
        constructor(type) {
            /**
             * 事件的目标
             * @api
             */
            this.target = null;
            this.type = type;
        }
        /**
         * 停止事件传递
         * @api
         */
        preventDefault() {
            this.propagationStopped = true;
        }
        /**
         * 停止事件传递
         * @api
         */
        stopPropagation() {
            this.propagationStopped = true;
        }
    }
    CZMAP.Event = Event;
})(CZMAP || (CZMAP = {}));
/// <reference path="EventTarget.ts" />
var CZMAP;
(function (CZMAP) {
    class ObservableEvents {
    }
    /**
     * ‘改变’事件
     */
    ObservableEvents.CHANGE = 'change';
    CZMAP.ObservableEvents = ObservableEvents;
    /**
     * @classdesc
     *
     * @fires
     * @api
     */
    class Observable extends CZMAP.EventTarget {
        /**
         * 构造函数
         */
        constructor() {
            super();
            /**
             * @private
             */
            this._revision = 0;
        }
        /**
         * 增加版本号并派发 'change' 事件
         * @api
         */
        changed() {
            ++this._revision;
            this.dispatchEvent(ObservableEvents.CHANGE);
        }
        /**
         * 获取当前对象的版本号，当对象修改后将版本号将增加
         * @return {number} Revision.
         * @api
         */
        getRevision() {
            return this._revision;
        }
        on(type, listener, opt_this) {
            if (Array.isArray(type)) {
                const len = type.length;
                const keys = new Array(len);
                for (let i = 0; i < len; ++i) {
                    keys[i] = listen(this, type[i], listener, opt_this);
                }
                return keys;
            }
            else {
                return listen(this, type, listener, opt_this);
            }
        }
        /**
         * 取消监听指定类型的事件
         * @param {string|Array<string>} type 事件类型或者类型数组
         * @param {function(?): ?} listener 监听函数
         * @api
         */
        un(type, listener, opt_this) {
            if (Array.isArray(type)) {
                for (let i = 0, ii = type.length; i < ii; ++i) {
                    unlisten(this, type[i], listener, opt_this);
                }
                return;
            }
            else {
                unlisten(this, type, listener, opt_this);
            }
        }
        /**
         * 通过指定的key取消监听
         * @param {Object} key 函数`on()`的返回值
         */
        static unByKey(key) {
            if (Array.isArray(key)) {
                for (let i = 0, ii = key.length; i < ii; ++i) {
                    unlistenByKey(key[i]);
                }
            }
            else {
                unlistenByKey(key);
            }
        }
    }
    CZMAP.Observable = Observable;
    function listen(target, type, listener, opt_this) {
        return target.addEventListener(type, listener, opt_this);
    }
    function unlisten(target, type, listener, opt_this) {
        target.removeEventListener(type, listener, opt_this);
    }
    function unlistenByKey(key) {
        if (key instanceof CZMAP.ListenerObject) {
            key.target.removeEventListener(key.type, key.listener, key.bindto);
        }
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="../utils/util.ts" />
/// <reference path="../utils/Types.ts" />
/// <reference path="Event.ts" />
/// <reference path="EventTarget.ts" />
/// <reference path="Observable.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * @classdesc
     */
    class ObjectEvent extends CZMAP.Event {
        /**
         * @param {string} type 事件类型.
         * @param {string} key 属性名称.
         * @param {*} oldValue 旧的属性值 `key`.
         */
        constructor(type, key, oldValue) {
            super(type);
            /**
             * 属性名称
             * @api
             */
            this.key = key;
            /**
             * 改变前的值，获取新的值通过 `e.target.get(e.key)` 获取
             * @api
             */
            this.oldValue = oldValue;
        }
    }
    CZMAP.ObjectEvent = ObjectEvent;
    /**
     * 对象属性
     */
    class ObjectProperty {
        /**
         * 构造一个新的属性
         * @param name 属性的名称
         */
        constructor(name) {
            /**
             * 值
             */
            this.value = undefined;
            /**
             * 默认值
             */
            this.default = undefined;
            /**
             * 自定的的检查函数
             */
            this.check = undefined;
            /**
             * 比较函数
             */
            this.equals = undefined;
            /**
             * 属性名称
             */
            this.name = name;
        }
        /**
         * 检查数据格式
         * @param {*} v
         */
        doCheck(v) {
            return this.check ? this.check(v) : v;
        }
        /**
         * 判断数值是否相同
         * @param {*} v1
         * @param {*} v2
         */
        isEquals(v1, v2) {
            return this.equals ? this.equals(v1, v2) : Object.is(v1, v2);
        }
    }
    class BaseObjectProperty {
    }
    CZMAP.BaseObjectProperty = BaseObjectProperty;
    class BaseObjectEvents extends CZMAP.ObservableEvents {
    }
    /**
     * 属性变化事件
     */
    BaseObjectEvents.PROPERTYCHANGE = 'propertychange';
    CZMAP.BaseObjectEvents = BaseObjectEvents;
    /**
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Most non-trivial classes inherit from this.
     *
     * @fires ObjectEvent
     * @api
     */
    class BaseObject extends CZMAP.Observable {
        /**
         * 构造函数
         * @param values An object with key-value pairs.
         */
        constructor(values) {
            super();
            /**
             * @private
             */
            this._values = new Map();
            /// 获取对象的唯一ID
            CZMAP.getUid(this);
            /// 
            this._initDefines();
            /// 
            if (CZMAP.Types.isDefined(values)) {
                this.setProperties(values);
            }
        }
        /**
         * 定义属性
         * @param {String} key 属性名称
         * @param {*} def 属性默认值
         * @param {Function=} check 属性检查函数
         */
        def(key, def, check, equals) {
            const prop = this._getProperty(key, true);
            prop.value = def;
            prop.default = def;
            ///
            if (CZMAP.Types.isFunction(equals))
                prop.equals = equals;
            if (CZMAP.Types.isFunction(check))
                prop.check = check;
        }
        /**
         * 获取属性值
         * @param {string} key 属性名称
         * @return {*} 属性值
         * @api
         */
        get(key) {
            return this._getProperty(key, false).value;
        }
        /**
         * 获取属性名称列表
         * @return {Array<string>} 属性名称列表
         * @api
         */
        getKeys() {
            return [...this._values.keys()];
        }
        /**
         * 获取所有的属性名称和值
         * @return {Object<string, *>} 所有的属性名称和值
         * @api
         */
        getProperties() {
            const props = {};
            for (let [k, v] of this._values) {
                props[k] = CZMAP.defaultValue(v.value, v.default);
            }
            return props;
        }
        /**
         * @param {string} key Key name.
         * @param {*} oldValue Old value.
         */
        notify(key, oldValue, optData) {
            let eventType;
            /// change:key 事件
            eventType = BaseObject.getChangeEventType(key);
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue), optData);
            /// PROPERTYCHANGE 事件
            eventType = BaseObjectEvents.PROPERTYCHANGE;
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue), optData);
            /// CHANGE 事件
            this.changed();
        }
        /** 通知当前属性 */
        notifyCurrent(key) {
            this.notify(key, this.get(key));
        }
        /**
         * 通知所有属性
         */
        notifyAll() {
            const keys = this.getKeys();
            keys.forEach(k => {
                const value = this.get(k);
                if (CZMAP.Types.isDefined(value))
                    this.notify(k, value);
            });
        }
        /**
         * 设置属性值
         * @param {string} key 属性名称
         * @param {*} value 属性值
         * @param {boolean=} opt_silent 不派发事件
         * @api
         */
        set(key, value, opt_silent, opt_data) {
            const prop = this._getProperty(key, true);
            if (CZMAP.Types.isDefined(value))
                value = prop.doCheck(value);
            else
                value = prop.default;
            /// 
            if (opt_silent) {
                prop.value = value;
            }
            else {
                const oldValue = prop.value;
                prop.value = value;
                /// 判断是否相同，不同触发通知事件
                if (!prop.isEquals(oldValue, value)) {
                    this.notify(key, oldValue, opt_data);
                }
            }
        }
        /**
         * 设置一组属性，旧的属性不会被移除
         * @param {Object<string, *>} values 多个属性
         * @param {boolean=} opt_silent 不派发事件
         * @api
         */
        setProperties(values, opt_silent) {
            for (const key in values) {
                this.set(key, values[key], opt_silent);
            }
        }
        /**
         * 删除一个属性
         * @param {string} key 属性名称
         * @param {boolean=} opt_silent 不派发事件
         * @api
         */
        unset(key, opt_silent) {
            if (this._values.has(key)) {
                const oldValue = this._values.get(key);
                this._values.delete(key);
                if (!opt_silent) {
                    this.notify(key, oldValue);
                }
            }
        }
        /**
         * 监听指定属性的changed事件
         * @param {string} key 属性名称
         * @param {BaseObjectEventListener} listener 监听函数
         * @param {object} opt_this 可选的this对象
         * @return 当前监听键（Key），如果第一个参数是数组，则返回数组
         * @api
         */
        onProperty(key, listener, opt_this) {
            return this.on(BaseObject.getChangeEventType(key), listener, opt_this);
        }
        /**
         * 取消监听指定属性的changed事件
         * @param {string} key 属性名称
         * @param {BaseObjectEventListener} listener 监听函数
         * @param {*} opt_this 可选的this对象
         * @api
         */
        unProperty(key, listener, opt_this) {
            return this.un(BaseObject.getChangeEventType(key), listener, opt_this);
        }
        /**
         * 监听所有属性的changed事件
         * @param listener
         * @param opt_this
         * @returns
         */
        onAllProperty(listener, opt_this) {
            return this.on(BaseObjectEvents.PROPERTYCHANGE, listener, opt_this);
        }
        /**
         * 取消监听所有属性的changed事件
         * @param listener
         * @param opt_this
         * @returns
         */
        unAllProperty(listener, opt_this) {
            return this.un(BaseObjectEvents.PROPERTYCHANGE, listener, opt_this);
        }
        /**
         * @param {string} key Key name.
         * @return {string} Change name.
         */
        static getChangeEventType(key) {
            let cache = changeEventTypeCache;
            return cache.hasOwnProperty(key) ? cache[key] : (cache[key] = 'change:' + key);
        }
        /**
         *
         * @param {BaseObject} o
         * @param {*} key
         * @param {*} create
         * @return {ObjectProperty}
         */
        _getProperty(key, create) {
            let prop;
            if (this._values.has(key))
                prop = this._values.get(key);
            else if (create) {
                prop = new ObjectProperty(key);
                this._values.set(key, prop);
            }
            else
                prop = EmptyProperty;
            return prop;
        }
        /** 初始化定义项 */
        _initDefines() {
        }
    }
    CZMAP.BaseObject = BaseObject;
    const EmptyProperty = new ObjectProperty('EMPTY');
    const changeEventTypeCache = {};
})(CZMAP || (CZMAP = {}));
/// <reference path="../base/BaseObject.ts" />
var CZMAP;
(function (CZMAP) {
    let nextViewID = 0;
    /**
     * 地图类
     */
    class ComMap extends CZMAP.BaseObject {
        ///
        constructor(mode, dom, options) {
            super();
            this._view = null;
            this._projection = 'EPSG:4326';
            ///
            this._enableTip = false;
            this._dynData = new CZMAP.DynamicData();
            ///
            this._mode = mode;
            this._options = CZMAP.Types.defaultValue(options, {});
            ///
            if (CZMAP.Types.isString(dom))
                this._mapDOM = document.getElementById(dom);
            else
                this._mapDOM = dom;
            //
            this._mapID = this._mapDOM.id;
            ///
            if (!CZMAP.Types.isDefined(this._mapDOM))
                throw new Error("dom is empty.");
            //
            const viewIndex = nextViewID++;
            this._viewID = this._mapDOM.id + '-mapview-' + viewIndex;
            this._projection = CZMAP.Types.defaultValue(this._options.projection, "EPSG:4326");
            /// 
            this._createMapView(mode);
            ///
            this._overlayRoot = this._createDOM('czmap-overlayRoot-' + viewIndex, 'map-overlayRoot', true);
        }
        get mapID() { return this._mapID; }
        get mapDOM() { return this._mapDOM; }
        get viewID() { return this._viewID; }
        get viewDOM() { return this._viewDOM; }
        get overlayRoot() { return this._overlayRoot; }
        /** 获取根图层 */
        get rootLayer() { return this._view.layerManager; }
        /**
         * 获取图层管理器
         * @deprecated
         * @see ComMap.rootLayer
         */
        get layers() { return this.rootLayer; }
        /** 获取投影系 */
        get projection() { return this._projection; }
        /** 获取当前的显示模式 */
        get mode() { return this._mode; }
        /** 获取视图类 */
        get view() { return this._view; }
        /** 获取二维视图 */
        get view2d() { return this._view instanceof CZMAP.MapView2D ? this._view : undefined; }
        /** 获取三维视图 */
        get view3d() { return this._view instanceof CZMAP.MapView3D ? this._view : undefined; }
        /**
         * 缩放到指定范围
         * @param {*} extent
         */
        zoomTo(extent) { return this._view.zoomTo(extent); }
        /**
         * 飞行到指定范围
         * @param {*} extent
         */
        flyTo(extent) { return this._view.flyTo(extent); }
        /**
         * 创建路径漫游工具
         * @param {Array} path
         */
        createPathRoam() { return this._view.createPathRoam(); }
        /**
         * 测量距离
         */
        measureDistance(option) { return this._view.measureDistance(option); }
        /**
         * 测量面积
         */
        measureArae(option) { return this._view.measureArae(option); }
        /**
         * 清除测量
         */
        measureClear() { return this._view.measureClear(); }
        /**
         * 获取是否启用tip（提示事件）
         */
        get enableTip() { return this._enableTip; }
        /**
         * 设置启动鼠标提示事件
         */
        set enableTip(enable) {
            if (this._enableTip != enable) {
                this._enableTip = enable;
            }
        }
        /**
         * 设置鼠标tip事件
         * @param {*} callback
         * @param {*} opt_this
         */
        setOnTip(callback, opt_this) {
            this.view.events.on(CZMAP.MapEventsType.MOUSE_OVER, callback, opt_this);
            this.view.events.on(CZMAP.MapEventsType.MOUSE_OUT, callback, opt_this);
        }
        /**
         * 设置点击事件
         * @param callback
         * @param opt_this
         */
        setOnClick(callback, opt_this) {
            this.view.events.on(CZMAP.MapEventsType.MOUSE_CLICK, callback, opt_this);
        }
        /**
         * 获取动态数据支持
         */
        get dynamiceDate() { return this._dynData; }
        /** 获取根元素 */
        get containerElement() { return this._mapDOM; }
        /** 创建底图视图对象 */
        _createMapView(mode) {
            this._viewDOM = this._createDOM(this._viewID, 'map-mapview');
            switch (mode) {
                case CZMAP.MapMode.Mode2D:
                    this._view = new CZMAP.MapView2D(this, this._viewID);
                    break;
                case CZMAP.MapMode.Mode3D:
                    this._view = new CZMAP.MapView3D(this, this._viewID, this._options);
                    break;
                case CZMAP.MapMode.ModeCloud:
                    this._view = new CZMAP.MapViewUE(this, this._viewID, this._options);
                    break;
            }
        }
        _createDOM(id, domClass, noSize) {
            let div = document.createElement('div');
            div.id = id;
            div.className = domClass;
            ///
            if (!noSize) {
                div.style.width = '100%';
                div.style.height = '100%';
            }
            //
            div.style.overflow = 'hidden';
            this._mapDOM.append(div);
            return div;
        }
        /** 销毁 */
        destroy() {
            this._dynData.unRegAll();
            ///
            this._view.dispose();
        }
        _disposeInternal() {
            super._disposeInternal();
            this.destroy();
        }
    }
    CZMAP.ComMap = ComMap;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 投影变换支持
     */
    class Projection {
        /**
         * 定义投影系
         */
        static defs(...defs) {
            proj4.defs.apply(null, defs);
        }
    }
    CZMAP.Projection = Projection;
    CZMAP.Proj = Projection;
})(CZMAP || (CZMAP = {}));
/// <reference path="map/ComMap.ts" />
/// <reference path="proj/Projection.ts" />
var CZMAP;
(function (CZMAP) {
    ///
    window.CZMAP['Map'] = CZMAP.ComMap;
    CZMAP.urlSearchs = new URLSearchParams(location.search);
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class DynamicStyle {
        /**
         *
         * @param {VectorLayer} fc
         * @param {*} options
         */
        constructor(map, fc, layerdef, options) {
            this.map = map;
            this.layer = fc;
            this.layerdef = layerdef;
            this.url = CZMAP.Types.defaultValue(options.url, layerdef.url);
            this.originkey = CZMAP.Types.defaultValue(options.originkey, 'id');
            this.dynamicekey = CZMAP.Types.defaultValue(options.dynamicekey, 'id');
            this.interval = CZMAP.Types.defaultValue(options.interval, 10000);
            this.handle = (e) => { this.update(e); };
        }
        /**
         * 动态更新数据
         * @param data
         */
        update(data) {
            const source = this.layer.source;
            const vf = source.getFormat();
            /// 当前存在的要素
            const feas0 = this.layer.children.slice();
            /// 读取到的要素
            const feas = vf.readFeatures(data);
            ///
            feas.forEach(f => {
                /// 新数据的ID
                const id = f.properties[this.dynamicekey];
                /// 新数据不存在ID，则跳过
                if (!CZMAP.Types.isDefined(id))
                    return;
                /// 查找对应的要素图层
                const find = feas0.findIndex(e => {
                    if (e === null)
                        return false;
                    ///
                    return e.properties[this.originkey] === id;
                });
                /// 未找到，新增数据
                if (find == -1) {
                    source.addFeature(f);
                }
                /// 找到，更新数据
                else {
                    ///
                    const e = feas0[find];
                    const merge = Object.assign({}, e.properties, f.properties);
                    /// 
                    if (f.properties)
                        e.feature.properties = merge;
                    if (f.geometry)
                        e.feature.geometry = f.geometry;
                    /// 
                    e.style.update(this.layerdef.style, merge, true);
                    /// 标记已更新
                    feas0[find] = null;
                }
            });
            /// 待删除的
            feas0.forEach(f0 => {
                if (f0) {
                    this.layer.removeLayer(f0);
                }
            });
        }
        reg() {
            this.map.dynamiceDate.reg(this.url, this.handle, CZMAP.DynamicDataType.JSON, this.interval);
        }
        unreg() {
            this.map.dynamiceDate.unReg(this.url, this.handle, CZMAP.DynamicDataType.JSON, this.interval);
        }
    }
    CZMAP.DynamicStyle = DynamicStyle;
})(CZMAP || (CZMAP = {}));
/// <reference path="DynamicStyle.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 地图加载器
     */
    class MapLoader {
        /**
         * 加载多个图层
         * @param cmap
         * @param layers
         */
        static loadMapLayers(cmap, layers) {
            if (CZMAP.Types.isArray(layers)) {
                return layers.map((ld) => this.loadLayer(cmap.rootLayer, ld));
            }
            else {
                return this.loadLayer(cmap.rootLayer, layers);
            }
        }
        /**
         * 加载一个图层
         * @param parent
         * @param layerdef
         */
        static loadLayer(parent, layerdef) {
            let layer;
            switch (layerdef.type.toLowerCase()) {
                case 'folder':
                    layer = this.loadFolder(parent, layerdef);
                    break;
                case 'terrain':
                    layer = this.loadTerrain(parent, layerdef);
                    break;
                case 'tile':
                case 'map':
                    layer = this.loadTileLayer(parent, layerdef);
                    break;
                case 'vector':
                case 'point':
                    layer = this.loadVectorLayer(parent, layerdef);
                    break;
                case 'model':
                    layer = this.loadModelLayer(parent, layerdef);
                    break;
                case 'volume':
                    layer = this.loadVolumeLayer(parent, layerdef);
                    break;
                case '3dtiles':
                    layer = this.loadTdtilesLayer(parent, layerdef);
                    break;
                default:
                    layer = this.loadLayerOther(parent, layerdef);
                    break;
            }
            /// 
            return layer;
        }
        static loadFolder(parent, layerdef) {
            const fo = {
                name: layerdef.name,
                visible: layerdef.visible,
                define: layerdef
            };
            const folder = parent.createLayer(CZMAP.Folder, fo);
            if (CZMAP.Types.isArray(layerdef.children))
                layerdef.children.forEach(child => this.loadLayer(folder, child));
            ///
            return folder;
        }
        static loadTerrain(parent, layerdef) {
            const to = {
                name: layerdef.name,
                visible: layerdef.visible,
                url: layerdef.url,
                define: layerdef
            };
            ///
            return parent.createLayer('terrain', to);
        }
        static loadTileLayer(parent, layerdef) {
            layerdef.style = layerdef.style || {};
            const to = {
                name: layerdef.name,
                visible: layerdef.visible,
                define: layerdef,
                url: layerdef.url,
                scheme: layerdef.style.scheme,
                mapType: layerdef.style["map-type"],
                minLevel: layerdef.style["min-level"],
                maxLevel: layerdef.style["max-level"],
                subdomains: layerdef.style.subdomains
            };
            ///
            return parent.createLayer('tile', to);
        }
        static loadFormatter(define) {
            define = Object.assign({ type: "table" }, define);
            switch (define.type) {
                case "table":
                    return new CZMAP.TableDataFormat(define);
                case "geojson":
                    return new CZMAP.GeoJSONFormat(define);
                default:
                    return new CZMAP.TableDataFormat(define);
            }
        }
        static loadVectorLayer(parent, layerdef) {
            const fmt = MapLoader.loadFormatter(layerdef.formatter);
            const so = {
                format: fmt
            };
            if (CZMAP.StringUtils.isNotEmpty(layerdef.url)) {
                so.url = layerdef.url;
            }
            else if (CZMAP.Types.isDefined(layerdef.data)) {
                so.features = fmt.readFeatures(layerdef.data);
                so.projection = fmt.readProjection(layerdef.data);
            }
            function createFeatureStyle(feature, resolution, opt_style) {
                const style = new CZMAP.FeatureStyle();
                style.update(layerdef.style, feature.properties, false);
                ///
                return style;
            }
            ///
            const src = new CZMAP.VectorSource(so);
            const fo = {
                name: layerdef.name, visible: layerdef.visible,
                source: src, style: createFeatureStyle,
                enableCluster: layerdef.enableCluster,
                multiLevelCluster: layerdef.multiLevelCluster,
                pointAnimation: layerdef.pointAnimation,
                enableAnimation: layerdef.enableAnimation,
                animationTimes: layerdef.animationTimes,
                maxAnimationDistance: layerdef.maxAnimationDistance,
                define: layerdef
            };
            if (layerdef.refLine) {
                const lop = layerdef.refLine;
                fo.referenceLine = new CZMAP.NearestPointInLine({ url: lop.url, data: lop.data, radius: lop.radius });
            }
            ///
            const vector = parent.createLayer('vector', fo);
            /// 
            if (layerdef.dynamic) {
                const dyn = new CZMAP.DynamicStyle(parent.map, vector, layerdef, layerdef.dynamic);
                dyn.reg();
                vector.set('dynamic', dyn);
            }
            ///
            return vector;
        }
        static loadModelLayer(parent, layerdef) {
            let mregeRegex = '';
            const style = layerdef.style || {};
            if (style.merge) {
                if (style.merge === 'byname')
                    mregeRegex = '.+';
                else if (style.merge === 'byprefix')
                    mregeRegex = '.+';
            }
            let labelStyle = undefined;
            if (style.label) {
                const label = {};
                Object.keys(style.label).forEach(key => {
                    const ckey = CZMAP.toCamelCase(key);
                    if (ckey)
                        label[ckey] = style.label[key];
                    else
                        label[key] = style.label[key];
                });
                labelStyle = new CZMAP.LabelStyle(label);
            }
            const mo = {
                url: layerdef.url,
                name: layerdef.name,
                visible: layerdef.visible,
                define: layerdef,
                position: layerdef.position,
                offset: layerdef.offset,
                pose: layerdef.pose,
                scale: layerdef.scale,
                flat: style.flat,
                label: labelStyle,
                enableCluster: layerdef.enableCluster,
                expandChild: style.expand,
                expandChildTree: style.expandTree,
                expandLeafChild: style.expandLeaf,
                mergeChild: style.merge === 'byprefix' ? MregeByPrefix : MregeByName
            };
            ///
            return parent.createLayer('model', mo);
        }
        static loadVolumeLayer(parent, layerdef) {
            return parent.createLayer('volume', layerdef);
        }
        static loadTdtilesLayer(parent, layerdef) {
            return parent.createLayer('3dtiles', layerdef);
        }
        static loadLayerOther(parent, layerdef) {
            return parent.createLayer(layerdef.type, layerdef);
        }
    }
    CZMAP.MapLoader = MapLoader;
    function MregeByName(names) {
        let ct;
        const rt = [];
        for (let i = 0; i < names.length; ++i) {
            const n = names[i];
            if (ct && n === ct.name) {
                ct.index.push(i);
            }
            else {
                ct = null;
            }
            if (!ct) {
                ct = rt[rt.length] = {};
                ct.name = n;
                ct.index = [i];
                continue;
            }
        }
        ///
        return rt;
    }
    function MregeByPrefix(names) {
        let ct;
        const rt = [];
        for (let i = 0; i < names.length; ++i) {
            let n = names[i];
            const pos = n.lastIndexOf('-');
            n = n.substr(0, pos);
            if (ct && n === ct.name) {
                ct.index.push(i);
            }
            else {
                ct = null;
            }
            if (!ct) {
                ct = rt[rt.length] = {};
                ct.name = n;
                ct.index = [i];
                continue;
            }
        }
        ///
        return rt;
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="apps/MapLoader.ts" />
/// <reference path="apps/DynamicStyle.ts" />
var CZMAPAPP;
(function (CZMAPAPP) {
    CZMAPAPP.MapLoader = CZMAP.MapLoader;
    CZMAPAPP.DynamicStyle = CZMAP.DynamicStyle;
})(CZMAPAPP || (CZMAPAPP = {}));
//declare var Cesium:any;
//declare var Cegore:any;
/// <reference path="CZMAP.ts" />
/// <reference path="CZMAPAPP.ts" />
var CZMAP;
(function (CZMAP) {
    let nextActionID = 0;
    class Action {
        constructor(view, option) {
            this.id = nextActionID++;
            this._view = view;
            if (view instanceof CZMAP.MapView3D)
                this._czviewer = view.czviewer;
        }
        get view() { return this._view; }
        get czviewer() { return this._czviewer; }
        /** 初始化 */
        init() {
            return Promise.resolve();
        }
        /** 销毁 */
        destroy() { }
        cancelFlight() {
            if (this._czviewer)
                this._czviewer.camera.cancelFlight();
            else
                this.view.setViewInfo(this.view.getViewInfo());
        }
    }
    CZMAP.Action = Action;
    let nextLoopID = 0;
    class Loop {
        constructor(option) {
            this.id = nextLoopID++;
            ///
            this.duration = 2;
            this.skip = 0;
            this.handle = 0;
            this.skipNum = 0;
            this.currentTime = 0;
            if (option) {
                this.duration = CZMAP.defaultValue(option.duration, 2);
                this.skip = CZMAP.defaultValue(option.skip, 0);
                this.callback = option.callback;
                this.finish = option.finish;
            }
        }
        start(start) {
            if (start)
                this.currentTime = start;
            this.lastTime = undefined;
            this.requestNext();
        }
        pause() {
            this.cancelNext();
        }
        stop() {
            if (this.finish)
                this.finish();
            ///
            this.cancelNext();
        }
        loop(now) {
            now = new Date().getTime();
            if (this.lastTime === undefined) {
                this.lastTime = now;
            }
            ///
            const deltaTime = now - this.lastTime;
            this.currentTime += now - this.lastTime;
            this.lastTime = now;
            ///
            if (this.currentTime > this.duration) {
                if (this.callback)
                    this.callback(1, this.duration, deltaTime);
                if (this.finish)
                    this.finish();
                return;
            }
            if (this.skipNum >= this.skip) {
                ///
                const percent = this.currentTime / this.duration;
                if (this.callback)
                    this.callback(percent, this.currentTime, deltaTime);
                this.skipNum = 0;
            }
            ///
            this.skipNum++;
            ///
            this.requestNext();
        }
        requestNext() {
            this.handle = requestAnimationFrame((now) => this.loop(now));
        }
        cancelNext() {
            if (this.handle) {
                cancelAnimationFrame(this.handle);
                this.handle = 0;
            }
        }
    }
    CZMAP.Loop = Loop;
})(CZMAP || (CZMAP = {}));
/// <reference path="Action.ts" />
var CZMAP;
(function (CZMAP) {
    const TimeRegex = /([0-9]+):([0-9]+)/;
    function parseTime(time) {
        if (typeof time === 'number')
            return time;
        if (typeof time === 'string') {
            if (TimeRegex.test(time)) {
                const min = RegExp.$1;
                const sec = RegExp.$2;
                return Number.parseInt(min) * 60 + Number.parseInt(sec);
            }
        }
        throw new Error('错误的时间格式!');
    }
    class ActionGroup {
        constructor(view, option) {
            this._start = parseTime(option.start);
            this._end = parseTime(option.end);
            /// 
            let actions = option.actions;
            if (!Array.isArray(actions)) {
                actions = [option];
            }
            this._actions = actions.map(act => CZMAP.createAction(view, act));
        }
        ///
        get begin() { return this._start; }
        get end() { return this._end; }
        get duration() { return this._end - this._start; }
        /// 
        get actions() { return this._actions; }
        /** 开始 */
        start() {
            this.actions.forEach(act => act.start());
        }
        pause() {
            this.actions.forEach(act => act.pause());
        }
        /** 结束 */
        finish() {
            this.actions.forEach(act => act.finish());
        }
        /// 
        destroy() {
            this.actions.forEach(act => act.destroy());
            this.actions.length = 0;
        }
    }
    CZMAP.ActionGroup = ActionGroup;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 音频播放器。基于AudioContext
     */
    class AudioPlayer extends globalThis.EventTarget {
        constructor() {
            super();
            this._onEndListener = (e) => this._onended(e);
            /** 循环 */
            this._loop = false;
            /** 音量 */
            this._volume = 1;
            /** 播放开始的时间 */
            this._startTime = 0;
            /** 播放偏移 */
            this._offsetTime = 0;
            /** 暂停的位置 */
            this._pauseTime = 0;
        }
        /** 媒体时长 */
        get duration() {
            return this._buffer ? this._buffer.duration : 0;
        }
        /** 是否暂停 */
        get paused() {
            return this._sourceNode === undefined;
        }
        /** 音量 */
        get volume() {
            return this._volume;
        }
        /** 音量 */
        set volume(val) {
            this._volume = val;
            if (this._gainNode)
                this._gainNode.gain.value = val;
        }
        /** 当前播放的时间 */
        get currentTime() {
            if (!this._context)
                return 0;
            if (this.paused)
                return this._pauseTime;
            ///
            const duration = this.duration;
            const current = this._context.currentTime - this._startTime + this._offsetTime;
            if (current < duration) {
                return current;
            }
            else if (this._loop) {
                return current % duration;
            }
            else {
                return duration;
            }
        }
        set currentTime(val) {
            if (this.paused) {
                this._pauseTime = val;
            }
            else {
                this.play(val);
            }
        }
        /** 循环播放 */
        set loop(val) {
            this._loop = val;
            if (this._sourceNode)
                this._sourceNode.loop = val;
        }
        get loop() { return this._loop; }
        /** 打开音频数据并解码 */
        async open(src) {
            this.pause();
            const resp = await fetch(src);
            const buffer = await resp.arrayBuffer();
            ///
            return this.openBuffer(buffer);
        }
        /** 打开音频数据并解码 */
        async openBuffer(buffer) {
            if (!this._context)
                this._context = new AudioContext();
            ///
            this._buffer = await this._context.decodeAudioData(buffer);
        }
        /** 开始播放 */
        play(start) {
            const paused = this.paused;
            if (!paused) {
                this._stop();
            }
            ///
            this._start(start);
            ///
            if (paused)
                this._fire('play');
        }
        /** 暂停播放 */
        pause() {
            this._pauseTime = this.currentTime;
            this._stop();
            this._fire('pause');
        }
        /** 恢复播放 */
        resume() {
            this.play(this._pauseTime);
        }
        addEventListener(type, listener, options) {
            super.addEventListener(type, listener, options);
        }
        removeEventListener(type, listener, options) {
            super.removeEventListener(type, listener, options);
        }
        /** 开始播放 */
        _start(start) {
            if (!this._buffer)
                return new Error('not open!');
            ///
            if (start === undefined)
                start = this._pauseTime;
            if (start >= this.duration)
                start = 0;
            ///
            this._sourceNode = this._context.createBufferSource();
            this._sourceNode.buffer = this._buffer;
            this._sourceNode.loop = this._loop;
            this._sourceNode.addEventListener('ended', this._onEndListener);
            this._gainNode = this._context.createGain();
            this._gainNode.gain.value = this._volume;
            ///
            this._sourceNode.connect(this._gainNode);
            this._gainNode.connect(this._context.destination);
            ///
            this._sourceNode.start(0, start);
            this._startTime = this._context.currentTime;
            this._offsetTime = start || 0;
        }
        /** 停止播放 */
        _stop() {
            if (this._sourceNode) {
                this._sourceNode.removeEventListener('ended', this._onEndListener);
                this._sourceNode.stop();
                this._sourceNode.disconnect();
                this._sourceNode = undefined;
            }
            if (this._gainNode) {
                this._gainNode.disconnect();
                this._gainNode = undefined;
            }
        }
        _onended(e) {
            this._pauseTime = this.currentTime;
            this._fire('ended');
            if (this._sourceNode) {
                this._sourceNode.disconnect();
                this._sourceNode = undefined;
            }
            if (this._gainNode) {
                this._gainNode.disconnect();
                this._gainNode = undefined;
            }
        }
        _fire(event) {
            this.dispatchEvent(new globalThis.Event(event));
        }
    }
    CZMAP.AudioPlayer = AudioPlayer;
})(CZMAP || (CZMAP = {}));
/// <reference path="Action.ts" />
/// <reference path="AudioPlayer.ts" />
var CZMAP;
(function (CZMAP) {
    class ActionPlayer {
        constructor(view) {
            this._groups = [];
            this._loopHandle = 0;
            this._current = 0;
            this._paused = true;
            this._currents = new Map();
            this._audioPlayer = new CZMAP.AudioPlayer();
            this._inited = false;
            this._view = view;
            this._ready = new Promise(resolve => {
                this._readyResolve = resolve;
            });
        }
        get duration() {
            return this._audioPlayer.duration;
        }
        get current() { return this._current; }
        set current(val) {
            this._current = val;
            this._audioPlayer.currentTime = val;
        }
        get paused() { return this._paused; }
        get ready() { return this._ready; }
        init(option) {
            ///
            if (this._inited)
                return this._ready;
            ///
            this._inited = true;
            const readys = [];
            option.groups.forEach(g => {
                const group = new CZMAP.ActionGroup(this._view, g);
                group.actions.forEach(act => {
                    readys.push(act.init());
                });
                this._groups.push(group);
            });
            ///
            readys.push(this._audioPlayer.open(option.audio));
            ///
            Promise.all(readys).then(this._readyResolve);
            ///
            return this._ready;
        }
        /** 播放 */
        play(start) {
            this._paused = false;
            if (!this._loopHandle) {
                this._run();
            }
            if (start !== undefined)
                this._current = start;
            ///
            for (let act of this._currents.values()) {
                act.start();
            }
            this._audioPlayer.play(start);
        }
        /** 暂停 */
        pause() {
            this._paused = true;
            this._audioPlayer.pause();
            for (let act of this._currents.values()) {
                act.pause();
            }
        }
        /** 切换状态 */
        togger() {
            if (this.paused)
                this.play();
            else
                this.pause();
        }
        /** 销毁对象，释放资源 */
        destroy() {
            if (this._loopHandle) {
                cancelAnimationFrame(this._loopHandle);
                this._loopHandle = 0;
            }
            this._audioPlayer.pause();
            this._groups.forEach(act => act.destroy());
            this._groups.length = 0;
            this._currents.clear();
        }
        _run() {
            this._current = 0;
            this._audioPlayer.play(0);
            let lastTime;
            const next = (nowTime) => {
                if (lastTime === undefined)
                    lastTime = nowTime;
                const diff = (nowTime - lastTime) / 1000;
                this._loop(diff);
                lastTime = nowTime;
                this._loopHandle = requestAnimationFrame(next);
            };
            ///
            this._loopHandle = requestAnimationFrame(next);
        }
        _loop(diff) {
            if (this._paused)
                return;
            const currents = this._currents;
            const begin = this._current;
            const end = this._current + diff;
            /// 结束过期的action
            currents.forEach((act, key) => {
                if (act.begin > begin || act.end < end) {
                    act.finish();
                    currents.delete(key);
                }
            });
            /// 查找新的action
            const result = this._findActions(begin, end);
            result.forEach((act, key) => {
                if (currents.has(key))
                    return;
                ///
                //act.finish();
                act.start();
                ///
                currents.set(key, act);
            });
            ///
            this._current = end;
        }
        _findActions(begin, end) {
            const result = new Map();
            this._groups.forEach((act, index) => {
                if (act.begin <= end && act.end >= begin) {
                    result.set(index, act);
                }
            });
            return result;
        }
    }
    CZMAP.ActionPlayer = ActionPlayer;
})(CZMAP || (CZMAP = {}));
/// <reference path="Action.ts" />
var CZMAP;
(function (CZMAP) {
    class ViewInfoAction extends CZMAP.Action {
        constructor(view, option) {
            super(view, option);
            this._option = option;
        }
        init() {
            return Promise.resolve();
        }
        start() {
            const option = this._option;
            this.view.setViewInfo({
                position: option.target,
                heading: option.hpr[0],
                pitch: option.hpr[1],
                roll: option.hpr[2]
            }, {
                duration: option.duration
            });
        }
        pause() {
            //this.czviewer.camera.cancelFlight();
            this.cancelFlight();
        }
        finish() {
            //throw new Error("Method not implemented.");
        }
    }
    class FlytoAction extends CZMAP.Action {
        constructor(view, option) {
            super(view, option);
            this._option = option;
        }
        init() {
            return Promise.resolve();
        }
        start() {
            const option = this._option;
            const ps = Cesium.Cartesian3.fromDegrees(...option.target);
            const sp = new Cesium.BoundingSphere(ps, option.distance);
            this.view.flyToSphere(sp, {
                heading: option.heading,
                pitch: option.pitch,
                duration: option.duration
            });
        }
        pause() {
            this.cancelFlight();
        }
        finish() {
            //throw new Error("Method not implemented.");
        }
    }
    class RotateAction extends CZMAP.Action {
        constructor(view, option) {
            super(view, option);
            this._flying = false;
            this._option = option;
        }
        ///
        init() {
            const option = this._option;
            const tar = Cesium.Cartesian3.fromDegrees(...option.target);
            const sp = new Cesium.BoundingSphere(tar, option.distance);
            const vinfo = this.view.getViewInfo();
            ///
            const flyDuration = CZMAP.defaultValue(option.flyDuration, 2);
            const rotateDuration = option.duration;
            const allDuration = flyDuration + rotateDuration;
            const speed = option.speed || 3;
            const flyOption = {
                heading: CZMAP.defaultValue(option.heading, vinfo.heading),
                pitch: option.pitch,
                distance: option.distance,
                duration: CZMAP.defaultValue(option.flyDuration, 2),
            };
            ///
            this._loop = new CZMAP.Loop();
            this._loop.duration = allDuration * 1000;
            this._loop.callback = (percent, time, deltaTime) => {
                const second = time / 1000.0;
                if (second < flyDuration) {
                    if (!this._flying) {
                        this._flying = true;
                        flyOption.duration = flyDuration - second;
                        this.view.flyToSphere(sp, flyOption);
                    }
                }
                else {
                    flyOption.heading += speed * deltaTime / 1000.0;
                    flyOption.duration = 0;
                    this.view.flyToSphere(sp, flyOption);
                }
            };
            return Promise.resolve();
        }
        async start() {
            this._loop.start();
            console.info('start rotate:' + this._loop.id);
        }
        pause() {
            this._loop.pause();
            this._flying = false;
            this.cancelFlight();
        }
        finish() {
            this._loop.stop();
        }
    }
    class EntityAction extends CZMAP.Action {
        constructor(view, option) {
            super(view, option);
            this._entities = [];
            this._startLoop = new CZMAP.Loop({
                duration: 1000,
                callback: (percent, t) => {
                    console.info('start:scale', percent, t);
                    this._entities.forEach(e => showEntity(e, percent));
                }
            });
            this._finishLoop = new CZMAP.Loop({
                duration: 1000,
                callback: (percent, t) => {
                    console.info('finish:scale', percent, t);
                    this._entities.forEach(e => showEntity(e, 1 - percent));
                },
                finish: () => {
                    console.info('finished');
                    this._entities.forEach(e => e.show = false);
                }
            });
        }
        start() {
            if (!this._entities)
                return;
            ///
            this._finishLoop.stop();
            this._entities.forEach(e => e.show = true);
            this._startLoop.start();
        }
        pause() {
            this._startLoop.pause();
            this._finishLoop.pause();
        }
        finish() {
            if (!this._entities)
                return;
            ///
            this._startLoop.stop();
            this._finishLoop.start();
        }
        destroy() {
            if (this._entities) {
                if (this.czviewer)
                    this._entities.forEach(e => this.czviewer.entities.remove(e));
                this._entities.length = 0;
            }
        }
    }
    function showEntityPoly(entity, show) {
        const { billboard, label, polygon, polyline } = entity;
        if (polyline) {
            polyline.show = show;
        }
        if (polygon) {
            polygon.show = show;
        }
    }
    function showEntity(entity, percent) {
        const { billboard, label, polygon, polyline } = entity;
        if (billboard)
            billboard.scale = percent;
        if (label)
            label.scale = percent;
    }
    class PinActive extends EntityAction {
        constructor(view, option) {
            super(view, option);
            this._option = option;
        }
        init() {
            return this._init();
        }
        async _init() {
            const option = this._option;
            const img = await fetchImage(option.icon);
            if (this.czviewer) {
                const entity = this.czviewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(...option.target),
                    show: false,
                    billboard: {
                        scale: 0,
                        image: option.icon,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                    },
                    label: {
                        scale: 0,
                        text: option.text,
                        font: option.textFont,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        fillColor: CZMAP.CesiumAttrib.getColor(option.textColor),
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -img.height - 10)
                    }
                });
                this._entities.push(entity);
            }
        }
    }
    function asPolylineMaterial(material) {
        if (typeof material === 'string')
            return CZMAP.CesiumAttrib.getColor(material);
        material = Object.assign({}, material);
        material.color = CZMAP.CesiumAttrib.getColor(material.color);
        material.outlineColor = CZMAP.CesiumAttrib.getColor(material.outlineColor);
        switch (material.type) {
            case 'arrow':
                return new Cesium.PolylineArrowMaterialProperty(material.color);
            case 'dash':
                return new Cesium.PolylineDashMaterialProperty(material);
            case 'outline':
                return new Cesium.PolylineOutlineMaterialProperty(material);
            case 'glow':
                return new Cesium.PolylineGlowMaterialProperty(material);
        }
    }
    function setColorPropertyAlpha(material, name, alpha) {
        if (!material)
            return;
        const prop = material[name];
        if (!prop)
            return;
        ///
        const color = prop.getValue(undefined);
        if (!color)
            return;
        ///
        const acolor = color.withAlpha(alpha);
        material[name] = acolor;
    }
    class PolylineAction extends EntityAction {
        constructor(view, option) {
            super(view, option);
            this._option = option;
        }
        async init() {
            let lines = await loadPolyline(this._option.points);
            this.createEntity(lines);
        }
        createEntity(line) {
            if (this.czviewer) {
                const entity = this.czviewer.entities.add({
                    show: false,
                    polyline: {
                        positions: line.map(p => Cesium.Cartesian3.fromDegrees(...p)),
                        width: this._option.width,
                        material: asPolylineMaterial(this._option.material)
                    }
                });
                this._entities.push(entity);
            }
        }
    }
    class PolygoneAction extends EntityAction {
        constructor(view, option) {
            super(view, option);
            this._option = option;
        }
        async init() {
            let polygon = await loadPolygon(this._option.points);
            this.createEntity(polygon[0]);
        }
        createEntity(points) {
            const option = this._option;
            const box = Cesium.AxisAlignedBoundingBox.fromPoints(points.map(p => new Cesium.Cartesian3(...p)));
            const center = Cesium.Cartesian3.midpoint(box.minimum, box.maximum, new Cesium.Cartesian3());
            const position = Cesium.Cartesian3.fromDegrees(center.x, center.y, center.z);
            const entOption = {
                show: false,
            };
            const positions = points.map(p => Cesium.Cartesian3.fromDegrees(...p));
            if (option.color) {
                entOption.polygon = {
                    hierarchy: positions,
                    fill: true,
                    material: asPolylineMaterial(option.color),
                    outlineColor: CZMAP.CesiumAttrib.getColor(option.outlineColor)
                };
            }
            if (option.outlineColor && option.outlineWidth) {
                entOption.polyline = {
                    positions: positions,
                    width: option.outlineWidth,
                    material: asPolylineMaterial(option.outlineColor)
                };
            }
            if (this._option.text) {
                entOption.position = position;
                entOption.label = {
                    scale: 0,
                    text: option.text,
                    font: option.textFont,
                    fillColor: CZMAP.CesiumAttrib.getColor(option.textColor),
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -10)
                };
            }
            ///
            this._entities.push(this.czviewer.entities.add(entOption));
        }
    }
    class CircleAction extends PolygoneAction {
        constructor(view, option) {
            super(view, option);
        }
        async init() {
        }
    }
    async function loadPolyline(data) {
        if (typeof data === "string") {
            const json = await CZMAP.fetchJSON(data);
            const type = json.geometry.type;
            if (type === 'LineString')
                return json.geometry.coordinates;
            else if (type === 'Polygon')
                return json.geometry.coordinates[0];
            else {
                console.warn('错误的文件格式');
                return [];
            }
        }
        else {
            return data;
        }
    }
    async function loadPolygon(points) {
        if (typeof points === "string") {
            const json = await CZMAP.fetchJSON(points);
            const type = json.geometry.type;
            if (type === 'LineString')
                return [json.geometry.coordinates];
            else if (type === 'Polygon')
                return json.geometry.coordinates;
            else {
                console.warn('错误的文件格式');
                return [];
            }
        }
        else {
            return points;
        }
    }
    class DistanceAction extends EntityAction {
        constructor(view, option) {
            super(view, option);
            const p0 = Cesium.Cartesian3.fromDegrees(...option.points[0]);
            const p1 = Cesium.Cartesian3.fromDegrees(...option.points[1]);
            option.points.map(p => Cesium.Cartesian3.fromDegrees(...p));
            if (this.czviewer) {
                const entity = this.czviewer.entities.add({
                    show: false,
                    position: Cesium.Cartesian3.midpoint(p0, p1, new Cesium.Cartesian3()),
                    label: {
                        scale: 0,
                        text: option.text,
                        font: option.textFont,
                        fillColor: CZMAP.CesiumAttrib.getColor(option.textColor),
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -20)
                    },
                    polyline: {
                        positions: [p0, p1],
                        width: option.lineWidth,
                        material: new Cesium.PolylineArrowMaterialProperty(CZMAP.CesiumAttrib.getColor(option.lineColor))
                    }
                });
                this._entities.push(entity);
            }
        }
    }
    function fetchImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.crossOrigin = 'anonymous';
            img.src = src;
        });
    }
    const ActionTypes = {
        flyto: FlytoAction,
        viewinfo: ViewInfoAction,
        pin: PinActive,
        polyline: PolylineAction,
        polygon: PolygoneAction,
        distance: DistanceAction,
        rotate: RotateAction
    };
    function createAction(view, option) {
        const creator = ActionTypes[option.type];
        if (!creator)
            return;
        return new creator(view, option);
    }
    CZMAP.createAction = createAction;
    function registerAction(name, creator) {
        ActionTypes[name] = creator;
    }
    CZMAP.registerAction = registerAction;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 要素的属性
     */
    let FeatureProperty;
    (function (FeatureProperty) {
        FeatureProperty["ID"] = "id";
        FeatureProperty["PROPERTIES"] = "properties";
        FeatureProperty["GEOMETRY"] = "geometry";
    })(FeatureProperty = CZMAP.FeatureProperty || (CZMAP.FeatureProperty = {}));
    /**
     * 要素
     */
    class Feature extends CZMAP.BaseObject {
        /**
         * 构造一个新的要素
         * @param {Object} feature
         */
        constructor(feature) {
            super();
            /// 
            this.def(FeatureProperty.ID, -1);
            this.def(FeatureProperty.PROPERTIES, {});
            this.def(FeatureProperty.GEOMETRY, null, Feature.checkGeometry);
            ///
            if (CZMAP.Types.isDefined(feature)) {
                this.set(FeatureProperty.ID, feature.id);
                this.set(FeatureProperty.PROPERTIES, feature.properties);
                this.set(FeatureProperty.GEOMETRY, feature.geometry);
            }
        }
        /**
         * ID
         */
        get id() { return this.get(FeatureProperty.ID); }
        set id(v) { this.set(FeatureProperty.ID, v); }
        /**
         * 属性
         */
        get properties() { return this.get(FeatureProperty.PROPERTIES); }
        set properties(v) { this.set(FeatureProperty.PROPERTIES, v); }
        /**
         * 几何对象
         */
        get geometry() { return this.get(FeatureProperty.GEOMETRY); }
        set geometry(v) { this.set(FeatureProperty.GEOMETRY, v); }
        /**
         *
         * @param geo
         */
        static checkGeometry(geo) {
            return CZMAP.GeometryFactory.create(geo);
        }
    }
    CZMAP.Feature = Feature;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 几何对象的基类
     */
    class Geometry {
        /**
         * 构造一个几何对象
         * @param geo
         */
        constructor() {
            /**
             * 包围盒
             */
            this._box = new CZMAP.BoundingBox();
            if (this.constructor === Geometry) {
                throw new Error("Geometry is abstract.");
            }
        }
        /**
         * 获取几何的类型
         */
        get type() { return this.getGeometryType(); }
        /**
         * 获取几何的坐标
         */
        get coordinates() { return this.getCoordinates(); }
        /**
         * 获取当前对象的box
         */
        get box() {
            if (this._box.isEmpty())
                this.computeBox();
            ///
            return this._box.clone();
        }
        /**
         * 计算包围盒
         * @protected
         */
        computeBox() {
            this._box.mergeCoordinates(this.coordinates);
        }
    }
    CZMAP.Geometry = Geometry;
})(CZMAP || (CZMAP = {}));
/// <reference path="../geom/Feature.ts" />
/// <reference path="../geom/Geometry.ts" />
/// <reference path="../proj/Projection.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 要素格式类型
     */
    let FeatureFormatType;
    (function (FeatureFormatType) {
        FeatureFormatType["ARRAY_BUFFER"] = "arraybuffer";
        FeatureFormatType["JSON"] = "json";
        FeatureFormatType["TEXT"] = "text";
        FeatureFormatType["XML"] = "xml";
    })(FeatureFormatType = CZMAP.FeatureFormatType || (CZMAP.FeatureFormatType = {}));
    ;
    /**
     * 要素格式化
     */
    class FeatureFormat {
        constructor(option) {
            this._option = option || {};
        }
        applyOffset(geometry) {
            const offset = this._option.coordinateOffset;
            if (offset) {
                geometry.applyTransform((src, dest) => CZMAP.GeoMath.add(src, offset, dest));
            }
        }
    }
    CZMAP.FeatureFormat = FeatureFormat;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 几何类型
     */
    let GeometryType;
    (function (GeometryType) {
        /**
         * 点类型
         */
        GeometryType["POINT"] = "point";
        /**
         * 折线
         */
        GeometryType["POLYLINE"] = "polyline";
        /**
         * 多边形
         */
        GeometryType["POLYGON"] = "polygon";
        /**
         * 多点
         */
        GeometryType["MULTI_POINT"] = "multipoint";
        /**
         * 多线
         */
        GeometryType["MULTI_POLYLINE"] = "multipolyline";
        /**
         * 多多边形
         */
        GeometryType["MULTI_POLYGON"] = "multipolygon";
        /**
         * 圆
         */
        GeometryType["CIRCLE"] = "circle";
        /**
         * 矩形
         */
        GeometryType["RECTANGLE"] = "rectange";
    })(GeometryType = CZMAP.GeometryType || (CZMAP.GeometryType = {}));
    ;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 几何工厂
     */
    class GeometryFactory {
        /**
         * 创建几何对象
         * @param geo
         */
        static create(geo) {
            if (!CZMAP.Types.isDefined(geo))
                return undefined;
            if (geo instanceof CZMAP.Geometry)
                return geo;
            switch (geo.type.toLowerCase()) {
                case CZMAP.GeometryType.POINT:
                    return new CZMAP.GeoPoint(geo);
                case CZMAP.GeometryType.POLYLINE:
                case "linestring":
                    return new CZMAP.GeoPolyline(geo);
                case CZMAP.GeometryType.POLYGON:
                    return new CZMAP.GeoPolygon(geo);
                case CZMAP.GeometryType.CIRCLE:
                    return new CZMAP.GeoCircle(geo);
                case CZMAP.GeometryType.RECTANGLE:
                    return new CZMAP.GeoRectangle(geo);
            }
        }
    }
    CZMAP.GeometryFactory = GeometryFactory;
})(CZMAP || (CZMAP = {}));
/// <reference path="../utils/util.ts" />
/// <reference path="../geom/GeometryType.ts" />
/// <reference path="../geom/Geometry.ts" />
/// <reference path="../geom/Feature.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for JSON feature formats.
     */
    class JSONFeatureFormat extends CZMAP.FeatureFormat {
        constructor(option) {
            super(option);
        }
        /**
         * 获取要素格式的类型
         */
        getType() { return CZMAP.FeatureFormatType.JSON; }
        /**
         * @inheritDoc
         */
        readFeature(source, options) {
            return this.readFeatureFromObject(getObject(source), options);
        }
        /**
         * @inheritDoc
         */
        readFeatures(source, options) {
            return this.readFeaturesFromObject(getObject(source), options);
        }
        /**
         * @inheritDoc
         */
        readProjection(source, options) {
            return this.readProjectionFromObject(getObject(source), options);
        }
        /**
         * @inheritDoc
         */
        readGeometry(source, options) {
            return this.readGeometryFromObject(getObject(source), options);
        }
    }
    CZMAP.JSONFeatureFormat = JSONFeatureFormat;
    /** 获取对象 */
    function getObject(source) {
        if (typeof source === 'string') {
            const object = JSON.parse(source);
            return object ? (object) : null;
        }
        else if (source !== null) {
            return source;
        }
        else {
            return null;
        }
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="../geom/GeometryType.ts" />
/// <reference path="../geom/GeometryFactory.ts" />
/// <reference path="JSONFeatureFormat.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * @classdesc
     * Feature format for reading and writing data in the GeoJSON format.
     *
     * @api
     */
    class GeoJSONFormat extends CZMAP.JSONFeatureFormat {
        /**
         * @param opt_options Options.
         */
        constructor(option) {
            super(option);
        }
        /**
         * @inheritDoc
         */
        readFeatureFromObject(object) {
            let geojson = null;
            if (object['type'] === 'Feature') {
                geojson = object;
            }
            else {
                geojson = {
                    'type': 'Feature',
                    'geometry': object,
                    'properties': null
                };
            }
            const geometry = this.readGeometryFromObject(geojson['geometry']);
            const feature = new CZMAP.Feature();
            feature.geometry = geometry;
            if ('id' in geojson) {
                feature.id = geojson['id'];
            }
            if (geojson['properties']) {
                feature.properties = geojson['properties'];
            }
            return feature;
        }
        /**
         * @inheritDoc
         */
        readFeaturesFromObject(object) {
            const geoJSONObject = (object);
            let features;
            if (geoJSONObject['type'] === 'FeatureCollection') {
                features = [];
                const geoJSONFeatureCollection = (object);
                const geoJSONFeatures = geoJSONFeatureCollection['features'];
                for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
                    features.push(this.readFeatureFromObject(geoJSONFeatures[i]));
                }
            }
            else {
                features = [this.readFeatureFromObject(object)];
            }
            ///
            return features;
        }
        /**
         * @inheritDoc
         */
        readGeometryFromObject(object) {
            if (!object) {
                return null;
            }
            ///
            const geometry = CZMAP.GeometryFactory.create(object);
            if (geometry)
                this.applyOffset(geometry);
            ///
            return geometry;
        }
        /**
         * @inheritDoc
         */
        readProjectionFromObject(object) {
            const crs = object['crs'];
            let projection;
            if (crs) {
                if (crs['type'] == 'name') {
                    projection = ''; //getProjection(crs['properties']['name']);
                }
                else {
                    //assert(false, 36); // Unknown SRS type
                }
            }
            ///
            return ((projection));
        }
        /**
         *
         * @param {*} object
         */
        _readGeometry(object) {
        }
    }
    CZMAP.GeoJSONFormat = GeoJSONFormat;
    const TypeMap = {
        'Point': CZMAP.GeometryType.POINT,
        'LineString': CZMAP.GeometryType.POLYLINE,
        'Polygon': CZMAP.GeometryType.POLYGON,
        'MultiPoint': CZMAP.GeometryType.MULTI_POINT,
    };
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 坐标数据的布局 */
    let GeometryLayout;
    (function (GeometryLayout) {
        /** [x,y] */
        GeometryLayout["XY"] = "xy";
        /** [x,y,z] */
        GeometryLayout["XYZ"] = "xyz";
        /** [x,y,m] */
        GeometryLayout["XYM"] = "xym";
        /** [x,y,z,m] */
        GeometryLayout["XYZM"] = "xyzm";
    })(GeometryLayout = CZMAP.GeometryLayout || (CZMAP.GeometryLayout = {}));
    /**
     *
     * @api
     */
    class TableDataFormat extends CZMAP.JSONFeatureFormat {
        /**
         */
        constructor(option) {
            super(option);
            ///
            this._meta = option.option;
        }
        /**
         * @inheritDoc
         */
        readFeatureFromObject(data, options) {
            ///
            const meta = this.getTableMeta(options);
            ///
            const feature = new CZMAP.Feature();
            feature.geometry = this._readGeometry(data, meta);
            feature.properties = data;
            return feature;
        }
        /**
         * @inheritDoc
         */
        readFeaturesFromObject(data) {
            const table = data;
            const list = this.getDataList(data);
            ///
            let features = [];
            if (CZMAP.Types.isArray(list)) {
                list.forEach(e => {
                    features.push(this.readFeatureFromObject(e, table.meta));
                });
            }
            return features;
        }
        /**
         * @inheritDoc
         */
        readGeometryFromObject(object, option) {
            return this._readGeometry(object, this.getTableMeta(option));
        }
        /**
         * @inheritDoc
         */
        readProjectionFromObject(object, option) {
            const table = object;
            if (table.meta && table.meta.epsg)
                return 'EPSG:' + table.meta.epsg;
            return null;
        }
        getTableMeta(option) {
            return CZMAP.defaultValue(this._meta, option);
        }
        getDataList(data) {
            const meta = this.getTableMeta(data.meta);
            if (!meta.datapath)
                return data.data;
            ///
            meta.datapath.forEach(f => data = data[f]);
            return data;
        }
        _readGeometry(object, option) {
            const geometry = readGeometry(object, option);
            if (geometry)
                this.applyOffset(geometry);
            return geometry;
        }
    }
    CZMAP.TableDataFormat = TableDataFormat;
    function readGeomComp(data, field, ...ofields) {
        if (CZMAP.defined(field)) {
            let val = data[field];
            if (CZMAP.defined(val))
                return val;
            if (typeof field === 'number')
                return field;
        }
        for (let i = 0; i < ofields.length; ++i) {
            const val = data[ofields[i]];
            if (CZMAP.defined(val))
                return val;
        }
        return undefined;
    }
    /**
     *
     * @param {*} object
     */
    function readGeometry(object, option) {
        if (!object) {
            return null;
        }
        const e = object;
        if (CZMAP.Types.isArray(e.coordinates)) {
            if (!CZMAP.Types.isDefined(e.type)) {
                e.type = checkType(e.coordinates);
            }
            return CZMAP.GeometryFactory.create(e);
        }
        const tops = option;
        if (!CZMAP.Types.isDefined(tops))
            return null;
        const type = CZMAP.defaultValue(tops.type, CZMAP.GeometryType.POINT);
        if (type === CZMAP.GeometryType.POINT) {
            ///
            let vx = readGeomComp(e, tops.x, 'x', 'X');
            let vy = readGeomComp(e, tops.y, 'y', 'Y');
            let vz = readGeomComp(e, tops.z, 'z', 'Z');
            vx = CZMAP.Types.isDefined(vx) ? Number.parseFloat(vx) : 0;
            vy = CZMAP.Types.isDefined(vy) ? Number.parseFloat(vy) : 0;
            vz = CZMAP.Types.isDefined(vz) ? Number.parseFloat(vz) : 0;
            return new CZMAP.GeoPoint(vx, vy, vz);
        }
        if (!CZMAP.defined(tops.coordinates))
            return null;
        const xyz = e[tops.coordinates];
        if (typeof xyz !== 'string')
            return null;
        try {
            const coordinates = JSON.parse(xyz);
            return CZMAP.GeometryFactory.create({
                type,
                coordinates
            });
        }
        catch (e) {
        }
        try {
            const coordinates = [];
            const layout = CZMAP.defaultValue(tops.layout, GeometryLayout.XY);
            const cellSize = calcLayoutSize(layout);
            const xyzn = CZMAP.Parse.parseArray(xyz, ",;");
            const size = xyzn.length / cellSize;
            for (let i = 0; i < size; ++i) {
                const point = [];
                const index = i * cellSize;
                for (let k = 0; k < cellSize; ++k) {
                    point.push(xyzn[index + k]);
                }
                coordinates.push(point);
            }
            ///
            return CZMAP.GeometryFactory.create({
                type: CZMAP.GeometryType.POLYLINE,
                coordinates
            });
        }
        catch (e) {
        }
    }
    function calcLayoutSize(layout) {
        switch (layout) {
            case GeometryLayout.XY: return 2;
            case GeometryLayout.XYZ:
            case GeometryLayout.XYM: return 3;
            case GeometryLayout.XYZM: return 4;
        }
        return 2;
    }
    function checkType(coord) {
        if (!CZMAP.Types.isArray(coord))
            return undefined;
        if (!CZMAP.Types.isArray(coord[0]))
            return CZMAP.GeometryType.POINT;
        if (!CZMAP.Types.isArray(coord[0][0]))
            return CZMAP.GeometryType.POLYLINE;
        ///
        return CZMAP.GeometryType.POLYGON;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function swapMinMax(o, minf, maxf) {
        const min = o[minf];
        const max = o[maxf];
        if (min > max) {
            o[minf] = max;
            o[maxf] = min;
        }
    }
    /**
     * 包围盒
     */
    class BoundingBox {
        static formString(sbox, result) {
            if (!result)
                result = new BoundingBox();
            const cbox = CZMAP.Numbers.parseArray(sbox, ',', 6);
            result.minx = cbox[0];
            result.miny = cbox[1];
            result.minz = cbox[2];
            result.maxx = cbox[3];
            result.maxy = cbox[4];
            result.maxz = cbox[5];
            return result;
        }
        static formCenterSize(center, size, result) {
            if (!result)
                result = new BoundingBox();
            ///
            const rsize = CZMAP.GeoMath.mulScalar(size, 0.5);
            const [cx, cy, cz] = center;
            const [sx, sy, sz] = rsize;
            ///
            result.minx = cx - sx;
            result.miny = cy - sy;
            result.minz = cz - sz;
            result.maxx = cx + sx;
            result.maxy = cy + sy;
            result.maxz = cz + sz;
            return result;
        }
        static fromExtent(extent) {
            const bb = new BoundingBox();
            const [x0, y0, x1, y1] = extent;
            bb.minx = x0;
            bb.miny = y0;
            bb.minz = 0;
            bb.maxx = x1;
            bb.maxy = y1;
            bb.maxx = Math.min(bb.getWidth(), bb.getHeight()) * 111000 * 0.5;
            return bb;
        }
        /// 
        constructor() {
            ///
            this.minx = Infinity;
            this.miny = Infinity;
            this.minz = Infinity;
            ///
            this.maxx = -Infinity;
            this.maxy = -Infinity;
            this.maxz = -Infinity;
        }
        normalMinMax() {
            swapMinMax(this, 'minx', 'maxx');
            swapMinMax(this, 'miny', 'maxy');
            swapMinMax(this, 'minz', 'maxz');
        }
        setMin(pt) {
            this.minx = pt[0];
            this.miny = pt[1];
            this.minz = pt[2];
        }
        setMax(pt) {
            this.maxx = pt[0];
            this.maxy = pt[1];
            this.maxz = pt[2];
        }
        setMinMax(min, max) {
            this.minx = min[0];
            this.miny = min[1];
            this.minz = min[2];
            this.maxx = max[0];
            this.maxy = max[1];
            this.maxz = max[2];
            this.normalMinMax();
        }
        /**
         * 获取中心点
         * @param {Point} opt_point 可选的输出目标
         */
        getCenter(opt_point) {
            /// 
            return CZMAP.createOrUpdatePoint((this.minx + this.maxx) / 2.0, (this.miny + this.maxy) / 2.0, (this.minz + this.maxz) / 2.0, opt_point);
        }
        /**
         * 获取宽度
         */
        getWidth() { return this.maxx - this.minx; }
        /**
         * 获取高度
         */
        getHeight() { return this.maxy - this.miny; }
        /**
         * 获取深度
         */
        getDepth() { return this.maxz - this.minz; }
        /**
         * 获取最小点
         */
        getMin(opt_point) {
            return CZMAP.createOrUpdatePoint(this.minx, this.miny, this.minz, opt_point);
        }
        /**
         * 获取最大点
         * @param opt_point 可选的输出对象
         */
        getMax(opt_point) {
            return CZMAP.createOrUpdatePoint(this.maxx, this.maxy, this.maxz, opt_point);
        }
        /**
         * 获取box的尺寸
         * @param {Point} opt_size 可选的输出目标
         */
        getSize(opt_size) {
            return CZMAP.createOrUpdatePoint(this.maxx - this.minx, this.maxy - this.miny, this.maxz - this.minz, opt_size);
        }
        /** 获取包围半径 */
        getBoundRadius() {
            return CZMAP.GeoMath.calcLength(CZMAP.GeoMath.sub(this.getCenter(), this.getMin()));
        }
        /** 获取角点坐标 */
        getCorners() {
            const { minx, miny, minz, maxx, maxy, maxz } = this;
            return [
                [minx, miny, minz],
                [maxx, miny, minz],
                [minx, maxy, minz],
                [maxx, maxy, minz],
                [minx, miny, maxz],
                [maxx, miny, maxz],
                [minx, maxy, maxz],
                [maxx, maxy, maxz],
            ];
        }
        /**
         * 是否为空
         * @return {boolean} Is empty.
         * @api
         */
        isEmpty() {
            return this.minx > this.maxx ||
                this.miny > this.maxy ||
                this.minz > this.maxz;
        }
        /**
         * 设置为空
         */
        setEmtpty() {
            this.minx = Infinity;
            this.miny = Infinity;
            this.minz = Infinity;
            this.maxx = -Infinity;
            this.maxy = -Infinity;
            this.maxz = -Infinity;
        }
        /**
         * 外扩或者缩小当前box
         * @param value 扩大或者缩小的尺寸
         */
        inflate(value) {
            this.inflateXYZ(value, value, value);
        }
        /**
         * 外扩或者缩小当前box
         * @param multiple 倍数
         */
        inflateMultiple(multiple) {
            const ct = this.getCenter();
            const sz = this.getSize();
            this.minx = ct[0] - sz[0] / 2 * multiple;
            this.miny = ct[1] - sz[1] / 2 * multiple;
            this.minz = ct[2] - sz[2] / 2 * multiple;
            this.maxx = ct[0] + sz[0] / 2 * multiple;
            this.maxy = ct[1] + sz[1] / 2 * multiple;
            this.maxz = ct[2] + sz[2] / 2 * multiple;
        }
        /**
         * 外扩或者缩小当前box
         * @param x 扩大或者缩小的尺寸
         * @param y 扩大或者缩小的尺寸
         * @param z 扩大或者缩小的尺寸
         */
        inflateXYZ(x, y, z) {
            this.minx -= x;
            this.miny -= y;
            this.minz -= z;
            this.maxx += x;
            this.maxy += y;
            this.maxz += z;
        }
        /**
         * 是否包含点坐标
         * @param point 点坐标
         */
        containsPoint(point) {
            return this.containsXYZ(point[0], point[1], point[2]);
        }
        /**
         * 是否包含是xyz坐标
         */
        containsXYZ(x, y, z) {
            const xy = x >= this.minx && x <= this.maxx &&
                y >= this.miny && y <= this.maxy;
            ///
            if (CZMAP.Types.isDefined(z)) {
                return xy && z >= this.minz && z <= this.maxz;
            }
            else {
                return xy;
            }
        }
        /**
         * 克隆对象
         * @param {Box} opt_box 可选的输出对象
         */
        clone(opt_box) {
            if (!opt_box)
                opt_box = new BoundingBox();
            opt_box.minx = this.minx;
            opt_box.miny = this.miny;
            opt_box.minz = this.minz;
            opt_box.maxx = this.maxx;
            opt_box.maxy = this.maxy;
            opt_box.maxz = this.maxz;
            /// 
            return opt_box;
        }
        /**
         * 合并box到当前对象
         * @param {Box} box
         */
        mergeBox(box) {
            if (box.minx < this.minx)
                this.minx = box.minx;
            if (box.miny < this.miny)
                this.miny = box.miny;
            if (box.minz < this.minz)
                this.minz = box.minz;
            if (box.maxx > this.maxx)
                this.maxx = box.maxx;
            if (box.maxy > this.maxy)
                this.maxy = box.maxy;
            if (box.maxz > this.maxz)
                this.maxz = box.maxz;
        }
        /**
         * 合并点到当前box中
         * @param {Point} pt
         */
        mergePoint(pt) {
            this.mergeXYZ(pt[0], pt[1], pt[2]);
        }
        /**
         * 合并xyz坐标到box中
         * @param {number} x
         * @param {number} y
         * @param {number} z
         */
        mergeXYZ(x, y, z) {
            if (x < this.minx)
                this.minx = x;
            if (y < this.miny)
                this.miny = y;
            if (z < this.minz)
                this.minz = z;
            if (x > this.maxx)
                this.maxx = x;
            if (y > this.maxy)
                this.maxy = y;
            if (z > this.maxz)
                this.maxz = z;
        }
        /**
         * 从坐标串到当前box中
         * @param {Coordinates} coordinates
         */
        mergeCoordinates(coordinates) {
            const c = coordinates;
            if (!CZMAP.Types.isArray(c))
                return;
            if (CZMAP.Types.isArray(c[0])) {
                c.forEach((e) => this.mergeCoordinates(e));
            }
            else if (CZMAP.Types.isNumber(c[0])) {
                let [x, y, z] = c;
                this.mergeXYZ(x, y, CZMAP.defaultValue(z, 0));
            }
        }
    }
    BoundingBox.Empty = Object.freeze(new BoundingBox());
    CZMAP.BoundingBox = BoundingBox;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * `Extent` 的操作函数
     */
    class Extents {
        /**
         * 创建一个空的 Extent
         * @return {Extent}.
         * @api
         */
        static createEmpty() {
            return [Infinity, Infinity, -Infinity, -Infinity];
        }
        /**
         * 创建一个新的 `Extent` 或者更新提供的 `Extent`
         * @param {number} minX 最小的 X.
         * @param {number} minY 最小的 Y.
         * @param {number} maxX 最大的 X.
         * @param {number} maxY 最大的 Y.
         * @param {Extent=} opt_extent
         * @return {Extent}
         */
        static createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
            if (opt_extent) {
                opt_extent[0] = minX;
                opt_extent[1] = minY;
                opt_extent[2] = maxX;
                opt_extent[3] = maxY;
                return opt_extent;
            }
            else {
                return [minX, minY, maxX, maxY];
            }
        }
        /**
         * 创建一个新的空 `Extent` 或者使上一个 `extent` 为空
         * @param {Extent=} opt_extent Extent.
         * @return {Extent} Extent.
         */
        static createOrUpdateEmpty(opt_extent) {
            return this.createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
        }
        /**
         * @param {Array<[x,y]>} coordinates 坐标串.
         * @param {Extent=} opt_extent Extent.
         * @return {Extent} Extent.
         */
        static createOrUpdateFromCoordinates(coordinates, opt_extent) {
            const extent = this.createOrUpdateEmpty(opt_extent);
            return this.extendCoordinates(extent, coordinates);
        }
        /**
         * 计算所有坐标点的外包框
         *
         * @param {Array<[x,y]>} coordinates Coordinates.
         * @return {Extent} Bounding extent.
         * @api
         */
        static boundingExtent(coordinates) {
            const extent = this.createEmpty();
            for (let i = 0, ii = coordinates.length; i < ii; ++i) {
                this.extendCoordinate(extent, coordinates[i]);
            }
            return extent;
        }
        /**
         * 计算缓冲区
         * @param {Extent} extent Extent.
         * @param {number} value The amount by which the extent should be buffered.
         * @param {Extent=} opt_extent Extent.
         * @return {Extent} Extent.
         * @api
         */
        static buffer(extent, value, opt_extent) {
            if (opt_extent) {
                opt_extent[0] = extent[0] - value;
                opt_extent[1] = extent[1] - value;
                opt_extent[2] = extent[2] + value;
                opt_extent[3] = extent[3] + value;
                return opt_extent;
            }
            else {
                return [
                    extent[0] - value,
                    extent[1] - value,
                    extent[2] + value,
                    extent[3] + value
                ];
            }
        }
        /**
         * 克隆当前对象
         *
         * @param {Extent} extent Extent to clone.
         * @param {Extent=} opt_extent Extent.
         * @return {Extent} The clone.
         */
        static clone(extent, opt_extent) {
            if (opt_extent) {
                opt_extent[0] = extent[0];
                opt_extent[1] = extent[1];
                opt_extent[2] = extent[2];
                opt_extent[3] = extent[3];
                return opt_extent;
            }
            else {
                return extent.slice();
            }
        }
        /**
         * 是否包含坐标，内部或者边上
         *
         * @param {Extent} extent Extent.
         * @return {boolean} The coordinate is contained in the extent.
         * @api
         */
        static containsCoordinate(extent, coordinate) {
            return this.containsXY(extent, coordinate[0], coordinate[1]);
        }
        /**
         * 是否包含
         *
         * @param {Extent} extent1 Extent 1.
         * @param {Extent} extent2 Extent 2.
         * @return {boolean} The second extent is contained by or on the edge of the
         *     first.
         * @api
         */
        static containsExtent(extent1, extent2) {
            return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&
                extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
        }
        /**
         * 是否包含，内部或者边界上
         *
         * @param {Extent} extent Extent.
         * @param {number} x X coordinate.
         * @param {number} y Y coordinate.
         * @return {boolean} The x, y values are contained in the extent.
         * @api
         */
        static containsXY(extent, x, y) {
            return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
        }
        /**
         * 是否相同
         * @param {Extent} extent1 Extent 1.
         * @param {Extent} extent2 Extent 2.
         * @return {boolean} The two extents are equivalent.
         * @api
         */
        static equals(extent1, extent2) {
            return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&
                extent1[1] == extent2[1] && extent1[3] == extent2[3];
        }
        /**
         * 合并 extent2 到 extent1
         * @param {Extent} extent1 The extent to be modified.
         * @param {Extent} extent2 The extent that will be included in the first.
         * @return {Extent} A reference to the first (extended) extent.
         * @api
         */
        static extend(extent1, extent2) {
            if (extent2[0] < extent1[0]) {
                extent1[0] = extent2[0];
            }
            if (extent2[2] > extent1[2]) {
                extent1[2] = extent2[2];
            }
            if (extent2[1] < extent1[1]) {
                extent1[1] = extent2[1];
            }
            if (extent2[3] > extent1[3]) {
                extent1[3] = extent2[3];
            }
            return extent1;
        }
        /**
         * @param {Extent} extent Extent.
         */
        static extendCoordinate(extent, coordinate) {
            if (coordinate[0] < extent[0]) {
                extent[0] = coordinate[0];
            }
            if (coordinate[0] > extent[2]) {
                extent[2] = coordinate[0];
            }
            if (coordinate[1] < extent[1]) {
                extent[1] = coordinate[1];
            }
            if (coordinate[1] > extent[3]) {
                extent[3] = coordinate[1];
            }
        }
        /**
         * 合并坐标到当前Extent
         * @param {Extent} extent Extent.
         * @return {Extent} Extent.
         */
        static extendCoordinates(extent, coordinates) {
            for (let i = 0, ii = coordinates.length; i < ii; ++i) {
                let c = coordinates[i];
                if (Array.isArray(c[0]))
                    this.extendCoordinates(extent, c);
                else
                    this.extendCoordinate(extent, c);
            }
            return extent;
        }
        /**
         * @param {Extent} extent Extent.
         * @param {number} x X.
         * @param {number} y Y.
         */
        static extendXY(extent, x, y) {
            extent[0] = Math.min(extent[0], x);
            extent[1] = Math.min(extent[1], y);
            extent[2] = Math.max(extent[2], x);
            extent[3] = Math.max(extent[3], y);
        }
        /**
         * Get the size of an extent.
         * @param {Extent} extent Extent.
         * @return {number} Area.
         * @api
         */
        static getArea(extent) {
            let area = 0;
            if (!this.isEmpty(extent)) {
                area = this.getWidth(extent) * this.getHeight(extent);
            }
            return area;
        }
        /**
         * 获取中心
         * @param {Extent} extent Extent.
         * @return {[x,y]} Center.
         * @api
         */
        static getCenter(extent) {
            return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2, 0];
        }
        /**
         * 求交集
         * @param {Extent} extent1 Extent 1.
         * @param {Extent} extent2 Extent 2.
         * @param {Extent=} opt_extent Optional extent to populate with intersection.
         * @return {Extent} Intersecting extent.
         * @api
         */
        static getIntersection(extent1, extent2, opt_extent) {
            const intersection = opt_extent ? opt_extent : this.createEmpty();
            if (this.intersects(extent1, extent2)) {
                if (extent1[0] > extent2[0]) {
                    intersection[0] = extent1[0];
                }
                else {
                    intersection[0] = extent2[0];
                }
                if (extent1[1] > extent2[1]) {
                    intersection[1] = extent1[1];
                }
                else {
                    intersection[1] = extent2[1];
                }
                if (extent1[2] < extent2[2]) {
                    intersection[2] = extent1[2];
                }
                else {
                    intersection[2] = extent2[2];
                }
                if (extent1[3] < extent2[3]) {
                    intersection[3] = extent1[3];
                }
                else {
                    intersection[3] = extent2[3];
                }
            }
            else {
                this.createOrUpdateEmpty(intersection);
            }
            return intersection;
        }
        /**
         * 获取尺寸
         * @api
         */
        static getSize(extent) {
            return [extent[2] - extent[0], extent[3] - extent[1], 0];
        }
        /**
         * @api
         */
        static getTopLeft(extent) {
            return [extent[0], extent[3], 0];
        }
        /**
         * @api
         */
        static getTopRight(extent) {
            return [extent[2], extent[3], 0];
        }
        /**
         * @api
         */
        static getBottomLeft(extent) {
            return [extent[0], extent[1], 0];
        }
        /**
         * @api
         */
        static getBottomRight(extent) {
            return [extent[2], extent[1], 0];
        }
        /**
         * @param {Extent} extent Extent.
         * @return {number} Width.
         * @api
         */
        static getWidth(extent) {
            return extent[2] - extent[0];
        }
        /**
         * @param {Extent} extent Extent.
         * @return {number} Height.
         * @api
         */
        static getHeight(extent) {
            return extent[3] - extent[1];
        }
        /**
         * 是否相交
         * @param {Extent} extent1 Extent 1.
         * @param {Extent} extent2 Extent.
         * @return {boolean} The two extents intersect.
         * @api
         */
        static intersects(extent1, extent2) {
            return extent1[0] <= extent2[2] &&
                extent1[2] >= extent2[0] &&
                extent1[1] <= extent2[3] &&
                extent1[3] >= extent2[1];
        }
        /**
         * 是否为空
         * @param {Extent} extent Extent.
         * @return {boolean} Is empty.
         * @api
         */
        static isEmpty(extent) {
            return extent[2] < extent[0] || extent[3] < extent[1];
        }
        /**
         * @param {Extent} extent Extent.
         * @param {Extent=} opt_extent Extent.
         * @return {Extent} Extent.
         */
        static returnOrUpdate(extent, opt_extent) {
            if (opt_extent) {
                opt_extent[0] = extent[0];
                opt_extent[1] = extent[1];
                opt_extent[2] = extent[2];
                opt_extent[3] = extent[3];
                return opt_extent;
            }
            else {
                return extent;
            }
        }
        /**
         * @param {Extent} extent Extent.
         * @param {number} value Value.
         */
        static scaleFromCenter(extent, value) {
            const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
            const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
            extent[0] -= deltaX;
            extent[2] += deltaX;
            extent[1] -= deltaY;
            extent[3] += deltaY;
        }
    }
    CZMAP.Extents = Extents;
})(CZMAP || (CZMAP = {}));
/// <reference path="Geometry.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 几何————圆
     */
    class GeoCircle extends CZMAP.Geometry {
        constructor(cc, radius) {
            super();
            this._center = [0, 0, 0];
            this._radius = 0;
            if (cc instanceof GeoCircle) {
                this._center = cc._center.slice(0);
                this._radius = cc._radius;
            }
            else if (CZMAP.Types.isArray(cc)) {
                this._center = cc.slice();
                this._radius = radius;
            }
            else if (CZMAP.Types.isObject(cc)) {
                const g = cc;
                if (g.type === CZMAP.GeometryType.CIRCLE) {
                    this._center = CZMAP.deepCopy(g.center);
                    this._radius = g.radius;
                }
            }
        }
        /**
         * 获取圆的中心点
         */
        get center() { return this._center; }
        /**
         * 获取圆的半径
         */
        get radius() { return this._radius; }
        /**
         * 克隆当前对象
         */
        clone() {
            return new GeoCircle(this);
        }
        /**
         * 获取几何的坐标点
         */
        getCoordinates() {
            return this._center;
        }
        /**
         * 获取几何类型
         */
        getGeometryType() {
            return CZMAP.GeometryType.CIRCLE;
        }
        /**
         * 对当前对象应用坐标变换
         * @abstract
         * @param {TransformProc} proc Transform.
         */
        applyTransform(proc, opt_this) {
            this._box.setEmtpty();
            proc.call(opt_this, this._center, this._center);
        }
        /**
         * 计算包围盒
         * @override
         * @abstract
         */
        computeBox() {
            this._box.setEmtpty();
            this._box.mergeXYZ(this._center[0] - this._radius, this._center[1] - this._radius, this._center[2] - this._radius);
            this._box.mergeXYZ(this._center[0] + this._radius, this._center[1] + this._radius, this._center[2] + this._radius);
        }
    }
    CZMAP.GeoCircle = GeoCircle;
})(CZMAP || (CZMAP = {}));
/// <reference path="Geometry.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 几何————点对象
     */
    class GeoPoint extends CZMAP.Geometry {
        constructor(x, y, z) {
            super();
            this.x = 0;
            this.y = 0;
            this.z = 0;
            /**
             * 坐标串
             */
            this._coordinates = new Array(3);
            ///
            if (x instanceof GeoPoint) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
            }
            else if (CZMAP.Types.isArray(x)) {
                this.x = x[0];
                this.y = x[1];
                this.z = x[2];
            }
            else if (CZMAP.Types.isObject(x)) {
                const g = x;
                if (g.type.toLowerCase() === CZMAP.GeometryType.POINT) {
                    const c = g.coordinates;
                    this.x = c[0];
                    this.y = c[1];
                    this.z = c[2];
                }
            }
            else if (CZMAP.Types.isNumber(x)) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }
        /**
         * 克隆当前对象
         */
        clone() {
            return new GeoPoint(this);
        }
        /**
         * 获取几何的坐标点
         */
        getCoordinates() {
            this._coordinates[0] = this.x;
            this._coordinates[1] = this.y;
            this._coordinates[2] = this.z;
            return this._coordinates;
        }
        /**
         * 获取几何类型
         */
        getGeometryType() {
            return CZMAP.GeometryType.POINT;
        }
        /**
         * 对当前对象应用坐标变换
         * @abstract
         * @param {TransformProc} proc Transform.
         */
        applyTransform(proc, opt_this) {
            this._box.setEmtpty();
            const c = this.getCoordinates();
            proc.call(opt_this, c, c);
            this.x = c[0];
            this.y = c[1];
            this.z = c[2];
        }
        /**
         * 计算包围盒
         * @override
         * @abstract
         */
        computeBox() {
            this._box.setEmtpty();
            this._box.mergeXYZ(this.x, this.y, this.z);
        }
    }
    CZMAP.GeoPoint = GeoPoint;
})(CZMAP || (CZMAP = {}));
/// <reference path="Geometry.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 几何————多边形对象
     */
    class GeoPolygon extends CZMAP.Geometry {
        constructor(polygon) {
            super();
            ///
            this._coordinates = [];
            ///
            if (polygon instanceof GeoPolygon)
                this._coordinates = CZMAP.deepCopy(polygon.coordinates);
            else if (CZMAP.Types.isArray(polygon))
                this._coordinates = CZMAP.deepCopy(polygon);
            else if (CZMAP.Types.isObject(polygon)) {
                const g = polygon;
                if (g.type.toLowerCase() === CZMAP.GeometryType.POLYGON) {
                    this._coordinates = CZMAP.deepCopy(g.coordinates);
                }
            }
        }
        get coordinates() {
            return this._coordinates;
        }
        /**
         * 克隆当前对象
         */
        clone() {
            return new GeoPolygon(this);
        }
        /**
         * 获取几何的坐标点
         */
        getCoordinates() {
            return this._coordinates;
        }
        /**
         * 获取几何类型
         */
        getGeometryType() {
            return CZMAP.GeometryType.POLYGON;
        }
        /**
         * 对当前对象应用坐标变换
         * @abstract
         * @param {TransformProc} proc Transform.
         */
        applyTransform(proc, opt_this) {
            this._box.setEmtpty();
            const c = this._coordinates;
            c.forEach(r => {
                r.forEach(p => {
                    proc.call(opt_this, p, p);
                });
            });
        }
    }
    CZMAP.GeoPolygon = GeoPolygon;
})(CZMAP || (CZMAP = {}));
/// <reference path="Geometry.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 几何————线对象
     */
    class GeoPolyline extends CZMAP.Geometry {
        constructor(polyline) {
            super();
            /**
             * 坐标序列
             */
            this._coordinates = [];
            ///
            if (polyline instanceof GeoPolyline)
                this._coordinates = CZMAP.deepCopy(polyline.coordinates);
            else if (CZMAP.Types.isArray(polyline))
                this._coordinates = CZMAP.deepCopy(polyline);
            else if (CZMAP.Types.isObject(polyline)) {
                const g = polyline;
                if (g.type.toLowerCase() === CZMAP.GeometryType.POLYLINE ||
                    g.type.toLowerCase() === "linestring") {
                    this._coordinates = CZMAP.deepCopy(g.coordinates);
                }
            }
        }
        get coordinates() {
            return this._coordinates;
        }
        /**
         * 克隆当前对象
         */
        clone() {
            return new GeoPolyline(this);
        }
        /**
         * 获取几何的坐标点
         */
        getCoordinates() {
            return this._coordinates;
        }
        /**
         * 获取几何类型
         */
        getGeometryType() {
            return CZMAP.GeometryType.POLYLINE;
        }
        /**
         * 对当前对象应用坐标变换
         * @abstract
         * @param {TransformProc} proc Transform.
         */
        applyTransform(proc, opt_this) {
            this._box.setEmtpty();
            const c = this._coordinates;
            c.forEach(p => {
                proc.call(opt_this, p, p);
            });
        }
    }
    CZMAP.GeoPolyline = GeoPolyline;
})(CZMAP || (CZMAP = {}));
/// <reference path="Geometry.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 几何————圆
     */
    class GeoRectangle extends CZMAP.Geometry {
        constructor(cc, max) {
            super();
            this._min = [0, 0, 0];
            this._max = [0, 0, 0];
            /// GeoRectangle
            if (cc instanceof GeoRectangle) {
                const gr = cc;
                CZMAP.copyPoint(gr.min, this._min);
                CZMAP.copyPoint(gr.max, this._max);
            }
            /// Point
            else if (CZMAP.Types.isArray(cc)) {
                CZMAP.copyPoint(cc, this._min);
                CZMAP.copyPoint(max, this._max);
            }
            /// GeometryLike
            else if (CZMAP.Types.isObject(cc)) {
                const g = cc;
                if (g.type.toLowerCase() === CZMAP.GeometryType.RECTANGLE) {
                    CZMAP.copyPoint(g.coordinates[0], this._min);
                    CZMAP.copyPoint(g.coordinates[1], this._max);
                }
            }
            this.fitMinMax();
        }
        /**
         * 自动翻转最大最小值
         */
        fitMinMax() {
            const [x0, y0, z0] = this._min;
            const [x1, y1, z1] = this._max;
            if (x0 > x1) {
                this._min.x = x1;
                this._max.x = x0;
            }
            if (y0 > y1) {
                this._min.y = y1;
                this._max.y = y0;
            }
            if (z0 > z1) {
                this._min.z = z1;
                this._max.z = z0;
            }
        }
        /**
         * 获取圆的中心点
         */
        get min() { return this._min; }
        /**
         * 获取圆的半径
         */
        get max() { return this._max; }
        /**
         * 克隆当前对象
         */
        clone() {
            return new GeoRectangle(this);
        }
        /**
         * 获取几何的坐标点
         */
        getCoordinates() {
            const c = GeoRectangle._coords;
            CZMAP.copyPoint(this._min, c[0]);
            CZMAP.copyPoint(this._max, c[1]);
            return c;
        }
        /**
         * 获取几何类型
         */
        getGeometryType() {
            return CZMAP.GeometryType.RECTANGLE;
        }
        /**
         * 对当前对象应用坐标变换
         * @abstract
         * @param {TransformProc} proc Transform.
         */
        applyTransform(proc, opt_this) {
            this._box.setEmtpty();
            proc.call(opt_this, this._min, this._min);
            proc.call(opt_this, this._max, this._max);
        }
        /**
         * 计算包围盒
         * @override
         * @abstract
         */
        computeBox() {
            this._box.setEmtpty();
            this._box.mergePoint(this._min);
            this._box.mergePoint(this._max);
        }
    }
    ///
    GeoRectangle._coords = [[0, 0, 0], [0, 0, 0]];
    CZMAP.GeoRectangle = GeoRectangle;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 一些简单数据对象
     */
    /**
     * 复制点
     * @param src 待复制的对象
     * @param opt 输出目标
     */
    function copyPoint(src, opt) {
        return createOrUpdatePoint(src[0], src[1], src[2], opt);
    }
    CZMAP.copyPoint = copyPoint;
    function comparePoint(src, tar) {
        return src[0] === tar[0] && src[1] === tar[1] && src[2] === tar[2];
    }
    CZMAP.comparePoint = comparePoint;
    function createEmptyPoint() {
        return new Array(3);
    }
    CZMAP.createEmptyPoint = createEmptyPoint;
    function createOrUpdatePoint(x, y, z, opt_point) {
        if (!opt_point) {
            opt_point = [x, y, z];
        }
        else {
            opt_point[0] = x;
            opt_point[1] = y;
            opt_point[2] = z;
        }
        ///
        return opt_point;
    }
    CZMAP.createOrUpdatePoint = createOrUpdatePoint;
    function forEachPoints(coordinates, callback) {
        if (!Array.isArray(coordinates[0])) {
            callback(coordinates);
        }
        else {
            coordinates.forEach((ss) => forEachPoints(ss, callback));
        }
    }
    CZMAP.forEachPoints = forEachPoints;
    function mapCoordinates(coordinates, callback) {
        if (!Array.isArray(coordinates[0])) {
            return callback(coordinates);
        }
        else {
            return coordinates.map((ss) => mapCoordinates(ss, callback));
        }
    }
    CZMAP.mapCoordinates = mapCoordinates;
    function defineArrayProperty(key, index) {
        Object.defineProperty(Array.prototype, key, {
            get: function () { return CZMAP.defaultValue(this[index], 0); },
            set: function (v) { this[index] = v; }
        });
    }
    defineArrayProperty('x', 0);
    defineArrayProperty('y', 1);
    defineArrayProperty('z', 2);
    defineArrayProperty('minx', 0);
    defineArrayProperty('miny', 1);
    defineArrayProperty('maxx', 2);
    defineArrayProperty('maxy', 3);
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class GraphArc {
        constructor(start, end, length) {
            this.mStart = 0;
            this.mEnd = 0;
            this.mLength = 0;
            this.mEnable = true;
            this.mStart = start;
            this.mEnd = end;
            this.mLength = length;
        }
        get isEnable() { return this.mEnable; }
        set isEnable(enable) { this.mEnable = enable; }
        get length() { return this.mLength; }
        get startVertex() { return this.mStart; }
        get endVertex() { return this.mEnd; }
    }
    CZMAP.GraphArc = GraphArc;
    class GraphVertex {
        constructor(pt) {
            this.mStartArcs = [];
            this.mEndArcs = [];
            this.mPoint = pt;
        }
        get startArcs() { return this.mStartArcs; }
        get endArcs() { return this.mEndArcs; }
        get point() { return this.mPoint; }
    }
    CZMAP.GraphVertex = GraphVertex;
    class Graph {
        constructor(t) {
            this.mVertices = [];
            this.mArcs = [];
            this.mPoints = new CZMAP.GridPointMap(t);
        }
        /// 
        init(tol) {
            this.mPoints.setTolerance(tol);
            this.mVertices.length = 0;
            this.mArcs.length = 0;
        }
        // begin graph constructing methods
        /**
        * add vertex to a grap
        */
        addVertex(pt) {
            const result = this.mPoints.add(pt);
            if (!result.exist)
                this.mVertices.push(new GraphVertex(pt));
            ///
            return result;
        }
        /**
        * add edge to a graph
        */
        addArc(startVertex, endVertex, length) {
            this.mArcs.push(new GraphArc(startVertex, endVertex, length));
            const edgeIdx = this.mArcs.length - 1;
            this.mVertices[startVertex].mStartArcs.push(edgeIdx);
            this.mVertices[endVertex].mEndArcs.push(edgeIdx);
            return edgeIdx;
        }
        /// 
        enableArc(arc, enable) {
            this.mArcs[arc].mEnable = enable;
        }
        enableVertex(pt, enable) {
            const gv = this.mVertices[pt];
            for (let i = 0; i < gv.mEndArcs.length; ++i) {
                this.mArcs[gv.mEndArcs[i]].mEnable = enable;
            }
            for (let i = 0; i < gv.mStartArcs.length; ++i) {
                this.mArcs[gv.mStartArcs[i]].mEnable = enable;
            }
        }
        ///
        vertexCount() { return this.mVertices.length; }
        vertex(idx) { return this.mVertices[idx]; }
        ///
        arcCount() { return this.mArcs.length; }
        arc(idx) { return this.mArcs[idx]; }
        /**
        * find vertex by point
        * \return vertex index
        */
        findVertex(pt) {
            return this.mPoints.find(pt);
        }
        /// 
        clear() {
            this.mVertices.clear();
            this.mArcs.clear();
            this.mPoints.clear();
        }
    }
    CZMAP.Graph = Graph;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function getLine(g, arcs) {
        const pts = [];
        const size = arcs.length;
        for (let i = 0; i < size; ++i) {
            const arc = g.arc(arcs[i]);
            if (i == 0) {
                pts.push(g.vertex(arc.startVertex).point);
            }
            pts.push(g.vertex(arc.endVertex).point);
        }
        return pts;
    }
    class GraphAnalyzer {
        /// 
        setStartEnd(start, end) {
            this.mPassPoints = [start, end];
        }
        ///
        setPassPoints(pts) {
            this.mPassPoints = pts;
        }
        /// 
        doAnalysis(g) {
            ///
            if (this.mPassPoints.length < 2)
                return;
            const pts = [];
            for (let i = 0; i < this.mPassPoints.length; ++i) {
                pts[i] = g.findVertex(this.mPassPoints[i]);
                /// 找不到必经点
                if (pts[i] == -1)
                    return;
            }
            const abortArcs = new Set();
            /// 获取最短路径
            const result = GraphAnalyzer.shortestPath2(g, abortArcs, pts);
            if (!result)
                return;
            ///
            const path = getLine(g, result.arcs);
            return { path, distance: result.cost };
        }
        /// dijkstra 算法
        static dijkstra(src, abortArc, start) {
            const vnum = src.vertexCount();
            const costs = new Array(vnum);
            costs.fill(Number.MAX_VALUE, 0, vnum);
            costs[start] = 0.0;
            const arcs = new Array(vnum);
            arcs.fill(-1, 0, vnum);
            const not_begin = [];
            not_begin.push([0.0, start]);
            while (not_begin.length > 0) {
                const [curCost, curVertex] = not_begin.pop();
                // edge index list
                const l = src.vertex(curVertex).startArcs;
                l.forEach(arcIdx => {
                    if (abortArc.has(arcIdx))
                        return;
                    const arc = src.arc(arcIdx);
                    if (!arc.isEnable)
                        return;
                    const cost = arc.length + curCost;
                    if (cost >= costs[arc.endVertex])
                        return;
                    ///
                    costs[arc.endVertex] = cost;
                    arcs[arc.endVertex] = arcIdx;
                    not_begin.push([cost, arc.endVertex]);
                });
            }
            return arcs;
        }
        /// 计算最短路径树
        static shortestTree(src, abortArc, start) {
            return undefined;
        }
        /// 计算最短路径
        static shortestPath(src, abortArc, start, end) {
            const tree = GraphAnalyzer.dijkstra(src, abortArc, start);
            if (tree[end] == -1)
                return;
            const arcs = [];
            let cost = 0;
            while (end != start) {
                const arcIdx = tree[end];
                if (arcIdx == -1)
                    return;
                const arc = src.arc(arcIdx);
                arcs.push(arcIdx);
                cost += arc.length;
                ///
                end = arc.startVertex;
            }
            arcs.reverse();
            return { arcs, cost };
        }
        /// 计算最短路径
        static shortestPath2(src, abortArc, pts) {
            let cost = 0;
            const arcs = [];
            for (let k = 1; k < pts.length; ++k) {
                const start = pts[k - 1];
                const stop = pts[k];
                /// 
                if (start == stop) {
                    continue;
                }
                ///
                const sub = GraphAnalyzer.shortestPath(src, abortArc, start, stop);
                if (!sub) {
                    arcs.clear();
                    return;
                }
                cost += sub.cost;
                arcs.push(...sub.arcs);
            }
            ///
            return { arcs, cost };
        }
    }
    CZMAP.GraphAnalyzer = GraphAnalyzer;
    ;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let GraphDirection;
    (function (GraphDirection) {
        GraphDirection[GraphDirection["ForwardDirection"] = 1] = "ForwardDirection";
        GraphDirection[GraphDirection["ReverseDirection"] = 2] = "ReverseDirection";
        GraphDirection[GraphDirection["DoubleDirection"] = 3] = "DoubleDirection";
    })(GraphDirection = CZMAP.GraphDirection || (CZMAP.GraphDirection = {}));
    ;
    function measureLine(a, b, isLonglat) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = CZMAP.Parse.parseNumber(a.z - b.z);
        return Math.sqrt(x * x + y * y + z * z);
    }
    function toCartesian(pt, result) {
        return Cesium.Cartesian3.fromElements(pt.x, pt.y, pt.z, result);
    }
    class GraphBuilder {
        // 
        //RasterBlock mWeightDS;
        constructor(tolerance = 1e-6, isLonglat = true) {
            this.mGraph = new CZMAP.Graph(tolerance);
            this.mIsLongLat = isLonglat;
        }
        /// 初始化，或者重新初始化
        setParam(tolerance = 1e-6, isLonglat = true) {
            this.mGraph.init(tolerance);
            this.mIsLongLat = isLonglat;
        }
        /// 设置权重数据集
        //setWeightData(const RasterBlock& ds) { mWeightDS = ds; }
        /// 添加正常的弧段
        pushLine(p1, p2, dt = GraphDirection.DoubleDirection, weight = 1.0) {
            const idx1 = this.mGraph.addVertex(p1).id;
            const idx2 = this.mGraph.addVertex(p2).id;
            if (idx1 == idx2)
                return;
            const distance = measureLine(p1, p2, this.mIsLongLat) * weight;
            if (dt & GraphDirection.ForwardDirection) {
                this.mGraph.addArc(idx1, idx2, distance);
            }
            if (dt & GraphDirection.ReverseDirection) {
                this.mGraph.addArc(idx2, idx1, distance);
            }
        }
        pushLines(points, dt = GraphDirection.DoubleDirection, weight = 1.0) {
            let p1, p2;
            let p1idx, p2idx;
            points.forEach((pt, i) => {
                p1 = pt;
                p1idx = this.mGraph.addVertex(p1).id;
                if (i != 0 && p1idx != p2idx) {
                    const distance = measureLine(p1, p2, this.mIsLongLat) * weight;
                    if (dt & GraphDirection.ForwardDirection) {
                        this.mGraph.addArc(p1idx, p2idx, distance);
                    }
                    if (dt & GraphDirection.ReverseDirection) {
                        this.mGraph.addArc(p2idx, p1idx, distance);
                    }
                }
                p2 = p1;
                p2idx = p1idx;
            });
        }
        /// 附加额外的点
        tieds(point, maxDistance = 0) {
            return this.tiePoint({ point, maxDistance, attachPoint: true });
        }
        tiePoint(option) {
            ///
            const exist = this.mGraph.findVertex(option.point);
            if (exist !== -1)
                return { id: exist, vertex: this.mGraph.vertex(exist) };
            const find = this.findNearestArc(option.point);
            if (!find)
                return;
            if (option.maxDistance > 0 && find.dist > option.maxDistance) {
                return;
            }
            const addArc = (p0, p1, dist) => {
                this.mGraph.addArc(p0, p1, dist);
                this.mGraph.addArc(p1, p0, dist);
            };
            const cross = this.mGraph.addVertex(find.p);
            if (cross.exist) {
                ///
                if (option.attachPoint) {
                    const added = this.mGraph.addVertex(option.point);
                    addArc(cross.id, added.id, find.dist);
                }
            }
            else {
                find.arc.isEnable = false;
                const idx0 = find.arc.startVertex;
                const idx1 = find.arc.endVertex;
                const idxo = cross.id;
                addArc(idx0, idxo, find.dist0);
                addArc(idx1, idxo, find.dist1);
                if (option.attachPoint) {
                    const added = this.mGraph.addVertex(option.point);
                    const idxp = added.id;
                    addArc(idxp, idxo, find.dist);
                }
            }
            return { id: cross.id, vertex: this.mGraph.vertex(cross.id) };
        }
        tieds2(pts, maxDistance = 0) {
            pts.forEach(pt => this.tieds(pt, maxDistance));
        }
        /// 设置避让点
        setAvoidPoints(pt, distance) {
            const size = this.mGraph.vertexCount();
            for (let i = 0; i < size; ++i) {
                const gv = this.mGraph.vertex(i);
                if (measureLine(gv.point, pt, this.mIsLongLat) > distance)
                    continue;
                this.mGraph.enableVertex(i, false);
            }
        }
        /// 
        get graph() { return this.mGraph; }
        findNearestArc(pt) {
            const count = this.mGraph.arcCount();
            if (count === 0)
                return;
            let resultArc;
            let resultDist = Number.MAX_VALUE;
            let resultDist0 = Number.MAX_VALUE;
            let resultDist1 = Number.MAX_VALUE;
            let resultPos;
            const t0 = new Cesium.Cartesian3();
            const t1 = new Cesium.Cartesian3();
            const t = toCartesian(pt);
            for (let i = 0; i < count; ++i) {
                const arc = this.mGraph.arc(i);
                const v0 = this.mGraph.vertex(arc.startVertex);
                const v1 = this.mGraph.vertex(arc.endVertex);
                const p0 = toCartesian(v0.point, t0);
                const p1 = toCartesian(v1.point, t1);
                const p = CZMAP.projectCartesian(p0, p1, t, new Cesium.Cartesian3());
                const d = Cesium.Cartesian3.distanceSquared(p0, p1);
                const d0 = Cesium.Cartesian3.distanceSquared(p, p0);
                const d1 = Cesium.Cartesian3.distanceSquared(p, p1);
                if (d0 > d || d1 > d) {
                    if (d0 > d1)
                        p1.clone(p);
                    else
                        p0.clone(p);
                }
                const tpd = Cesium.Cartesian3.distanceSquared(t, p);
                if (tpd < resultDist) {
                    resultDist = tpd;
                    resultDist0 = d0;
                    resultDist1 = d1;
                    resultArc = arc;
                    resultPos = p;
                }
            }
            resultDist = Math.sqrt(resultDist);
            resultDist0 = Math.sqrt(resultDist0);
            resultDist1 = Math.sqrt(resultDist1);
            return {
                arc: resultArc,
                p: resultPos,
                dist: resultDist,
                dist0: resultDist0,
                dist1: resultDist1,
            };
        }
    }
    CZMAP.GraphBuilder = GraphBuilder;
    ;
    class FeatureGraphBuilder extends GraphBuilder {
        constructor(tolerance = 10e-6, isLonglat = true) {
            super(tolerance, isLonglat);
            this.mDefaultDirection = GraphDirection.DoubleDirection;
        }
        /// 设置方向字段序号
        setDirectionFeild(name) { this.mDirectionField = name; }
        /// 设置权重字段序号
        setWeightField(name) { this.mWeightField = name; }
        /// 设置方向字段值
        setDirectionValue(doubleDir, forwardDir, reverseDir) {
            this.mDoubleDirectionValue = doubleDir;
            this.mForwardDirectionValue = forwardDir;
            this.mReverseDirectionValue = reverseDir;
        }
        /// 设置默认方向
        setDefaultDirection(dt) {
            this.mDefaultDirection = dt;
        }
        /// 将线条添加到图中
        pushFeature(f) {
            const g = f.geometry;
            if (!g)
                return;
            if (g.type == 'LineString') {
                this.pushLineString(g.coordinates, f.properties);
            }
            else if (g.type == 'MultiLineString') {
                g.coordinates.forEach(l => {
                    this.pushLineString(l, f.properties);
                });
            }
        }
        ///
        pushLineString(pts, props) {
            let directionType = this.mDefaultDirection;
            // What direction have feature?
            const str = props[this.mDirectionField];
            if (str == this.mDoubleDirectionValue) {
                directionType = GraphDirection.DoubleDirection;
            }
            else if (str == this.mForwardDirectionValue) {
                directionType = GraphDirection.ForwardDirection;
            }
            else if (str == this.mReverseDirectionValue) {
                directionType = GraphDirection.ReverseDirection;
            }
            const weight = props[this.mWeightField];
            const items = pts.map(pt => {
                const [x, y, z] = pt;
                return { x, y, z, properties: props };
            });
            this.pushLines(items, directionType, weight);
        }
    }
    CZMAP.FeatureGraphBuilder = FeatureGraphBuilder;
    ;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 图层对象的事件类型
     */
    class LayerEvents extends CZMAP.BaseObjectEvents {
    }
    LayerEvents.INIT = 'init';
    LayerEvents.DESTROY = 'destroy';
    CZMAP.LayerEvents = LayerEvents;
    class LayerProperty extends CZMAP.BaseObjectProperty {
    }
    LayerProperty.VISIBLE = 'visible';
    LayerProperty.OPACITY = 'opacity';
    LayerProperty.COLOR = 'color';
    CZMAP.LayerProperty = LayerProperty;
    /**
     * 图层
     * @abstract
     */
    class Layer extends CZMAP.BaseObject {
        /**
         * 构造函数
         * @param parent 父图层
         * @param option 图层的定义
         */
        constructor(parent, option) {
            super();
            /** 是否初始化 */
            this._inited = false;
            /** 图层是否就绪 */
            this._ready = Promise.resolve();
            /// 
            option = option || {};
            this.define = option.define || {};
            ///
            this._owner = CZMAP.Types.isDefined(parent) ? parent.owner : this;
            this._id = this._owner.nextID();
            this._parent = parent;
            this._name = CZMAP.Types.defaultValue(option.name, `Layer-${this._id}`);
            /// 设置可见性为false，在创建后会设置可见性
            this.set(LayerProperty.VISIBLE, false, true);
            this.set(LayerProperty.OPACITY, CZMAP.defaultValue(option.opacity, 1), true);
            this.set(LayerProperty.COLOR, CZMAP.defaultValue(option.color, 'white'), true);
            this.onProperty(LayerProperty.VISIBLE, this._handleVisibleChange, this);
        }
        /** 获取图层ID */
        get id() { return this._id; }
        /** 获取地图对象 */
        get map() { return this._owner.map; }
        /** 获取视图对象 */
        get view() { return this._owner.view; }
        /** 图层的所有者 */
        get owner() { return this._owner; }
        /** 父图层 */
        get parent() { return this._parent; }
        /** 图层的名称 */
        get name() { return this._name; }
        /** 获取图层类型名称 */
        get type() { return 'Layer'; }
        /** 图层是否就绪 */
        get ready() { return this._ready; }
        /** 返回图层是否可见 */
        get visible() { return this.get(LayerProperty.VISIBLE); }
        /**
         * 设置图层是否可见
         * @param {bool} visible
         */
        set visible(visible) { this.set(LayerProperty.VISIBLE, visible); }
        /** 获取图层透明度 */
        get opacity() { return this.get(LayerProperty.OPACITY); }
        /** 设置图层透明度 */
        set opacity(value) { this.set(LayerProperty.OPACITY, value); }
        /** 获取图层的颜色 */
        get color() { return this.get(LayerProperty.COLOR); }
        /** 设置图层的颜色 */
        set color(value) { this.set(LayerProperty.COLOR, value); }
        /** 返回子图层 */
        get children() { return []; }
        /** 是否文件夹图层 */
        isFolder() { return false; }
        /**
         * 设置是否可见
         * @param visible
         */
        setVisible(visible) { this.visible = visible; }
        /** 缩放到模型 */
        zoomTo(option) {
            this.flyTo(Object.assign({ duration: 0 }, option));
        }
        /** 飞到模型 */
        flyTo(option) {
            this.view.flyToBox(this.boundBox, option);
        }
        /** 初始化图层 */
        _init() {
            if (this._inited)
                return;
            this._inited = true;
            this._createInner();
            this.dispatchEvent(LayerEvents.INIT);
        }
        ;
        /** 准备ready */
        _prepReady() {
            this._ready = new Promise((resolve, reject) => {
                this._readyResolve = resolve;
                this._readyReject = reject;
            });
        }
        /** 销毁图层 */
        destroy() {
            this._destroyInner();
            this.dispatchEvent(LayerEvents.DESTROY);
        }
        ;
        /** 移除从节点上移除图层 */
        remove() {
            this.parent.removeLayer(this);
        }
        /**
         * 查找图层
         * @param name
         * @returns
         */
        findLayer(name) {
            let func;
            if (typeof name === 'string') {
                func = (layer) => layer.name == name;
            }
            else {
                func = name;
            }
            return enumLayers(this, Layer, 0, layer => func(layer) ? layer : undefined);
        }
        /** 遍历所有图层 */
        forEachLayers(callback) {
            enumLayers(this, Layer, 0, callback);
        }
        /**
         * 遍历指定类型的所有图层
         * @param type
         * @param callback
         */
        forEachTypeLayers(type, callback) {
            enumLayers(this, type, 0, callback);
        }
        /** @override */
        _disposeInternal() {
            super._disposeInternal();
            this.destroy();
        }
        /**
         * visible 事件
         * @param event
         */
        _handleVisibleChange(event) {
            ///
            const visible = this.visible;
            if (visible) {
                this._init();
            }
            ///
            this._onVisible(visible);
        }
        /** visible发生改变 */
        _onVisible(v) {
        }
    }
    CZMAP.Layer = Layer;
    /**
     * 枚举所有子图层
     * @param layer 待枚举的图层
     * @param type 枚举的图层类型
     * @param level 图层深度
     * @param callback 回调，返回值不过不为<true>则终止枚举
     * @returns
     */
    function enumLayers(layer, type, level, callback) {
        ///
        let result = undefined;
        const chs = layer.children.slice();
        for (let i = 0; i < chs.length; ++i) {
            const ch = chs[i];
            if (ch instanceof type) {
                result = callback(ch, level + 1);
                if (result)
                    return result;
            }
            //
            result = enumLayers(ch, type, level + 1, callback);
            if (result)
                return result;
        }
        ///
        return undefined;
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="Layer.ts" />
var CZMAP;
(function (CZMAP) {
    class MoveableLayerProperty extends CZMAP.LayerProperty {
    }
    MoveableLayerProperty.POSITION = 'position';
    MoveableLayerProperty.POSE = 'pose';
    MoveableLayerProperty.SCALE = 'scale';
    CZMAP.MoveableLayerProperty = MoveableLayerProperty;
    /**
     * 体数据图层
     */
    class MoveableLayer extends CZMAP.Layer {
        constructor(parent, option) {
            super(parent, option);
            /// 
            this.def(MoveableLayerProperty.POSITION, [0, 0, 0], CZMAP.Numbers.parseArray3, CZMAP.ArrayUtils.equals);
            this.def(MoveableLayerProperty.POSE, [0, 0, 0], CZMAP.Numbers.parseArray3, CZMAP.ArrayUtils.equals);
            this.def(MoveableLayerProperty.SCALE, [1, 1, 1], CZMAP.Numbers.parseArray3, CZMAP.ArrayUtils.equals);
            /// 设置可见性为false，在创建后会设置可见性
            this.onProperty(MoveableLayerProperty.POSITION, this._handlePositionChange, this);
            this.onProperty(MoveableLayerProperty.POSE, this._handlePoseChange, this);
            this.onProperty(MoveableLayerProperty.SCALE, this._handleScaleChange, this);
            /// 
            if (CZMAP.defined(option.position))
                this.position = option.position;
            if (CZMAP.defined(option.scale))
                this.scale = option.scale;
            if (CZMAP.defined(option.pose))
                this.pose = option.pose;
        }
        /** 位置属性 */
        get position() { return this.get(MoveableLayerProperty.POSITION); }
        set position(position) { this.set(MoveableLayerProperty.POSITION, position); }
        /** 姿态属性 */
        get pose() { return this.get(MoveableLayerProperty.POSE); }
        set pose(pose) { this.set(MoveableLayerProperty.POSE, pose); }
        /** 缩放比 */
        get scale() { return this.get(MoveableLayerProperty.SCALE); }
        set scale(scale) { this.set(MoveableLayerProperty.SCALE, scale); }
        /** 移动图层 */
        move(actions) {
        }
        /**  */
        _handlePositionChange(event) { this._notifyTransformChange(); }
        ;
        _handlePoseChange(event) { this._notifyTransformChange(); }
        ;
        _handleScaleChange(event) { this._notifyTransformChange(); }
        ;
        _notifyTransformChange() {
            window.cancelAnimationFrame(this._updateHandle);
            this._updateHandle = window.requestAnimationFrame(() => this._onTransformChange());
        }
        _onTransformChange() {
        }
    }
    CZMAP.MoveableLayer = MoveableLayer;
})(CZMAP || (CZMAP = {}));
/// <reference path="MoveableLayer.ts" />
var CZMAP;
(function (CZMAP) {
    class DecalLayer extends CZMAP.MoveableLayer {
        constructor(parent, option) {
            super(parent, option);
        }
    }
    CZMAP.DecalLayer = DecalLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class LayerRender extends CZMAP.Disposable {
        constructor(parent) {
            super();
            ///
            this._parent = parent;
            this._view = parent.map.view;
        }
        /**
         * 获取父对象
         */
        get parent() { return this._parent; }
        /** 获取视图对象 */
        get view() { return this._view; }
        /** 获取地图对象 */
        get map() { return this._view.map; }
        /** 是否可见 */
        get visible() { return this._visible; }
        /** 设置可见 */
        set visible(visible) {
            if (visible !== this._visible) {
                this._visible = visible;
                this._onVisibleChangle();
            }
        }
        /** 缩放图层 */
        zoomTo(option) {
            this.flyTo(Object.assign({ duration: 0 }, option));
        }
        /** 飞到图层 */
        flyTo(option) {
            this._view.flyToBox(this.box, option);
        }
        /** 销毁对象 */
        destroy() { }
        /** */
        _disposeInternal() {
            this.destroy();
        }
    }
    CZMAP.LayerRender = LayerRender;
})(CZMAP || (CZMAP = {}));
/// <reference path="LayerInner.ts" />
var CZMAP;
(function (CZMAP) {
    class FeatureRender extends CZMAP.LayerRender {
        /**
         */
        constructor(parent) {
            super(parent);
            ///
            this._init();
            /// 绑定事件
            this._initPropHandle();
        }
        /** 获取要素对象 */
        get featureLayer() { return this.parent; }
        /** 获取矢量图层 */
        get vectorLayer() { return this.featureLayer.parent; }
        /**
         * 获取要素
         * @see FeatureLayer.feature
         */
        get feature() { return this.featureLayer.feature; }
        /**
         * 获取几何对象
         * @see FeatureLayer.geometry
         */
        get geometry() { return this.featureLayer.geometry; }
        /**
         * 获取样式
         * @see FeatureLayer.style
         */
        get style() { return this.featureLayer.style; }
        /** 销毁对象 */
        destroy() {
            super.destroy();
            /// 解绑事件
            this._releasePropHandle();
            ///
            this._release();
        }
        /** 初始化属性绑定 */
        _initPropHandle() {
            ///
            this.parent.onProperty(CZMAP.FeatureLayerProperty.FEATURE, this._handleFeatureChange, this);
            this.parent.onProperty(CZMAP.FeatureLayerProperty.STYLE, this._handleStyleChange, this);
            /// 
            requestAnimationFrame(() => this.parent.notifyAll());
        }
        /** 释放事件句柄 */
        _releasePropHandle() {
            this.parent.unProperty(CZMAP.FeatureLayerProperty.FEATURE, this._handleFeatureChange, this);
            this.parent.unProperty(CZMAP.FeatureLayerProperty.STYLE, this._handleStyleChange, this);
            ///
            this._unlistenFeature();
            this._unlistenStyle();
        }
        /** 要素改变 */
        _handleFeatureChange(event) {
            this._listenFeature(this.feature);
        }
        /** 样式改变 */
        _handleStyleChange(event) {
            this._listenStyle(this.featureLayer.style);
        }
        /** 监听要素 */
        _listenFeature(feature) {
            this._unlistenFeature();
            const nfe = this.feature;
            nfe.onProperty(CZMAP.FeatureProperty.GEOMETRY, this._handleGeometryChange, this);
            nfe.notifyCurrent(CZMAP.FeatureProperty.GEOMETRY);
            this._handleFeature = nfe;
        }
        /** 结束监听要素 */
        _unlistenFeature() {
            if (this._handleFeature) {
                this._handleFeature.unProperty(CZMAP.FeatureProperty.GEOMETRY, this._handleGeometryChange, this);
                this._handleFeature = undefined;
            }
        }
        /** 监听样式 */
        _listenStyle(fstyle) {
            this._unlistenStyle();
            const on = (style, handle) => {
                if (!style)
                    return;
                style.on(CZMAP.BaseObjectEvents.PROPERTYCHANGE, handle, this);
                style.notifyAll();
            };
            this._handleStyle = fstyle;
            on(fstyle.stroke, this._handleStrokeStyle);
            on(fstyle.model, this._handleModelStyle);
            on(fstyle.label, this._handleLabelStyle);
            on(fstyle.icon, this._handleIconStyle);
            on(fstyle.wall, this._handleWallStyle);
        }
        _unlistenStyle() {
            if (!this._handleStyle)
                return;
            const un = (style, handle) => {
                if (!style)
                    return;
                style.un(CZMAP.BaseObjectEvents.PROPERTYCHANGE, handle, this);
            };
            const style = this._handleStyle;
            un(style.stroke, this._handleStrokeStyle);
            un(style.model, this._handleModelStyle);
            un(style.label, this._handleLabelStyle);
            un(style.icon, this._handleIconStyle);
            un(style.wall, this._handleWallStyle);
        }
        _handleLabelStyle(event) { }
        ;
        _handleIconStyle(event) { }
        ;
        _handleModelStyle(event) { }
        ;
        _handleStrokeStyle(event) { }
        _handleWallStyle(event) { }
        /** 通知样式 */
        _notifyStyle() {
            this.parent.notifyCurrent(CZMAP.FeatureLayerProperty.STYLE);
        }
        /** 投影坐标到当前地图坐标 */
        _transformCoordinates(pts) {
            return CZMAP.Transforms.transformCoordinates(pts, this.featureLayer.projection, this.parent.map.projection);
        }
    }
    CZMAP.FeatureRender = FeatureRender;
})(CZMAP || (CZMAP = {}));
/// <reference path="Layer.ts" />
var CZMAP;
(function (CZMAP) {
    let FeatureLayerProperty;
    (function (FeatureLayerProperty) {
        FeatureLayerProperty["FEATURE"] = "feature";
        FeatureLayerProperty["STYLE"] = "style";
    })(FeatureLayerProperty = CZMAP.FeatureLayerProperty || (CZMAP.FeatureLayerProperty = {}));
    /**
     * 要素对象
     */
    class FeatureLayer extends CZMAP.Layer {
        /**
         * 构造一个新的要素
         * @param parent 父对象，FeatureCollectionLayer
         * @param data 数据
         * @param data.name 图层的名称
         * @param data.feature 要素
         * @param data.style
         */
        constructor(parent, options) {
            super(parent, options);
            this._box = new CZMAP.BoundingBox();
            ///
            if (options.feature instanceof CZMAP.Feature) {
                this.feature = options.feature;
            }
            else {
                this.feature = new CZMAP.Feature(options.feature);
            }
            ///
            this.style = options.style;
            /// 
            this.onProperty(FeatureLayerProperty.FEATURE, () => {
                this._box = this.geometry.box;
                const min = this.transformCoordinates(this._box.getMin());
                const max = this.transformCoordinates(this._box.getMax());
                this._box.setMinMax(min, max);
            });
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'FeatureLayer'; }
        /**
         * 图层的父对象
         */
        get parent() { return super.parent; }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            return Object.freeze(this._box);
        }
        /**
         * 显示隐藏标注
         * @param {*} enable
         * @api
         */
        set enableLabel(enable) {
            if (this.style.label)
                this.style.label.visible = enable;
        }
        /**
         * 是否显示图标
         * @return {Boolean}
         */
        get enableLabel() { return (this.style.label) ? this.style.visible : false; }
        /**
         * 显示隐藏图标
         * @param {Boolean} enable
         * @api
         */
        set enableIcon(enable) {
            if (this.style.icon)
                this.style.visible = enable;
        }
        /**
         * 是否显示图标
         */
        get enableIcon() { return (this.style.icon) ? this.style.icon.visible : false; }
        /**
         *
         */
        get feature() { return this.get(FeatureLayerProperty.FEATURE); }
        set feature(feature) {
            ///
            if (!(feature instanceof CZMAP.Feature)) {
                feature = new CZMAP.Feature(feature);
            }
            this.set(FeatureLayerProperty.FEATURE, feature);
        }
        /**
         * 是否启用聚合
         */
        get enableCluster() { return this.parent.enableCluster; }
        /**
         * 获取图层的投影
         */
        get projection() { return this.parent.projection; }
        /**
         * 要素的样式
         */
        get style() { return this.get(FeatureLayerProperty.STYLE); }
        set style(style) { this.set(FeatureLayerProperty.STYLE, style); }
        /**
         * 获取要素的属性表
         * @api
         */
        get properties() { return this.feature.properties; }
        /**
         * 获取要素的几何
         * @api
         */
        get geometry() { return this.feature.geometry; }
        _onVisible(v) {
            super._onVisible(v);
            const render = this.render;
            if (render)
                render.visible = v;
        }
        /**
         * 将当前图层坐标系坐标转换为地图坐标系
         * @param pts 待投影的坐标
         * @returns 投影后的坐标
         */
        transformCoordinates(pts) {
            return CZMAP.Transforms.transformCoordinates(pts, this.projection, this.map.projection);
        }
    }
    CZMAP.FeatureLayer = FeatureLayer;
})(CZMAP || (CZMAP = {}));
/// <reference path="MoveableLayer.ts" />
var CZMAP;
(function (CZMAP) {
    class FlowsLayer extends CZMAP.MoveableLayer {
        constructor(parent, option) {
            super(parent, option);
        }
        /**
         * 获取图层类型名称
         * @override
         */
        get type() { return 'FlowsLayer'; }
    }
    CZMAP.FlowsLayer = FlowsLayer;
})(CZMAP || (CZMAP = {}));
/// <reference path="Layer.ts" />
var CZMAP;
(function (CZMAP) {
    ;
    class FolderEvent extends CZMAP.Event {
        constructor(type, layer) {
            super(type);
            this.layer = layer;
        }
    }
    CZMAP.FolderEvent = FolderEvent;
    class FolderEvents extends CZMAP.LayerEvents {
    }
    FolderEvents.CHILD_ADDED = 'child-added';
    FolderEvents.CHILD_REMOVED = 'child-removed';
    CZMAP.FolderEvents = FolderEvents;
    /**
     * 目录图层
     */
    class Folder extends CZMAP.Layer {
        /**
         * 构造函数
         * @param {Folder} parent
         * @param {String} define.name 图层名称
         */
        constructor(parent, options) {
            super(parent, options);
            ///
            this._children = [];
            ///
            this.onProperty(CZMAP.LayerProperty.VISIBLE, this._handleFolderVisibleChanged, this);
        }
        createLayer(creator, options) {
            let creator_type;
            if (typeof creator === 'string') {
                creator_type = this.owner.getCreator(creator);
            }
            else {
                creator_type = creator;
            }
            if (typeof creator_type !== 'function') {
                console.error(`不支持的图层类型或者构造器`, creator);
                return;
            }
            ///
            const lyr = new creator_type(this, options);
            if (lyr == null)
                return;
            ///
            this._children.push(lyr);
            this.dispatchEvent(new FolderEvent(FolderEvents.CHILD_ADDED, lyr));
            /// 
            lyr.onProperty(CZMAP.LayerProperty.VISIBLE, this._handleChildVisibleChanged, this);
            lyr.setVisible(CZMAP.defaultValue(options.visible, true));
            ///
            return lyr;
        }
        /**
         * 删除图层
         */
        removeLayer(lyr) {
            if (lyr instanceof CZMAP.Layer) {
                lyr = this._children.indexOf(lyr);
                if (lyr == -1)
                    return;
            }
            if (!CZMAP.Types.isNumber(lyr)) {
                return;
            }
            let old = this._children[lyr];
            this._children.splice(lyr, 1);
            ///
            this.dispatchEvent(new FolderEvent(FolderEvents.CHILD_REMOVED, old));
            /// 销毁图层内部资源
            old.destroy();
        }
        /**
         * 移除所有图层
         */
        removeAllLayer() {
            let ch = this._children.slice(0);
            ch.forEach(e => this.removeLayer(e));
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'Folder'; }
        /**
         * 是否文件夹图层
         */
        isFolder() { return true; }
        /**
         * 返回子图层
         * @override
         */
        get children() {
            return this._children.slice(0);
        }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            const box = new CZMAP.BoundingBox();
            this._children.forEach(ch => box.mergeBox(ch.boundBox));
            return box;
        }
        /** @override */
        _createInner() {
        }
        /** @override */
        _destroyInner() {
            this.removeAllLayer();
        }
        /** 图层可见性发生改变 */
        _handleFolderVisibleChanged(event) {
            /// 
            if (event.data && event.data.cascade)
                return;
            ///
            const visible = this.visible;
            this.children.forEach(e => e.visible = visible);
        }
        /** 子图层可见性发生改变 */
        _handleChildVisibleChanged(event) {
            const visible = event.target.get(event.key);
            if (visible) {
                this.set(CZMAP.LayerProperty.VISIBLE, visible, false, { cascade: true });
            }
        }
    }
    CZMAP.Folder = Folder;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class FoliageLayer extends CZMAP.Layer {
        constructor(parent, option) {
            var _a;
            super(parent, option);
            this._foliages = [];
            this._box = new CZMAP.BoundingBox();
            this._foliages = CZMAP.deepAssign((_a = option.foliages) !== null && _a !== void 0 ? _a : []);
            this._updateBoundBox();
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'FoliageLayer'; }
        get boundBox() {
            return this._box;
        }
        addItem(mesh, item) {
            const foliage = this._getFoliage(mesh, true);
            foliage.items.push(item);
            this._addItems(FoliageLayer.asItemDetail(mesh, -1, [item]));
            this._updateBoundBox();
        }
        updateItem(mesh, id, item) {
            let foliage = this._getFoliage(mesh);
            if (!foliage)
                return;
            if (id < 0 || id >= foliage.items.length)
                return;
            foliage.items[id] = item;
            this._updateItems(FoliageLayer.asItemDetail(mesh, id, [item]));
            this._updateBoundBox();
        }
        removeItem(mesh, id) {
            let foliage = this._getFoliage(mesh);
            if (!foliage)
                return;
            if (id < 0 || id >= foliage.items.length)
                return;
            foliage.items.splice(id, 1);
            this._removeItems([{ mesh, id }]);
            this._updateBoundBox();
        }
        getItems(mesh) {
            var _a;
            return (_a = this._foliages.find(fo => fo.mesh === mesh)) === null || _a === void 0 ? void 0 : _a.items;
        }
        getFoliages() {
            return this._foliages;
        }
        _getFoliage(mesh, create = false) {
            let foliage = this._foliages.find(fo => fo.mesh === mesh);
            if (!foliage && create) {
                foliage = { mesh, items: [] };
                this._foliages.push(foliage);
            }
            return foliage;
        }
        _updateBoundBox() {
            this._box.setEmtpty();
            this._foliages.forEach(f => f.items.forEach(i => this._box.mergePoint(i.position)));
        }
        static asItemDetail(mesh, id, items) {
            return items.map(item => Object.assign({ mesh, id }, item));
        }
    }
    CZMAP.FoliageLayer = FoliageLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class LayerManagerEvents extends CZMAP.FolderEvents {
    }
    LayerManagerEvents.LAYER_ADDED = 'layer-added';
    LayerManagerEvents.LAYER_REMOVED = 'layer-removed';
    LayerManagerEvents.LAYER_VISIBLE_CHANGED = 'layer-changed';
    CZMAP.LayerManagerEvents = LayerManagerEvents;
    /**
     * 图层管理器
     */
    class LayerManager extends CZMAP.Folder {
        /**
         *
         */
        constructor(map) {
            super(null, { name: 'LayerManager' });
            /** 图层构建器 */
            this._creators = new Map();
            /** 地形图层列表 */
            this._terrains = [];
            /// 
            this._onLayerAdded = EmptyFuncton;
            this._onLayerRemoved = EmptyFuncton;
            this._onLayerVisible = EmptyFuncton;
            ///
            this._next_id = 0;
            this._map = map;
            ///
            this._handleEvents(this);
            ///
            this._register("folder", CZMAP.Folder);
            this._register("vector", CZMAP.VectorLayer);
            this._register("point", CZMAP.VectorLayer);
            this._register('terrain', CZMAP.TerrainLayer);
        }
        /**
         * 获取地图对象
         */
        get map() { return this._map; }
        /**
         * 获取视图对象
         */
        get view() { return this._map.view; }
        /**
         * 获取图层类型名称
         */
        get type() { return 'LayerManager'; }
        /**
         * 获取地形图层
         */
        get terrains() {
            return this._terrains.slice();
        }
        /**
         * 获取激活的地形
         */
        get activeTerrain() {
            const ts = this._terrains;
            if (ts.length == 0)
                return undefined;
            if (ts.length == 1)
                return ts[0];
            const t = this._terrains.find(t => t.visible);
            if (t)
                return t;
            ///
            return ts[0];
        }
        /**
         * 下一个图层ID
         */
        nextID() {
            return this._next_id++;
        }
        /** 获取图层创建器 */
        getCreator(type) { return this._creators.get(type); }
        ;
        /** 注册图层创建器 */
        _register(type, creator) {
            this._creators.set(type, creator);
        }
        /** @deprecated */
        get onLayerAdded() { return this._onLayerAdded; }
        /** @deprecated */
        get onLayerRemoved() { return this._onLayerRemoved; }
        /** @deprecated */
        get onLayerVisible() { return this._onLayerVisible; }
        /** @deprecated */
        set onLayerAdded(cb) { this._onLayerAdded = CZMAP.Types.defaultValue(cb, EmptyFuncton); }
        /** @deprecated */
        set onLayerRemoved(cb) { this._onLayerRemoved = CZMAP.Types.defaultValue(cb, EmptyFuncton); }
        /** @deprecated */
        set onLayerVisible(cb) { this._onLayerVisible = CZMAP.Types.defaultValue(cb, EmptyFuncton); }
        _handleEvents(layer) {
            layer.on(CZMAP.FolderEvents.CHILD_ADDED, this._handleLayerAdded, this);
            layer.on(CZMAP.FolderEvents.CHILD_REMOVED, this._handleLayerRemoved, this);
            layer.onProperty(CZMAP.LayerProperty.VISIBLE, this._handleLayerVisibleChange, this);
        }
        _unhandleEvents(layer) {
            layer.un(CZMAP.FolderEvents.CHILD_ADDED, this._handleLayerAdded, this);
            layer.un(CZMAP.FolderEvents.CHILD_REMOVED, this._handleLayerRemoved, this);
            layer.unProperty(CZMAP.LayerProperty.VISIBLE, this._handleLayerVisibleChange, this);
        }
        _handleLayerAdded(event) {
            const layer = event.layer;
            if (layer instanceof CZMAP.TerrainLayer) {
                layer.on(CZMAP.LayerEvents.CHANGE, this._handleTerrainChange, this);
                this._terrains.push(layer);
            }
            /// 绑定事件
            this._handleEvents(layer);
            /// 触发事件
            this._onLayerAdded(layer);
            this.dispatchEvent(new CZMAP.FolderEvent(LayerManagerEvents.LAYER_ADDED, layer));
        }
        _handleLayerRemoved(event) {
            const layer = event.layer;
            if (layer instanceof CZMAP.TerrainLayer) {
                /// 当前地形被删除
                if (layer === this._terrain) {
                    this._terrain = undefined;
                    this._clearTerrain();
                }
                ///
                const index = this._terrains.indexOf(layer);
                if (index != -1) {
                    this._terrains.splice(index, 1);
                }
                layer.un(CZMAP.LayerEvents.CHANGE, this._handleTerrainChange, this);
            }
            /// 解绑事件
            this._unhandleEvents(layer);
            /// 触发事件
            this._onLayerRemoved(layer);
            this.dispatchEvent(new CZMAP.FolderEvent(LayerManagerEvents.LAYER_REMOVED, layer));
        }
        _handleLayerVisibleChange(event) {
            const layer = event.target;
            if (layer === this)
                return;
            ///
            this._onLayerVisible(layer);
            this.dispatchEvent(new CZMAP.FolderEvent(LayerManagerEvents.LAYER_VISIBLE_CHANGED, layer));
        }
        /**
         * 地形图层可见性改变事件
         * @param event
         * @returns
         */
        _handleTerrainChange(event) {
            const terrain = event.target;
            if (!terrain.visible) {
                this._terrain = undefined;
                this._clearTerrain();
                return;
            }
            /// 隐藏其他地形图层
            this._terrains.forEach(t => {
                if (t != terrain)
                    t.visible = false;
            });
            ///
            this._terrain = terrain;
            this._applyTerrain(terrain);
        }
        _clearTerrain() { }
        _applyTerrain(terrain) { }
    }
    CZMAP.LayerManager = LayerManager;
    function EmptyFuncton() { }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 默认合并函数
     * @param names
     */
    function DefaultMerge(names) {
        const mnames = [];
        for (var i = 0; i < names.length; ++i) {
            mnames.push({ name: names[i], index: [i] });
        }
        ///
        return mnames;
    }
    class ModelNode {
        constructor(item) {
            if (item) {
                this.node = item.id;
                this.box = CZMAP.BoundingBox.formString(item.box);
            }
        }
        static fromPoint(point) {
            const mn = new ModelNode();
            mn.box = CZMAP.BoundingBox.formCenterSize(point, [0, 0, 0]);
            return mn;
        }
    }
    CZMAP.ModelNode = ModelNode;
    let ModelDataFormat;
    (function (ModelDataFormat) {
        ModelDataFormat[ModelDataFormat["GLTF"] = 0] = "GLTF";
        ModelDataFormat[ModelDataFormat["OBJ"] = 1] = "OBJ";
        ModelDataFormat[ModelDataFormat["ZFCLS"] = 2] = "ZFCLS";
        ModelDataFormat[ModelDataFormat["TDTILES"] = 3] = "TDTILES";
    })(ModelDataFormat = CZMAP.ModelDataFormat || (CZMAP.ModelDataFormat = {}));
    class LineLabel {
        constructor(name, tar, labelstyle) {
            this.label = new Cesium.LabelGraphics({
                text: name,
                scale: 0.5,
                font: CZMAP.Types.defaultValue(labelstyle.font, '32px 黑体'),
                style: Cesium.LabelStyle.FILL,
                pixelOffset: CZMAP.CesiumAttrib.getCartesian2(labelstyle.offset),
                fillColor: CZMAP.CesiumAttrib.getColor(labelstyle.color, Cesium.Color.WHITE),
                outlineColor: CZMAP.CesiumAttrib.getColor(labelstyle.borderColor, Cesium.Color.BLACK),
                outlineWidth: CZMAP.CesiumAttrib.getNumber(labelstyle.borderWidth, 0),
                showBackground: true,
                backgroundColor: CZMAP.CesiumAttrib.getColor(labelstyle.backgroundColor, Cesium.Color.DARKGREY),
                horizontalOrigin: CZMAP.CesiumAttrib.getHorizontal(labelstyle.horizontalOrigin),
                verticalOrigin: CZMAP.CesiumAttrib.getVertical(labelstyle.vertitalOrigin),
                distanceDisplayCondition: CZMAP.CesiumAttrib.getDisplayDistance(labelstyle.visibleRange),
                scaleByDistance: CZMAP.CesiumAttrib.getNearFarScalar(labelstyle.scaleDistance),
                translucencyByDistance: CZMAP.CesiumAttrib.getNearFarScalar(labelstyle.fadeDistance),
            });
            const offset = labelstyle.lineOffset;
            const width = labelstyle.lineWidth;
            const color = CZMAP.CesiumAttrib.getColor(labelstyle.lineColor, Cesium.Color.RED);
            if (offset && width > 0) {
                const opt = {
                    show: true,
                    width: width,
                    material: color,
                    positions: []
                };
                if (Cesium.ArcType)
                    opt.arcType = Cesium.ArcType.NONE;
                else
                    opt.followSurface = false;
                this.line = new Cesium.PolylineGraphics(opt);
                this.offset = offset.slice();
                this.offset[0] /= 111000;
                this.offset[1] /= 111000;
            }
            else {
                this.offset = [0, 0, 0];
            }
            this.entity = new Cesium.Entity({
                name: name,
                show: labelstyle.visible,
            });
            this.entity.label = this.label;
            this.entity.polyline = this.line;
            this.tar = tar.slice();
        }
        update(matrix) {
            const tar = this.tar;
            const off = add(this.tar, this.offset);
            const p0 = Cesium.Cartesian3.fromElements(...tar);
            const p1 = Cesium.Cartesian3.fromElements(...off);
            Cesium.Matrix4.multiplyByPoint(matrix, p0, p0);
            Cesium.Matrix4.multiplyByPoint(matrix, p1, p1);
            this.entity.position = p1;
            if (this.line)
                this.line.positions = [p0, p1];
        }
    }
    /**
     * 3维模型类
     */
    class ModelLayer extends CZMAP.Folder {
        /**
         * @param {*} options
         */
        constructor(parent, options) {
            super(parent, options);
            this._box = new CZMAP.BoundingBox();
            ///
            this._show_child = false;
            /**
             * 模型列表
             */
            this._models = [];
            this._labels = [];
            this._modelOrientation = new Cesium.Quaternion();
            this._labelOrientation = new Cesium.Quaternion();
            this._modelMatrix4 = new Cesium.Matrix4();
            this._labelMatrix4 = new Cesium.Matrix4();
            this._updateHandle = 0;
            ///
            this._url = options.url;
            this._offset = CZMAP.ZFclsModel.parsePosition(options.offset, [0, 0, 0]);
            this._position = CZMAP.Types.isDefined(options.position) ? CZMAP.ZFclsModel.parsePosition(options.position) : undefined;
            this._pose = CZMAP.ZFclsModel.parsePosition(options.pose, [0, 0, 0]);
            this._scale = CZMAP.ZFclsModel.parsePosition(options.scale, [1, 1, 1]);
            //
            this.view3d = parent.map.view3d;
            this.scene = this.view3d.cesium.scene;
            ///
            this._labelStyle = options.label;
            if (this._labelStyle)
                this._enableLabel = this._labelStyle.visible;
            /// 
            this._flat = CZMAP.Parse.parseBoolean(options.flat);
            this._enableCluster = CZMAP.Parse.parseBoolean(options.enableCluster);
            this._expandChild = CZMAP.Parse.parseBoolean(options.expandChild);
            this._expandChildTree = CZMAP.Parse.parseBoolean(options.expandChildTree);
            this._expandLeafChild = CZMAP.Parse.parseBoolean(options.expandLeafChild);
            this._mergeChild = CZMAP.Types.defaultValue(options.mergeChild, DefaultMerge);
            this._prepReady();
            this._requestUpdateBoundBox();
        }
        /**
         * 添加模型
         * @param url 模型的URL
         */
        _addModel(url) {
            url += ((url.indexOf('?') !== -1) ? '&' : '?') + 'tts=' + new Date().getTime();
            /// 创建模型
            const model = Cesium.Model.fromGltf({
                url: url,
                incrementallyLoadTextures: true,
                scene: this.scene,
                show: this.visible,
                /// 启用高亮的shader
                color: new Cesium.Color(0.999, 0.999, 0.999),
            });
            /// 记录模型的所有着
            model.id = { _czmap_obj: this };
            this.scene.primitives.add(model);
            /// 
            this._models.push(model);
            /// 
            return model;
        }
        /**
         * 创建子图层
         * @param name
         * @param model
         * @param center
         */
        _createSubLayer(name, model, nodes, parent) {
            const bbox = CZMAP.BoundingBox.formString(this._zfclsInfo.box);
            const bcenter = bbox.getCenter();
            ///
            let entlabel;
            if (CZMAP.Types.isDefined(this._labelStyle) && nodes && nodes.length) {
                const box = new CZMAP.BoundingBox();
                nodes.forEach(e => {
                    box.mergeBox(e.box);
                });
                const ct = box.getCenter();
                ct[2] = box.maxz;
                sub(ct, bcenter, ct);
                const labelstyle = this._labelStyle;
                const label = new LineLabel(name, ct, labelstyle);
                entlabel = label.entity;
                ///
                this._labels.push(label);
                ///
                if (this.enableCluster)
                    this.view3d.clusterEntities.add(entlabel);
                else
                    this.view3d.entities.add(entlabel);
            }
            /// 
            parent = parent || this;
            /// 
            return parent.createLayer(CZMAP.SubModelLayer, {
                name: name,
                model,
                nodes,
                label: entlabel
            });
        }
        _createInner() {
            /// 
            const lowUrl = this._url.toLowerCase();
            /// 
            if (lowUrl.indexOf('.gltf') != -1 ||
                lowUrl.indexOf('.glb') != -1) {
                this._createOriginalModel();
                return;
            }
            /// 
            const zspos = lowUrl.indexOf('/zs/data/');
            if (zspos != -1) {
                /// 
                const address = this._url.substr(0, zspos);
                const sname = this._url.substr(zspos + 9);
                fetch(this._url + '?f=json').then(e => { if (e.ok)
                    return e.json(); })
                    .then(e => {
                    if (!CZMAP.Types.isDefined(e))
                        return;
                    ///
                    const _model_type = e.attributes.MiddleWare.toLowerCase();
                    switch (_model_type) {
                        case 'obj':
                            this._createObjModel(`${address}/zs/obj/${sname}`);
                            break;
                        case 'zmap':
                            this._createZfclsModel(`${address}/zs/zfcls/${sname}`);
                            break;
                        case '': break;
                    }
                });
            }
            else if (lowUrl.indexOf('/zs/obj/') != -1) {
                this._createObjModel();
            }
            else if (lowUrl.indexOf('/zs/zfcls/') != -1) {
                this._createZfclsModel();
            }
        }
        /** 初始化模型的ready */
        _initModelReady() {
            const all = [];
            this._models.forEach(e => all.push(e.readyPromise));
            Cesium.when.all(all)
                .then(() => this._readyResolve(), () => this._readyReject())
                .then(() => this._models.forEach(e => e.activeAnimations.addAll({ loop: Cesium.ModelAnimationLoop.REPEAT })));
        }
        _createOriginalModel() {
            this._format = ModelDataFormat.GLTF;
            this._addModel(this._url);
            this._updatePositionAndPose(true);
            this._initModelReady();
        }
        _createObjModel(url) {
            this._format = ModelDataFormat.OBJ;
            ///
            if (!url)
                url = this._url;
            this._url2 = url;
            fetch(url + '/files/zmapgltf.json')
                .then(e => {
                if (e.ok)
                    return e.json();
                else
                    throw '404';
            })
                .then(data => {
                if (!this._position)
                    this._position = CZMAP.ZFclsModel.parsePosition(data.position);
                if (!Array.isArray(data.children))
                    return;
                if (data.children.length > 1)
                    this._show_child = true;
                ///
                for (let i = 0; i < data.children.length; ++i) {
                    const ch = data.children[i];
                    const ent = this._addModel(`${url}/files/${ch.url}`);
                    /// 展开
                    if (this._expandChild) {
                        let pos = ch.url.lastIndexOf('/');
                        let name = ch.url.substring(pos + 1);
                        pos = name.lastIndexOf('.');
                        if (pos != -1)
                            name = name.substring(0, pos);
                        ///
                        this._createSubLayer(name, ent, [ModelNode.fromPoint(this._position)]);
                    }
                }
                ///
                this._updatePositionAndPose(true);
                this._initModelReady();
            }).catch((e) => { console.error(e); });
        }
        /**
         * 加载zfcls模型数据
         * @param url
         */
        _createZfclsModel(url) {
            this._format = ModelDataFormat.ZFCLS;
            if (!url)
                url = this._url;
            this._url2 = url;
            /// 请求模型树
            fetch(url + '/info').then(e => { if (e.ok)
                return e.json(); })
                .then(data => {
                /// 
                if (!data) {
                    console.warn(`请求模型数据失败，URL:'${url}'.`);
                    return;
                }
                ///
                const tddata = this._zfclsInfo = data;
                /// 解析信息中的位置信息
                if (!this._position)
                    this._position = CZMAP.ZFclsModel.parsePosition(tddata.position);
                /// 模型上图
                const fid = this._flat ? 'flat' : 0;
                const model = this._addModel(`${url}/model/${fid}/${tddata.offset}`);
                /// 显示子节点
                if (this._expandChild) {
                    if (this._expandChildTree) {
                        tddata.children.forEach(item => {
                            this._createModelTreeItem(model, this, item);
                        });
                    }
                    else {
                        ///
                        const items = CZMAP.ZFclsModel.tree2map(tddata.children);
                        const merged = CZMAP.ZFclsModel.merge(items, this._mergeChild);
                        ///
                        merged.forEach(m => {
                            ///
                            const nodes = m.items.map(item => new ModelNode(item));
                            this._createSubLayer(m.name, model, nodes);
                        });
                    }
                }
                ///
                this._updatePositionAndPose(true);
                this._initModelReady();
            });
        }
        _createModelTreeItem(model, parent, tditem) {
            ///
            const name = (tditem.name && tditem.name.length > 0) ? tditem.name : `Feature-${tditem.id}`;
            /// 简单要素
            if (!tditem.complex) {
                ///
                this._createSubLayer(name, model, [new ModelNode(tditem)], parent);
                return;
            }
            /// 
            while (tditem.children.length === 1 && tditem.name === tditem.children[0].name) {
                tditem = tditem.children[0];
            }
            /**
             * 是否包含复杂子要素
             * @param tditem
             * @returns
             */
            function hasComplexChild(tditem) {
                let has = false;
                tditem.children.forEach(ch => {
                    if (ch.complex)
                        has = true;
                });
                return has;
            }
            /// 展开叶子节点或者包含复杂子节点
            if (this._expandLeafChild || hasComplexChild(tditem)) {
                const cf = this._createSubLayer(name, model, undefined, parent);
                tditem.children.forEach(sub => {
                    this._createModelTreeItem(model, cf, sub);
                });
            }
            /// 合并显示子要素
            else {
                const nodes = tditem.children.map(item => new ModelNode(item));
                this._createSubLayer(name, model, nodes, parent);
            }
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'ModelLayer'; }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            return Object.freeze(this._box);
        }
        /** 获取要素类信息 */
        get zfclsInfo() { return this._zfclsInfo; }
        /** @override */
        flyTo(option) { this.zoomOrFlyto(option); }
        /** 模型炸开 */
        doExplode(option) {
            ///
            this.ready.then(() => {
                if (!this._explodes) {
                    this._explodes = new ModelExplode(this.view3d.czviewer, this._models);
                }
                this._explodes.startExplode(option);
            });
        }
        /** 模型复原 */
        restoreExplode() {
            if (this._explodes) {
                this._explodes.restoreExplode();
            }
        }
        /**
         * 显示或者隐藏包围盒
         * @param show
         * @param color
         */
        showBoxEntity(show = true, option) {
            ///
            if (show) {
                this._boxOption = Object.assign({ color: 'rgba(0,255,0,0.4)' }, option);
            }
            else {
                this._boxOption = undefined;
            }
            this._updateBoxEntity();
        }
        switchBoxEntity(option) {
            this.showBoxEntity(!CZMAP.defined(this._boxOption), option);
        }
        _updateBoxEntity() {
            if (this._boxEntity)
                this.view3d.czviewer.entities.remove(this._boxEntity);
            const opt = this._boxOption;
            if (!opt)
                return;
            const box = this.boundBox.clone();
            box.inflateMultiple(1.2);
            this._boxEntity = this.view3d.czviewer.entities.add({
                name: 'boundbox',
                rectangle: {
                    coordinates: Cesium.Rectangle.fromDegrees(box.minx, box.miny, box.maxx, box.maxy),
                    material: Cesium.Color.fromCssColorString(opt.color),
                    extrudedHeight: box.maxz,
                    height: box.minz,
                    outline: true,
                    outlineColor: Cesium.Color.BLACK
                }
            });
        }
        /**
         * 显示坐标网格
         * @param show
         * @param option
         */
        showCoordGrid(show, option) {
            if (show) {
                this._gridOption = Object.assign({}, option);
            }
            else {
                this._gridOption = undefined;
            }
            this._updateCoordGrid();
        }
        switchCoordGrid(option) {
            this.showCoordGrid(!CZMAP.defined(this._gridOption), option);
        }
        _updateCoordGrid(option) {
            if (this._gridEntity)
                this.view3d.gridTool.remove(this._gridEntity);
            const opt = this._gridOption;
            if (!opt)
                return;
            const box = this.boundBox.clone();
            box.inflateMultiple(1.2);
            const oo = Object.assign({}, opt);
            oo.displayBox = box;
            oo.dataBox = CZMAP.BoundingBox.formString(this.zfclsInfo.cbox);
            this._gridEntity = this.view.gridTool.create(oo);
        }
        /**
         *
         * @param zoomOrFly
         */
        zoomOrFlyto(option) {
            /// 当所有模型就绪后
            this.ready.then(() => {
                this.view.flyToBox(this._box, option);
            });
        }
        /**
         * 显示隐藏标注
         * @param {*} enable
         */
        showLabel(enable) {
            this.enableLabel = enable;
        }
        get enableLabel() { return this._enableLabel; }
        set enableLabel(enable) {
            this._enableLabel = enable;
            this.children.forEach(c => c.enableLabel = enable);
        }
        /** 位置属性 */
        set position(pos) {
            this._position = CZMAP.ZFclsModel.parsePosition(pos);
            this._updatePositionAndPose();
        }
        get position() { return this._position; }
        set pose(pose) {
            this._pose = CZMAP.ZFclsModel.parsePosition(pose);
            this._updatePositionAndPose();
        }
        /** 姿态属性 */
        get pose() { return this._pose; }
        set scale(scale) {
            this._scale = CZMAP.ZFclsModel.parsePosition(scale, [1, 1, 1]);
            this._updatePositionAndPose();
        }
        get scale() { return this._scale; }
        set offset(offset) {
            this._offset = CZMAP.ZFclsModel.parsePosition(offset, [0, 0, 0]);
            this._updatePositionAndPose();
        }
        get offset() { return this._offset; }
        /**
         * 是否启用聚合
         */
        get enableCluster() { return this._enableCluster; }
        set enableCluster(enable) { this._enableCluster = enable; }
        /** 获取模型数据的格式 */
        get format() { return this._format; }
        get url2() { return this._url2; }
        /**
         * 设置剖切面
         * @param axis 坐标轴
         * @param distance
         */
        setClip(axis, distance) {
            console.info('setClip', distance);
            distance = CZMAP.Parse.parseNumber(distance);
            const normal = new Cesium.Cartesian3(0, 0, 0);
            switch (axis) {
                case 'x':
                case '+x':
                    normal.x = 1.0;
                    break;
                case 'y':
                case '+y':
                    normal.y = 1.0;
                    break;
                case 'z':
                case '+z':
                    normal.z = 1.0;
                    break;
                case '-x':
                    normal.x = -1.0;
                    break;
                case '-y':
                    normal.y = -1.0;
                    break;
                case '-z':
                    normal.z = -1.0;
                    break;
                default:
                    normal.z = -1.0;
                    break;
            }
            if (!this._clips) {
                const position = CZMAP.CesiumAttrib.getCartesian3Degree(this._position);
                this._clips = new Cesium.ClippingPlaneCollection({
                    enabled: true,
                    planes: [new Cesium.ClippingPlane(normal, distance)],
                    edgeWidth: 1.0
                });
                if (this._format === ModelDataFormat.ZFCLS && !this._flat) {
                    const mat = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                    Cesium.Matrix4.setTranslation(mat, Cesium.Cartesian3.ZERO, this._clips.modelMatrix);
                    //Cesium.Matrix4.fromRotationTranslation(_initm3, Cesium.Cartesian3.ZERO, this._clips.modelMatrix);
                }
                this.ready.then(() => {
                    this.models.forEach(m => m.clippingPlanes = this._clips);
                });
            }
            else {
                const clip = this._clips.get(0);
                clip.distance = distance;
            }
        }
        clearClip() {
            if (this._clips) {
                this._clips.enabled = false;
            }
        }
        /** 同步其他地址模型和当前模型同高度 */
        async syncScaleHeight(others) {
            await Promise.all([this.ready, ...others.map(oth => oth.ready)]);
            const scale = this.scale;
            const position = this.position;
            others.forEach(oth => {
                const opos = oth.position;
                const offz = opos[2] - position[2];
                oth.scale = scale;
                oth.offset[2] = oth.offset[2] + offz * scale[2];
            });
        }
        /**
         * 更新模型的位置和方位
         */
        _updatePositionAndPose(imme) {
            clearTimeout(this._updateHandle);
            if (imme)
                this._updatePositionAndPoseImpl();
            else
                this._updateHandle = setTimeout(() => this._updatePositionAndPoseImpl());
        }
        _updatePositionAndPoseImpl() {
            const orientation = this._modelOrientation;
            const pos = add(this._position, this._offset);
            let position = CZMAP.CesiumAttrib.getCartesian3Degree(pos);
            let scale = CZMAP.CesiumAttrib.getCartesian3(this._scale);
            ///
            if (this._format === ModelDataFormat.ZFCLS && !this._flat) {
                Cesium.Quaternion.clone(_initq, orientation);
                scale.x = scale.y = scale.z = 1;
            }
            else {
                /// 方位角减去90度，cesium默认方向为东
                const hpr = Cesium.HeadingPitchRoll.fromDegrees(this._pose[0] + 90, this._pose[1], this._pose[2]);
                Cesium.Transforms.headingPitchRollQuaternion(position, hpr, undefined, undefined, orientation);
            }
            ///
            const labelHpr = Cesium.HeadingPitchRoll.fromDegrees(this._pose[0], this._pose[1], this._pose[2]);
            const labelOrientation = Cesium.Transforms.headingPitchRollQuaternion(position, labelHpr, undefined, undefined, this._labelOrientation);
            //
            const modelMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(position, orientation, scale, this._modelMatrix4);
            this._models.forEach(m => m.modelMatrix = modelMatrix);
            const labelMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(position, labelOrientation, scale, this._labelMatrix4);
            this._labels.forEach(lb => lb.update(labelMatrix));
            ///
            this._requestUpdateBoundBox();
        }
        _requestUpdateBoundBox() {
            this.ready.then(() => {
                this._updateBoundBox();
                this._updateBoxEntity();
                this._updateCoordGrid();
            });
        }
        _updateBoundBoxZfcls() {
            const scale = this.scale;
            const offset = this.offset;
            const position = this.position.slice();
            if (!this.zfclsInfo)
                return;
            /// 获取模型中心点
            const box = CZMAP.BoundingBox.formString(this.zfclsInfo.box);
            const size = box.getSize();
            /// 应用缩放比例
            CZMAP.GeoMath.mul(size, scale, size);
            /// 应用偏移
            CZMAP.GeoMath.add(position, offset, position);
            size[0] = size[0] / 111000;
            size[1] = size[1] / 111000;
            ///
            this._box = CZMAP.BoundingBox.formCenterSize(position, size, box);
        }
        _updateBoundBoxCommon() {
            const bbox = new CZMAP.BoundingBox();
            const cc = new Cesium.Cartesian3();
            this._models.forEach(m => {
                const sbbox = calcModelBoundBox(m);
                const modelMatrix = m['_computedModelMatrix'];
                sbbox.getCorners().forEach(cr => {
                    cc.x = cr[0];
                    cc.y = cr[1];
                    cc.z = cr[2];
                    Cesium.Matrix4.multiplyByPoint(modelMatrix, cc, cc);
                    const pos = new Cegore.Position(cc);
                    bbox.mergeXYZ(pos.x, pos.y, pos.z);
                });
            });
            this._box = bbox;
        }
        _updateBoundBox() {
            if (this._zfclsInfo) {
                this._updateBoundBoxZfcls();
            }
            else {
                this._updateBoundBoxCommon();
            }
        }
        /**
         * 销毁图层
         */
        _destroyInner() {
            this._models.forEach(m => {
                this.scene.primitives.remove(m);
            });
            this._labels.forEach(l => {
                this.view3d.clusterEntities.remove(l.entity);
                this.view3d.entities.remove(l.entity);
            });
            this._models.length = 0;
            this._labels.length = 0;
            this._show_child = false;
        }
        /**
         * 设置显示和隐藏
         * @param {*} v
         * @override
         */
        _onVisible(v) {
            this._models.forEach(m => m.show = v);
        }
        ///
        get models() { return this._models; }
    }
    CZMAP.ModelLayer = ModelLayer;
    const _initq = new Cesium.Quaternion(-0.5, -0.5, -0.5, 0.5);
    function add(p0, p1, r) {
        if (!r)
            r = [0, 0, 0];
        r[0] = p0[0] + p1[0];
        r[1] = p0[1] + p1[1];
        r[2] = p0[2] + p1[2];
        return r;
    }
    function sub(p0, p1, r) {
        if (!r)
            r = [0, 0, 0];
        r[0] = p0[0] - p1[0];
        r[1] = p0[1] - p1[1];
        r[2] = p0[2] - p1[2];
        return r;
    }
    class ModelExplode {
        /**  */
        constructor(viewer, models) {
            this._explodes = [];
            this._viewer = viewer;
            this._models = models.slice();
            /// 计算所有模型的包围球
            const boundingSpheres = [];
            this._models.forEach(m => {
                const nodes = m['_runtime'].nodes;
                const keys = Object.keys(nodes);
                keys.forEach(key => {
                    ///
                    const node = nodes[key];
                    const cmds = node.commands;
                    ///
                    let allbsphere;
                    cmds.forEach((nc) => {
                        boundingSpheres.push(nc.boundingSphere);
                        if (!allbsphere)
                            allbsphere = nc.boundingSphere.clone();
                        else
                            Cesium.BoundingSphere.union(nc.boundingSphere, allbsphere, allbsphere);
                    });
                    this._explodes.push({
                        key: key,
                        node: node,
                        translation: Cesium.Cartesian3.clone(node.translation),
                        boundingSphere: allbsphere
                    });
                });
            });
            ///
            this._boundingSphere = Cesium.BoundingSphere.fromBoundingSpheres(boundingSpheres);
        }
        startExplode(option) {
            ///
            this.restoreExplode();
            //this._viewer.
            this._start = new Date();
            this._option = option || {};
            this._tickInstance = this._viewer.scene.preRender.addEventListener(this._tick, this);
        }
        restoreExplode() {
            if (this._tickInstance) {
                this._tickInstance();
                this._tickInstance = undefined;
            }
            this._explodes.forEach(e => {
                Cesium.Cartesian3.clone(e.translation, e.node.translation);
            });
            this._notifyModelChanged();
        }
        /**
         * 通知模型已经改变
         */
        _notifyModelChanged() {
            this._models.forEach(m => {
                m.maximumScale = 100000000000 + Math.random();
            });
        }
        _tick(scene, time) {
            const now = new Date();
            const cost = now.getTime() - this._start.getTime();
            let percent = cost / CZMAP.Types.defaultValue(this._option.duration, 1000);
            if (percent > 1) {
                percent = 1;
                this._tickInstance();
                this._tickInstance = undefined;
            }
            const multi = CZMAP.Types.defaultValue(this._option.explodeMultiple, 5);
            this._explodes.forEach(e => {
                const off = e.boundingSphere.center.y - this._boundingSphere.center.y;
                const off2 = off * multi * percent;
                e.node.translation.y = e.translation.y + off2;
            });
            ///
            this._notifyModelChanged();
        }
    }
    function calcModelBoundBox(model, nodes) {
        const bbox = new CZMAP.BoundingBox();
        const sbox = new CZMAP.BoundingBox();
        const ccpt = new Cesium.Cartesian3();
        const gltf = model.gltf;
        const runtimeNodes = model['_runtime'].nodes;
        if (!Array.isArray(nodes) || nodes.length == 0) {
            nodes = Object.keys(runtimeNodes);
        }
        //const rnodes = Array.isArray(nodes) ? nodes.map(i => runtimeNodes[i]) : runtimeNodes;
        nodes.forEach(i => {
            const rnode = runtimeNodes[i];
            const gnode = gltf.nodes[i];
            const mesh = gltf.meshes[gnode.mesh];
            mesh.primitives.forEach(p => {
                const pos = p.attributes['POSITION'];
                if (!CZMAP.defined(pos))
                    return;
                const paccess = gltf.accessors[pos];
                if (!CZMAP.defined(paccess))
                    return;
                const { min, max } = paccess;
                if (!CZMAP.defined(min) || !CZMAP.defined(max))
                    return;
                sbox.setMinMax(min, max);
                sbox.getCorners().forEach(c => {
                    ccpt.x = c[0];
                    ccpt.y = c[1];
                    ccpt.z = c[2];
                    Cesium.Matrix4.multiplyByPoint(rnode.transformToRoot, ccpt, ccpt);
                    bbox.mergeXYZ(ccpt.x, ccpt.y, ccpt.z);
                });
            });
        });
        return bbox;
    }
    CZMAP.calcModelBoundBox = calcModelBoundBox;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 瓦片图层
     */
    class StaticImageLayer extends CZMAP.Layer {
        /**
         *
         */
        constructor(parent, options) {
            super(parent, options);
            ///
            this.options = options;
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'StaticImageLayer'; }
    }
    CZMAP.StaticImageLayer = StaticImageLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 子模型图层
     */
    class SubModelLayer extends CZMAP.Folder {
        /**
         * 构造函数
         * @param parent 父图层
         * @param define 图层的定义
         * @param define.name 图层名称
         */
        constructor(parent, options) {
            var _a;
            super(parent, options);
            /// 
            this._flashHandle = undefined;
            this._nodecmds = [];
            ///
            this.view3d = parent.map.view3d;
            ///
            this._model = options.model;
            this._nodes = options.nodes;
            this._label = options.label;
            if (this._label) {
                this._label['_czmap_obj'] = this;
            }
            /// 获取当前子模型的nodecommand
            if ((_a = this._nodes) === null || _a === void 0 ? void 0 : _a.length) {
                Cesium.when(this._model.readyPromise).then(() => {
                    this._nodes.forEach(n => {
                        const node = this._model['_runtime'].nodesByName[n.node];
                        if (!node)
                            return;
                        ///
                        node.publicNode._czmap_obj = this;
                        const cmds = node.commands;
                        ///
                        cmds.forEach((nc) => {
                            this._nodecmds.push(nc);
                        });
                    });
                });
            }
        }
        flyTo(option) {
            this.zoomOrFly(option);
        }
        _getBoundingSphere(allbsphere) {
            ///
            this._nodecmds.forEach((nc) => {
                const bv = nc.boundingSphere.clone();
                Cesium.Matrix4.multiplyByPoint(nc.command.modelMatrix, bv.center, bv.center);
                if (!allbsphere)
                    allbsphere = bv;
                else
                    Cesium.BoundingSphere.union(bv, allbsphere, allbsphere);
            });
            return allbsphere;
        }
        zoomOrFly(option) {
            function getBoundingSphere(sm, sp) {
                sp = sm._getBoundingSphere(sp);
                sm.children.forEach(ch => {
                    sp = getBoundingSphere(ch, sp);
                });
                ///
                return sp;
            }
            ///
            Cesium.when(this._model.readyPromise).then(() => {
                const allbsphere = getBoundingSphere(this);
                if (allbsphere) {
                    this.view3d.flyToSphere(allbsphere, option);
                    ///
                    this.startFlash({ flashColor: option.flashColor });
                }
            });
        }
        _onVisible(v) {
            this._nodecmds.forEach(e => e.show = v);
            this.enableLabel = v;
        }
        get enableLabel() { var _a; return (_a = this._label) === null || _a === void 0 ? void 0 : _a.show; }
        set enableLabel(v) {
            if (this._label)
                this._label.show = v;
        }
        get enableCluster() { return this.parent.enableCluster; }
        /**
         * 获取属性列表
         */
        get properties() {
            const props = [];
            if (!this._nodes)
                return props;
            //// 
            const gltf = this._model.gltf;
            this._nodes.forEach(n => {
                var _a;
                const node = gltf.nodes.find(n => n.name == n.node);
                if (!node)
                    return;
                const mesh = gltf.meshes[node.mesh];
                props.push((_a = mesh === null || mesh === void 0 ? void 0 : mesh.extras) === null || _a === void 0 ? void 0 : _a.attribute);
            });
            ///
            return props;
        }
        /** 开始闪烁 */
        startFlash(option) {
            if (CZMAP.Types.isDefined(this._flashHandle))
                return;
            option = CZMAP.deepAssign({ flashCount: 6, flashInterval: 500 }, option);
            /// 
            const czColor = CZMAP.CesiumAttrib.getColor(CZMAP.defaultValue(option.flashColor, SubModelLayer.defaultFlashColor));
            const cmds = [
                'command', 'silhouetteColorCommand', 'silhouetteModelCommand', 'translucentCommand',
                'command2D', 'silhouetteColorCommand2D', 'silhouetteModelCommand2D', 'translucentCommand2D'
            ];
            const newUniforMap = {
                ////
                gltf_color() {
                    return czColor;
                },
                gltf_colorBlend() {
                    return czColor.alpha;
                }
            };
            const ncbak = this._nodecmds.map(nc => {
                const bak = { nc };
                cmds.forEach(cname => {
                    const cmd = nc[cname];
                    if (!cmd)
                        return;
                    bak[cname] = {};
                    Object.keys(newUniforMap).forEach(key => {
                        bak[cname][key] = cmd.uniformMap[key];
                    });
                });
                ///
                return bak;
            });
            function setColor() {
                ncbak.forEach(ncb => {
                    const nc = ncb.nc;
                    cmds.forEach(cname => {
                        const cmd = nc[cname];
                        if (!cmd)
                            return;
                        Object.keys(newUniforMap).forEach(key => {
                            cmd.uniformMap[key] = newUniforMap[key];
                        });
                    });
                });
            }
            function resetColor() {
                ncbak.forEach(ncb => {
                    const nc = ncb.nc;
                    cmds.forEach(cname => {
                        const cmd = nc[cname];
                        if (!cmd)
                            return;
                        Object.keys(newUniforMap).forEach(key => {
                            cmd.uniformMap[key] = ncb[cname][key];
                        });
                    });
                });
            }
            ///
            let count = option.flashCount;
            this._flashHandle = setInterval(() => {
                /// 
                if (count % 2 == 0)
                    setColor();
                else
                    resetColor();
                /// 
                count--;
                if (count === 0) {
                    clearInterval(this._flashHandle);
                    this._flashHandle = undefined;
                }
            }, option.flashInterval);
        }
        /** 取消闪烁 */
        cancelFlash() {
            if (this._flashHandle) {
                clearTimeout(this._flashHandle);
                this._flashHandle = 0;
            }
        }
    }
    ///
    SubModelLayer.defaultFlashColor = 'red';
    CZMAP.SubModelLayer = SubModelLayer;
})(CZMAP || (CZMAP = {}));
/// <reference path="MoveableLayer.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 3DTileset图层
     */
    class TDTilesLayer extends CZMAP.MoveableLayer {
        constructor(parent, options) {
            super(parent, options);
        }
    }
    CZMAP.TDTilesLayer = TDTilesLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 地形图层
     */
    class TerrainLayer extends CZMAP.Layer {
        ///
        constructor(parent, options) {
            super(parent, options);
            ///
            this._option = options;
        }
        setClip(option) {
            this._option.clip = option;
            this.changed();
        }
        /** 设置地形夸张 */
        setExaggeration(scale, scaleOffset, heightOffset) {
            this._option.heightScale = scale;
            this._option.heightScaleOffset = scaleOffset;
            this._option.heightOffset = heightOffset;
            this.changed();
        }
        setMaxSSE(maxSSE) {
            this._option.maxSSE = maxSSE;
            this.changed();
        }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            return CZMAP.BoundingBox.Empty;
        }
        _createInner() {
        }
        /**
         * 销毁图层
         */
        _destroyInner() {
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'TerrainLayer'; }
        get url() { return this._option.url; }
        get option() { return this._option; }
    }
    CZMAP.TerrainLayer = TerrainLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 瓦片图层
     */
    class TileLayer extends CZMAP.Layer {
        /**
         *
         */
        constructor(parent, options) {
            super(parent, options);
            ///
            this.options = options;
            /// 
            this.options.scheme = TileLayer.parseScheme(this.options.scheme);
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'TileLayer'; }
        static parseScheme(scheme) {
            if (CZMAP.Types.isString(scheme) && scheme.toUpperCase() === CZMAP.TileLayerScheme.Geographic)
                return CZMAP.TileLayerScheme.Geographic;
            ///
            return CZMAP.TileLayerScheme.WebMercator;
        }
    }
    CZMAP.TileLayer = TileLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 瓦片图层方案
     */
    let TileLayerScheme;
    (function (TileLayerScheme) {
        /** 经纬度 */
        TileLayerScheme["Geographic"] = "GEOGRAPHIC";
        /** Web摩卡托 */
        TileLayerScheme["WebMercator"] = "WEBMERCATOR";
    })(TileLayerScheme = CZMAP.TileLayerScheme || (CZMAP.TileLayerScheme = {}));
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 数据源基类
     */
    class Source extends CZMAP.BaseObject {
        /**
         * 构造新的数据源
         * @param options
         */
        constructor(options) {
            super();
            /// 
            this._projection = CZMAP.Types.defaultValue(options.projection, 'EPSG:4326');
            this._state = CZMAP.Types.defaultValue(options.state, CZMAP.SourceState.READY);
        }
        /**
         * 获取数据源的投影系
         */
        get projection() { return this._projection; }
        /**
         * 获取数据源的状态
         */
        get state() { return this._state; }
        /**
         * 刷新数据源
         */
        refresh() {
            this.changed();
        }
        _setProjection(projection) {
            this._projection = projection;
        }
        /**
         * 设置数据源状态
         * @protected
         * @param state
         */
        _setState(state) {
            this._state = state;
            this.changed();
        }
    }
    CZMAP.Source = Source;
})(CZMAP || (CZMAP = {}));
/// <reference path="Source.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 要素数据源事件
     * @enum {string}
     */
    let VectorSourceEventType;
    (function (VectorSourceEventType) {
        /**
         * 添加要素
         */
        VectorSourceEventType["ADDFEATURE"] = "addfeature";
        /**
         * 要素改变
         */
        VectorSourceEventType["CHANGEFEATURE"] = "changefeature";
        /**
         * 移除要素
         */
        VectorSourceEventType["REMOVEFEATURE"] = "removefeature";
        /**
         * 移除所有要素
         */
        VectorSourceEventType["CLEAR"] = "clear";
    })(VectorSourceEventType = CZMAP.VectorSourceEventType || (CZMAP.VectorSourceEventType = {}));
    ;
    /**
     * 矢量数据源事件，包含触发该事件的“要素”
     */
    class VectorSourceEvent extends CZMAP.Event {
        /**
         * @param type Type.
         * @param opt_feature Feature.
         */
        constructor(type, opt_feature) {
            super(type);
            this.feature = opt_feature;
        }
    }
    CZMAP.VectorSourceEvent = VectorSourceEvent;
    /**
     * 矢量数据源
     */
    class VectorSource extends CZMAP.Source {
        /**
         * @param opt_options Vector source options.
         */
        constructor(opt_options) {
            ///
            super({
                projection: undefined,
                state: CZMAP.SourceState.UNDEFINED
            });
            /**
             * 包围盒
             */
            this._box = new CZMAP.BoundingBox();
            /**
             * 要素列表
             */
            this._keysmap = new Map();
            this._fidsmap = new Map();
            /**
             *
             */
            this._hasload = false;
            ///
            opt_options = opt_options || {};
            this._loader = CZMAP.VOID;
            this._format = opt_options.format;
            ///
            this._url = opt_options.url;
            ///
            if (CZMAP.Types.isDefined(opt_options.projection))
                this._setProjection(opt_options.projection);
            ///
            if (CZMAP.Types.isDefined(opt_options.loader)) {
                this._loader = opt_options.loader;
            }
            else if (CZMAP.Types.isDefined(this._url) && CZMAP.Types.isDefined(this._format)) {
                this._setState(CZMAP.SourceState.LOADING);
                this._loader = CZMAP.createUrlFeatureLoader(this._url, this._format, (features, projection) => {
                    ///
                    this._setProjection(projection);
                    this._setState(CZMAP.SourceState.READY);
                    this.addFeatures(features);
                });
            }
            if (CZMAP.Types.isDefined(opt_options.features)) {
                opt_options.features.forEach(this.addFeatureInternal, this);
                this._setState(CZMAP.SourceState.READY);
            }
        }
        /**
         * 添加一个要素到数据源中
         * @param feature 要素
         */
        addFeature(feature) {
            this.addFeatureInternal(feature);
            this.changed();
        }
        /**
         * 添加要素，不触发`change`事件
         * @param feature 要素
         */
        addFeatureInternal(feature) {
            const featureKey = CZMAP.getUid(feature);
            if (this._keysmap.has(featureKey))
                return;
            const fi = {
                id: feature.id,
                key: featureKey,
                feature: feature,
            };
            ///
            this._setupChangeEvents(fi);
            ///
            this._keysmap.set(featureKey, fi);
            const id = feature.id;
            if (id !== -1) {
                this._fidsmap.set(id, fi);
            }
            ///
            this.dispatchEvent(new VectorSourceEvent(VectorSourceEventType.ADDFEATURE, feature));
        }
        /**
         * 初始化`change`事件
         * @param fi 要素
         */
        _setupChangeEvents(fi) {
            fi.bindch = fi.feature.on(CZMAP.BaseObjectEvents.CHANGE, this._handleFeatureChange, this);
            fi.bindpo = fi.feature.on(CZMAP.BaseObjectEvents.PROPERTYCHANGE, this._handleFeatureChange, this);
        }
        /**
         * 批量添加要素到数据源中
         * @param features 要素列表
         */
        addFeatures(features) {
            features.forEach(f => this.addFeatureInternal(f));
            this.changed();
        }
        /**
         * 移除所有要素
         * @param opt_fast 是否快速移除
         */
        clear(opt_fast) {
            if (opt_fast) {
                this._fidsmap.forEach(fi => {
                    ///
                    CZMAP.BaseObject.unByKey(fi.bindch);
                    CZMAP.BaseObject.unByKey(fi.bindpo);
                });
                ///
                this._keysmap.clear();
                this._fidsmap.clear();
            }
            else {
                this.getFeatures().forEach(this.removeFeatureInternal, this);
            }
            /// CLEAR Event
            const clearEvent = new VectorSourceEvent(VectorSourceEventType.CLEAR);
            this.dispatchEvent(clearEvent);
            this.changed();
        }
        /**
         * 遍历所有要素，该遍历不能中断
         * @param callback 回调函数
         * @param opt_this 回调函数的this
         */
        forEachFeature(callback, opt_this) {
            this._keysmap.forEach((v) => { callback.call(opt_this, v.feature); });
        }
        /**
         * 遍历指定范围内的要素
         *
         * @param extent 范围.
         * @param callback 回调函数
         * @param opt_this 回调函数的this
         * @alpha
         */
        forEachFeatureInExtent(extent, callback, opt_this) {
            CZMAP.abstract();
        }
        /**
         * 遍历指定范围内精确相交的要素
         * @param extent 范围.
         * @param callback 回调函数
         * @param opt_this 回调函数的this
         * @alpha
         */
        forEachFeatureIntersectingExtent(extent, callback, opt_this) {
            CZMAP.abstract();
        }
        /**
         * 获取所有要素
         * @return Features.
         */
        getFeatures(opt_features) {
            if (!opt_features)
                opt_features = [];
            this.forEachFeature(f => opt_features.push(f));
            ///
            return opt_features;
        }
        /**
         * 获取指定范围所有要素
         * @param  extent 范围.
         * @return 范围内的要素.
         * @alpha
         */
        getFeaturesInExtent(extent) {
            return CZMAP.abstract();
        }
        /**
         * 获取数据源的几何范围
         * @param opt_extent 可选的返回对象
         * @return 几何范围
         */
        getExtent(opt_extent) {
            this._updateBox();
            return CZMAP.Extents.createOrUpdate(this._box.minx, this._box.miny, this._box.maxx, this._box.maxy, opt_extent);
        }
        /**
         * 获取数据源的三维几何范围
         * @param opt_box 可选的返回对象
         * @return 三维几何范围
         */
        getBox(opt_box) {
            this._updateBox();
            ///
            return this._box.clone(opt_box);
        }
        /** 更新数据包围盒 */
        _updateBox() {
            if (this._box.isEmpty()) {
                this.forEachFeature(f => { if (f.geometry)
                    this._box.mergeBox(f.geometry.box); });
            }
        }
        /**
         * 通过ID获取要素
         *
         * @param id 要素的ID
         * @return 找到的要素或者undefined.
         * @api
         */
        getFeatureById(id) {
            var _a;
            return (_a = this._fidsmap.get(id.toString())) === null || _a === void 0 ? void 0 : _a.feature;
        }
        /**
         * 获取数据源的格式
         * @return 数据源的格式
         */
        getFormat() { return this._format; }
        /**
         * 获取数据源的URL
         * @return 数据源的URL
         * @api
         */
        getUrl() { return this._url; }
        /**
         * 要素改变事件
         */
        _handleFeatureChange(event) {
            const feature = (event.target);
            this.changed();
            this.dispatchEvent(new VectorSourceEvent(VectorSourceEventType.CHANGEFEATURE, feature));
        }
        /**
         * 返回是否包含指定的要素
         * @param feature 要素.
         * @return 是否包含要素
         */
        hasFeature(feature) {
            const key = CZMAP.getUid(feature);
            return this._keysmap.has(key);
        }
        /**
         * @return 数据源是否为空
         */
        isEmpty() {
            return this._keysmap.size == 0;
        }
        /**
         * 加载要素
         * @param extent Extent.
         * @param resolution Resolution.
         * @param projection Projection.
         */
        loadFeatures(extent, resolution, projection) {
            if (this._loader && this._hasload == false) {
                this._hasload = true;
                this._loader.call(this, null, resolution, projection);
            }
        }
        /**
         * 移除指定要素
         * @param feature 待移除的要素
         */
        removeFeature(feature) {
            this.removeFeatureInternal(feature);
            this.changed();
        }
        /**
         * 移除指定要素，不触发`change`事件
         * @param feature 待移除的要素
         */
        removeFeatureInternal(feature) {
            const featureKey = CZMAP.getUid(feature);
            const fi = this._keysmap.get(featureKey);
            if (!CZMAP.Types.isDefined(fi))
                return;
            ///
            CZMAP.BaseObject.unByKey(fi.bindch);
            CZMAP.BaseObject.unByKey(fi.bindpo);
            this._keysmap.delete(featureKey);
            this._fidsmap.delete(fi.id.toString());
            ///
            this.dispatchEvent(new VectorSourceEvent(VectorSourceEventType.REMOVEFEATURE, feature));
        }
    }
    CZMAP.VectorSource = VectorSource;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class Math2D {
        /**
         * 计算三角形abc的面积
         * @param a
         * @param b
         * @param c
         */
        static TriArea2D(a, b, c) {
            let area = ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
            if (area < 1.e-20 && area > -1.e-20)
                area = 0;
            return area;
        }
        /**
         * 计算多边形的面积
         */
        static PolygonArea(pts) {
            const size = pts.length;
            if (pts == null || size < 3)
                return 0;
            const point_num = size;
            let p0 = pts[point_num - 1];
            let p1 = pts[0];
            let p2 = pts[1];
            let s = p1[1] * (p0[0] - p2[0]);
            for (let i = 1; i < point_num; ++i) {
                p0 = p1;
                p1 = p2;
                p2 = pts[(i + 1) % point_num];
                ///
                s += p1[1] * (p0[0] - p2[0]);
            }
            ///
            return s / 2.0;
        }
        /**
         * 点乘(点积)
         */
        static Dot2D(p1, p2) {
            return p1[0] * p2[0] + p1[1] * p2[1];
        }
        /**
         * 检测点p是不在三角形abc内部
         */
        static IsInTri(a, b, c, p) {
            const v0 = CZMAP.GeoMath.sub(c, a);
            const v1 = CZMAP.GeoMath.sub(b, a);
            const v2 = CZMAP.GeoMath.sub(p, a);
            const dot00 = Math2D.Dot2D(v0, v0);
            const dot01 = Math2D.Dot2D(v0, v1);
            const dot02 = Math2D.Dot2D(v0, v2);
            const dot11 = Math2D.Dot2D(v1, v1);
            const dot12 = Math2D.Dot2D(v1, v2);
            const inverDeno = 1 / (dot00 * dot11 - dot01 * dot01);
            const u = (dot11 * dot02 - dot01 * dot12) * inverDeno;
            if (u < -0.000001 || u > 1.000001) // if u out of range, return directly
             {
                return false;
            }
            const v = (dot00 * dot12 - dot01 * dot02) * inverDeno;
            if (v < -0.000001 || v > 1.000001) // if v out of range, return directly
             {
                return false;
            }
            return u + v <= 1.000001;
        }
        /**
         * 求线段ab和cd的交点e，segment为true表示线段，false表示直线
         */
        static Intersect2D(a, b, c, d, e, segment = true) {
            // 三角形abc 面积的2倍
            const area_abc = Math2D.TriArea2D(a, b, c);
            // 三角形abd 面积的2倍
            const area_abd = Math2D.TriArea2D(a, b, d);
            // 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);
            if (segment && area_abc * area_abd >= 0) {
                return false;
            }
            // 三角形cda 面积的2倍
            const area_cda = Math2D.TriArea2D(c, d, a);
            // 三角形cdb 面积的2倍
            const area_cdb = Math2D.TriArea2D(c, d, b);
            // 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);
            if (segment && area_cda * area_cdb >= 0) {
                return false;
            }
            ///
            if (area_abd - area_abc == 0) {
                return false;
            }
            if (e != null) {
                //计算交点坐标
                const t = area_cda / (area_abd - area_abc);
                const dx = t * (b[0] - a[0]);
                const dy = t * (b[1] - a[1]);
                e[0] = a[0] + dx;
                e[1] = a[1] + dy;
            }
            ///
            return true;
        }
        /**
         * 点是否在简单多边形内部
         * @param pts
         * @param pt
         */
        static IsInSimplePolygon2D(pts, pt) {
            let bRes = false;
            const count = pts.length;
            let x1 = pts[0][0];
            let y1 = pts[0][1];
            let x2 = 0, y2 = 0;
            const xl = pt[0], yl = pt[1];
            for (let i = 1; i < count; ++i) {
                x2 = pts[i][0];
                y2 = pts[i][1];
                if (((y2 <= yl && yl < y1) || (y1 <= yl && yl < y2)) &&
                    (xl < ((x1 - x2) * (yl - y2) / (y1 - y2) + x2))) {
                    bRes = !bRes;
                }
                x1 = x2;
                y1 = y2;
            }
            return bRes;
        }
        /**
         * 点是否在多边形内部
         * @param pts
         * @param pt
         */
        static IsInPolygon2D(pts, pt) {
            let bRes = false;
            const nelen = pts.length;
            for (let i = 0; i < nelen; ++i) {
                if (Math2D.IsInSimplePolygon2D(pts[i], pt)) {
                    bRes = !bRes;
                }
            }
            return bRes;
        }
        static ProjPointToLine(a, b, p, r) {
            if (!r)
                r = [0, 0, 0];
            const area = Math.abs(Math2D.TriArea2D(a, b, p));
            const ab2 = CZMAP.GeoMath.squareDistance(a, b);
            const ap2 = CZMAP.GeoMath.squareDistance(a, p);
            const bp2 = CZMAP.GeoMath.squareDistance(b, p);
            const pr2 = area * area / ab2;
            const ar2 = ap2 - pr2;
            const br2 = bp2 - pr2;
            if (ar2 > ab2) {
                return b;
            }
            if (br2 > ab2) {
                return a;
            }
            const t = Math.sqrt(ar2 / ab2);
            const dx = t * (b[0] - a[0]);
            const dy = t * (b[1] - a[1]);
            r[0] = a[0] + dx;
            r[1] = a[1] + dy;
            return r;
        }
    }
    CZMAP.Math2D = Math2D;
})(CZMAP || (CZMAP = {}));
/// <reference path="../utils/Math2D.ts" />
/// <reference path="../fmts/GeoJSONFormat.ts" />
/// <reference path="../geom/BoundingBox.ts" />
var CZMAP;
(function (CZMAP) {
    const GeoJSON = new CZMAP.GeoJSONFormat();
    class NearestPointInLine {
        constructor(option) {
            this._cellPrecent = 0.01;
            this._radius = 0;
            option = option || {};
            this._radius = CZMAP.Types.defaultValue(option.radius, 0);
            if (option.data) {
                this._data = GeoJSON.readFeatures(option.data);
                this._init();
            }
            else if (option.url) {
                fetch(option.url).then(e => e.json()).then(e => {
                    this._data = GeoJSON.readFeatures(e);
                    this._init();
                }).catch(e => console.warn('load data error', e));
            }
        }
        _init() {
            if (!CZMAP.Types.isArray(this._data))
                return;
            const box = new CZMAP.BoundingBox();
            this._data.forEach(e => {
                box.mergeBox(e.geometry.box);
            });
            const msize = Math.max(...box.getSize());
            box.inflate(msize * 0.05);
            const width = box.getWidth(), height = box.getHeight();
            const maxSide = Math.max(width, height);
            const cellSize = maxSide * this._cellPrecent;
            const cellNumX = Math.floor(width / cellSize);
            const cellNumY = Math.floor(height / cellSize);
            /// 
            const canvas = document.createElement('canvas');
            canvas.width = cellNumX;
            canvas.height = cellNumY;
            const ctx = canvas.getContext('2d');
            /// 
            const rc = { ctx, box, width, height, cellNumX, cellNumY, cellSize };
            this._box = box;
            this._width = width;
            this._height = height;
            this._cellNumX = cellNumX;
            this._cellNumY = cellNumY;
            this._cellSize = cellSize;
            /// 
            if (this._radius)
                this._findRadius = Math.floor(this._radius / cellSize);
            else
                this._findRadius = Math.floor(maxSide * 0.1 / cellSize);
            /// 
            this._ids = new Int32Array(cellNumX * cellNumY);
            /// 
            this._data.forEach((e, index) => {
                ctx.clearRect(0, 0, cellNumX, cellNumY);
                const g = e.geometry;
                if (g.getGeometryType() == CZMAP.GeometryType.POLYLINE)
                    this._drawLine(rc, g);
                this._copyID(rc, index + 1);
            });
        }
        _drawLine(rc, line) {
            rc.ctx.beginPath();
            rc.ctx.lineWidth = 1;
            rc.ctx.strokeStyle = "red";
            for (let i = 0; i < line.coordinates.length; ++i) {
                const pt = line.coordinates[i];
                const x = ((pt[0] - rc.box.minx) / rc.width * rc.cellNumX);
                const y = ((pt[1] - rc.box.miny) / rc.height * rc.cellNumY);
                if (i == 0)
                    rc.ctx.moveTo(x, y);
                else
                    rc.ctx.lineTo(x, y);
            }
            rc.ctx.stroke();
        }
        _copyID(rc, id) {
            const idata = rc.ctx.getImageData(0, 0, rc.cellNumX, rc.cellNumY).data;
            const count = rc.cellNumX * rc.cellNumY;
            for (let i = 0; i < count; ++i) {
                const idd = i * 4;
                if (idata[idd] != 0) {
                    this._ids[i] = id;
                }
            }
        }
        findNearestPoint(pt) {
            const find = {};
            const cx = Math.floor((pt[0] - this._box.minx) / this._cellSize);
            const cy = Math.floor((pt[1] - this._box.miny) / this._cellSize);
            const cr = this._findRadius;
            for (let y = cy - cr; y <= cy + cr; ++y) {
                if (y < 0 || y >= this._cellNumY)
                    continue;
                for (let x = cx - cr; x <= cx + cr; ++x) {
                    if (x < 0 || x >= this._cellNumX)
                        continue;
                    const id = this._ids[x + y * this._cellNumX];
                    if (id != 0)
                        find[id - 1] = 1;
                }
            }
            const findp = [];
            for (let key in find) {
                const f = this._data[key];
                const g = f.geometry;
                for (let i = 1; i < g.coordinates.length; ++i) {
                    const p0 = g.coordinates[i - 1];
                    const p1 = g.coordinates[i];
                    const pr = CZMAP.Math2D.ProjPointToLine(p0, p1, pt);
                    findp.push({ pt: pr, sd: CZMAP.GeoMath.squareDistance(pr, pt) });
                }
            }
            ///
            if (findp.length > 0) {
                findp.sort((a, b) => a.sd - b.sd);
                return findp[0].pt;
            }
            ///
            return undefined;
        }
    }
    CZMAP.NearestPointInLine = NearestPointInLine;
})(CZMAP || (CZMAP = {}));
/// <reference path="../source/VectorSource.ts" />
/// <reference path="../utils/NearestPointInLine.ts" />
var CZMAP;
(function (CZMAP) {
    let VectorLayerProperty;
    (function (VectorLayerProperty) {
        VectorLayerProperty["SOURCE"] = "source";
        VectorLayerProperty["STYLE"] = "style";
    })(VectorLayerProperty = CZMAP.VectorLayerProperty || (CZMAP.VectorLayerProperty = {}));
    const DefaultPointAnimation = {
        enable: false,
        duration: 5,
        maxDistance: undefined,
        showTail: false,
        tailWidth: 10,
        tailStyle: {
            type: 'glow',
            glowPower: 0.2,
            taperPower: 0.5,
            color: Cesium.Color.CORNFLOWERBLUE,
        },
        maxTailSeconds: 5,
        maxTailLength: 1000
    };
    /**
     * 要素图层
     */
    class VectorLayer extends CZMAP.Folder {
        /**
         * @param parent
         * @param options
         */
        constructor(parent, options) {
            super(parent, options);
            /**
             * 要素和图层的映射
             */
            this._loaded = false;
            /**
             * 是否启用聚合
             */
            this._enableCluster = true;
            /// 
            this.onProperty(VectorLayerProperty.SOURCE, this._handleSourceChange, this);
            this.onProperty(VectorLayerProperty.STYLE, this._handleStyleChange, this);
            ///
            this.onProperty(CZMAP.LayerProperty.VISIBLE, this._handleVectorVisibleChanged, this);
            ///
            this.source = options.source;
            this.style = options.style;
            ///
            this._enableCluster = CZMAP.Types.defaultValue(options.enableCluster, true);
            this._pointAnimation = CZMAP.deepAssign({}, DefaultPointAnimation, options.pointAnimation);
            this._processDeprecated(options);
            ///
            this._refLine = options.referenceLine;
            /// 
            if (options.multiLevelCluster && this.map.view3d) {
                this._multiLevelCluster = new CZMAP.MultiLevelCluster(this.map.view3d.czviewer, options.multiLevelCluster);
            }
            /// 
            if (!this.source)
                this.source = new CZMAP.VectorSource();
            if (!this.style)
                this.style = new CZMAP.FeatureStyle();
        }
        _processDeprecated(options) {
            this._pointAnimation.enable = CZMAP.defaultValue(options.enableAnimation, this._pointAnimation.enable);
            this._pointAnimation.duration = CZMAP.defaultValue(options.animationTimes, this._pointAnimation.duration);
            this._pointAnimation.maxDistance = CZMAP.defaultValue(options.maxAnimationDistance, this._pointAnimation.maxDistance);
        }
        /**
         * 获取图层类型名称
         */
        get type() { return 'FeatureCollectionLayer'; }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            return CZMAP.Transforms.transformBox(this.source.getBox(), this.projection, this.view.map.projection);
        }
        ///
        get source() { return this.get(VectorLayerProperty.SOURCE); }
        set source(src) { if (src instanceof CZMAP.VectorSource)
            this.set(VectorLayerProperty.SOURCE, src); }
        ///
        get style() { return this.get(VectorLayerProperty.STYLE); }
        set style(style) { if (style instanceof CZMAP.FeatureStyle || CZMAP.Types.isFunction(style))
            this.set(VectorLayerProperty.STYLE, style); }
        /** 是否启用聚合 */
        get enableCluster() { return this._enableCluster; }
        /** 获取点动画定义 */
        get pointAnimation() { return this._pointAnimation; }
        /** 多级聚合管理器 */
        get multiLevelCluster() { return this._multiLevelCluster; }
        /** 获取参考线 */
        get refLine() { return this._refLine; }
        /**
         * 获取图层的投影
         */
        get projection() { const src = this.source; return src ? src.projection : ''; }
        showLabel(enable) {
            this._children.forEach(element => {
                element.enableLabel = (enable);
            });
        }
        showIcon(enable) {
            this._children.forEach(element => {
                element.enableIcon = (enable);
            });
        }
        /**
         * 创建要素
         */
        createFeatureLayer(featruelike, options) {
            let feature;
            if (featruelike instanceof CZMAP.Feature) {
                feature = featruelike;
            }
            else {
                feature = new CZMAP.Feature(featruelike);
            }
            ///
            const ops = Object.assign({ feature }, options);
            if (!CZMAP.Types.isDefined(ops.style)) {
                ops.style = this._getStyle(feature);
            }
            if (!CZMAP.Types.isDefined(ops.name)) {
                ops.name = ops.style.name;
            }
            if (!CZMAP.Types.isDefined(ops.name)) {
                ops.name = `${this.name}-${this._children.length}`;
            }
            ///
            ops.visible = this.visible;
            ///
            return this.createLayer('feature', ops);
        }
        /**
         * 移除要素图层
         * @param feature
         */
        removeFeatureLayer(feature) {
            let flayer;
            if (feature instanceof CZMAP.Feature) {
                flayer = this._children.find(f => f.feature == feature);
                if (flayer)
                    this.removeLayer(flayer);
            }
            else if (feature instanceof CZMAP.FeatureLayer) {
                this.removeLayer(feature);
            }
        }
        ///
        _createInner() {
            /// 
            if (this.children.length == 0 && this.source.state === CZMAP.SourceState.READY) {
                this.source.forEachFeature(this.createFeatureLayer, this);
            }
        }
        /** 飞到模型 */
        flyTo(option) {
            this.view.flyToBox(this.boundBox, option);
        }
        _handleSourceChange(event) {
            const os = event.oldValue;
            if (os)
                os.un(VectorLayer.events, this._handleSourceEvents, this);
            ///
            this.removeAllLayer();
            this.source.on(VectorLayer.events, this._handleSourceEvents, this);
            this.source.loadFeatures(null, 0, this.map.projection);
        }
        _handleStyleChange(event) {
            const st = this.style;
            this._children.forEach(f => {
                const fl = f;
                fl.style = this._getStyle(fl.feature);
            });
        }
        _handleSourceEvents(event) {
            switch (event.type) {
                case CZMAP.VectorSourceEventType.ADDFEATURE:
                    this.createFeatureLayer(event.feature);
                    break;
                case CZMAP.VectorSourceEventType.REMOVEFEATURE:
                    this.removeFeatureLayer(event.feature);
                    break;
                case CZMAP.VectorSourceEventType.CHANGEFEATURE:
                    break;
                case CZMAP.VectorSourceEventType.CLEAR:
                    this.removeAllLayer();
                    break;
            }
        }
        _getStyle(feature) {
            const st = this.style;
            if (CZMAP.Types.isFunction(st)) {
                return st(feature, 0);
            }
            else if (CZMAP.Types.isObject(st)) {
                return st;
            }
            else {
                return CZMAP.FeatureStyle.default;
            }
        }
        _handleVectorVisibleChanged(event) {
            if (this._multiLevelCluster) {
                this._multiLevelCluster.show = this.visible;
            }
        }
    }
    VectorLayer.events = [
        CZMAP.VectorSourceEventType.ADDFEATURE,
        CZMAP.VectorSourceEventType.CHANGEFEATURE,
        CZMAP.VectorSourceEventType.CLEAR,
        CZMAP.VectorSourceEventType.REMOVEFEATURE
    ];
    CZMAP.VectorLayer = VectorLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 体数据图层
     */
    class VolumeLayer extends CZMAP.Layer {
        constructor(parent, options) {
            var _a, _b;
            super(parent, options);
            this._option = options;
            this._box = new CZMAP.BoundingBox();
            this._box.setMin(options.volumeOptions.volumeMin);
            this._box.setMax(options.volumeOptions.volumeMax);
            const rc = this._box.getCenter();
            const rs = this._box.getSize();
            const scale = (_a = options.volumeOptions.volumeScale) !== null && _a !== void 0 ? _a : [1, 1, 1];
            const offset = (_b = options.volumeOptions.volumeOffset) !== null && _b !== void 0 ? _b : [0, 0, 0];
            this._vbox = CZMAP.BoundingBox.formCenterSize(CZMAP.GeoMath.add(rc, offset), CZMAP.GeoMath.mul(rs, scale));
        }
        /**
         * 获取图层类型名称
         * @override
         */
        get type() { return 'VolumeLayer'; }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            return Object.freeze(this._box);
        }
        /** @override */
        flyTo(option) {
            this._zoomOrFlyto(option);
        }
        /**
         *
         * @param option
         */
        _zoomOrFlyto(option) {
            this.view.flyToBox(this._vbox, option);
        }
    }
    CZMAP.VolumeLayer = VolumeLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class LayerManager2D extends CZMAP.LayerManager {
    }
    CZMAP.LayerManager2D = LayerManager2D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class Point2D {
        /**
         *
         * @param parent
         */
        constructor(parent) {
        }
        set visible(v) {
        }
        _destroyInner() {
        }
    }
    CZMAP.Point2D = Point2D;
})(CZMAP || (CZMAP = {}));
/// <reference path="../LayerInner.ts" />
var CZMAP;
(function (CZMAP) {
    let typemaps = {
        'zmap': '',
        'UrlTemplate': '',
        'amap': 'AmapImage',
        'osm': 'osmImage',
        'tile': 'tileImage'
    };
    /** @internal */
    class TileLayer2D extends CZMAP.TileLayer {
        /**
         *
         */
        constructor(parent, options) {
            super(parent, options);
        }
        get boundBox() {
            throw new Error("Method not implemented.");
        }
        _onVisible() {
            throw new Error("Method not implemented.");
        }
        _createInner() {
        }
        _destroyInner() {
        }
    }
    CZMAP.TileLayer2D = TileLayer2D;
})(CZMAP || (CZMAP = {}));
/// <reference path="../FeatureInner.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class Feature3D extends CZMAP.FeatureRender {
        /** 快捷方式到 map.view3d */
        get view3d() { return this.map.view3d; }
    }
    CZMAP.Feature3D = Feature3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class FeatureLayer3D extends CZMAP.FeatureLayer {
        _createInner() {
            if (!this.geometry)
                return;
            ///
            if (this.geometry.type === CZMAP.GeometryType.POINT)
                this._render = new CZMAP.Point3D(this);
            if (this.geometry.type === CZMAP.GeometryType.POLYLINE)
                this._render = new CZMAP.Polyline3D(this);
        }
        _destroyInner() {
            if (this._render) {
                this._render.destroy();
                this._render = undefined;
            }
        }
        get render() {
            return this._render;
        }
    }
    CZMAP.FeatureLayer3D = FeatureLayer3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function creatImageyLayer() {
    }
    CZMAP.creatImageyLayer = creatImageyLayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 默认的平面地形 */
    let FlatBaseTerrain;
    function GetFlatBaseTerrain() {
        if (!FlatBaseTerrain)
            FlatBaseTerrain = new Cesium.EllipsoidTerrainProvider();
        return FlatBaseTerrain;
    }
    /** @internal */
    class LayerManager3D extends CZMAP.LayerManager {
        constructor(map) {
            super(map);
            this._register('terrain', CZMAP.TerrainLayer);
            this._register('tile', CZMAP.TileLayer3D);
            this._register('map', CZMAP.TileLayer3D);
            this._register('model', CZMAP.ModelLayer);
            this._register('volume', CZMAP.VolumeLayer3D);
            this._register('3dtiles', CZMAP.TDTilesLayer3D);
            this._register('feature', CZMAP.FeatureLayer3D);
            this._register('static', CZMAP.StaticImageLayer3D);
        }
        _clearTerrain() {
            const czv = this.map.view3d.czviewer;
            czv.terrainProvider = GetFlatBaseTerrain();
            czv.scene.globe.depthTestAgainstTerrain = false;
        }
        _applyTerrain(terrain) {
            const option = terrain.option;
            const clipOption = option.clip || {};
            this.map.view3d.cegore.globe.setTerrain({
                url: option.url,
                tileWidth: 20,
                tileHeight: 20,
                waterHeight: 0,
                heightOffset: option.heightOffset,
                heightScale: option.heightScale,
                heightScaleOffset: option.heightScaleOffset,
                qmesh: true,
                clip: JSON.stringify(clipOption.clip),
                clipInner: clipOption.inner,
                clipHeight: clipOption.height,
                clipWall: clipOption.wall,
                clipFloor: clipOption.floor
            });
            ///
            const globe = this.map.view3d.czviewer.scene.globe;
            globe.depthTestAgainstTerrain = true;
            globe.terrainProvider._czmap_obj = terrain;
        }
    }
    CZMAP.LayerManager3D = LayerManager3D;
})(CZMAP || (CZMAP = {}));
/// <reference path="Feature3D.ts" />
var CZMAP;
(function (CZMAP) {
    const step = 1.0 / 60.0;
    class MultiLevelClusterPoint {
        constructor(feature) {
            this._point = feature;
        }
        get position() {
            const time = this._point.view3d.czviewer.clock.currentTime;
            return this._point.entity.position.getValue(time);
        }
        get properties() {
            return this._point.feature.properties;
        }
        show(show) {
            this._point.visible = show;
        }
    }
    /**
     * 三维点对象
     * @internal
     */
    class Point3D extends CZMAP.Feature3D {
        /**
         */
        constructor(parent) {
            super(parent);
            /// 
            this._box = new CZMAP.BoundingBox();
            this._temp_hpr = new Cesium.HeadingPitchRoll();
            this._temp_ori = new Cesium.Quaternion();
            this._temp_date0 = new Cesium.JulianDate();
            this._temp_date1 = new Cesium.JulianDate();
            this._temp_date2 = new Cesium.JulianDate();
            const entity = {
                id: parent.id + "-point3d",
                show: true,
                //position : CesiumAttrib.getCartesian3Degree(this.geometry.coordinates)
            };
            this._entity = new Cesium.Entity(entity);
            this._entity._czmap_obj = parent;
            if (parent.enableCluster)
                this.view3d.clusterEntities.add(this._entity);
            else
                this.view3d.entities.add(this._entity);
            const pa = this.vectorLayer.pointAnimation;
            if (pa.showTail) {
                this._pathTail = this.view3d.pathTails.createTail({
                    position: time => { var _a, _b; return (_b = (_a = this.entity) === null || _a === void 0 ? void 0 : _a.position) === null || _b === void 0 ? void 0 : _b.getValue(time); },
                    width: pa.tailWidth,
                    material: CZMAP.Polyline3D.getStrokeMaterial(pa.tailStyle),
                    maxLength: pa.maxTailLength,
                    maxSeconds: pa.maxTailSeconds
                });
            }
        }
        get box() {
            return this._box;
        }
        get entity() {
            return this._entity;
        }
        _onVisibleChangle() {
            if (this._entity)
                this._entity.show = this.visible;
        }
        _init() {
        }
        _release() {
            ///
            if (this._clusterItem)
                this.vectorLayer.multiLevelCluster.remove(this._clusterItem);
            ///
            if (this._entity) {
                this.view3d.clusterEntities.remove(this._entity);
                this.view3d.entities.remove(this._entity);
                this._entity = undefined;
            }
            if (this._pathTail) {
                this.view3d.pathTails.removeTail(this._pathTail);
                this._pathTail = undefined;
            }
        }
        _handleGeometryChange() {
            this._updatePositionAndPose();
            /// 
            const mlc = this.vectorLayer.multiLevelCluster;
            if (mlc) {
                if (!this._clusterItem) {
                    this._clusterItem = new MultiLevelClusterPoint(this);
                    mlc.add(this._clusterItem);
                }
                mlc.update();
            }
        }
        _handleStyleChange(event) {
            this._entity.label = undefined;
            this._entity.billboard = undefined;
            this._entity.model = undefined;
            super._handleStyleChange(event);
        }
        _getLabel() {
            let label = this._entity.label;
            if (label)
                return label;
            label = new Cesium.LabelGraphics();
            label.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
            label.scale = 0.5;
            label.showBackground = false;
            label.outlineWidth = 0;
            //ent.label.eyeOffset = new Cesium.Cartesian3(0,0,-10);
            label.disableDepthTestDistance = Number.POSITIVE_INFINITY;
            ///
            this._entity.label = label;
            return label;
        }
        _getIcon() {
            let icon = this._entity.billboard;
            if (icon)
                return icon;
            icon = new Cesium.BillboardGraphics();
            //icon.eyeOffset = new Cesium.Cartesian3(0,0,-10); 
            icon.disableDepthTestDistance = Number.POSITIVE_INFINITY;
            this._entity.billboard = icon;
            ///
            return icon;
        }
        _getModel() {
            let model = this._entity.model;
            if (!model) {
                model = new Cesium.ModelGraphics();
                this._entity.model = model;
            }
            return model;
        }
        _applyBillStyle(bill, key, value) {
            switch (key) {
                case CZMAP.BillStyleProperty.OFFSET:
                    bill.pixelOffset = CZMAP.CesiumAttrib.getCartesian2(value);
                    break;
                case CZMAP.BillStyleProperty.HORIZONTAL_ORIGIN:
                    bill.horizontalOrigin = CZMAP.CesiumAttrib.getHorizontal(value, Cesium.HorizontalOrigin.LEFT);
                    break;
                case CZMAP.BillStyleProperty.VERTICAL_ORIGIN:
                    bill.verticalOrigin = CZMAP.CesiumAttrib.getVertical(value, Cesium.VerticalOrigin.BOTTOM);
                    break;
                case CZMAP.BillStyleProperty.VISIBLE_RANGE:
                    bill.distanceDisplayCondition = CZMAP.CesiumAttrib.getDisplayDistance(value);
                    break;
                case CZMAP.BillStyleProperty.SCALE_DISTANCE:
                    bill.scaleByDistance = CZMAP.CesiumAttrib.getNearFarScalar(value);
                    break;
                case CZMAP.BillStyleProperty.FADE_DISTANCE:
                    bill.translucencyByDistance = CZMAP.CesiumAttrib.getNearFarScalar(value);
                    break;
                case CZMAP.BillStyleProperty.DEPTH_DISTANCE:
                    bill.disableDepthTestDistance = value;
                    break;
            }
        }
        /**
         */
        _handleLabelStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            ///
            const label = this._getLabel();
            switch (event.key) {
                case CZMAP.StyleProperty.VISIBLE:
                    label.show = value;
                    break;
                case CZMAP.LabelStyleProperty.TEXT:
                    label.text = value;
                    break;
                case CZMAP.LabelStyleProperty.FONT:
                    label.font = CZMAP.Types.defaultValue(value, '32px 黑体');
                    break;
                case CZMAP.LabelStyleProperty.COLOR:
                    label.fillColor = CZMAP.CesiumAttrib.getColor(value, Cesium.Color.WHITE);
                    break;
                case CZMAP.LabelStyleProperty.BORDER_COLOR:
                    label.outlineColor = CZMAP.CesiumAttrib.getColor(value, Cesium.Color.BLACK);
                    break;
                case CZMAP.LabelStyleProperty.BORDER_WIDTH:
                    label.outlineWidth = CZMAP.CesiumAttrib.getNumber(value, 0);
                    break;
                case CZMAP.LabelStyleProperty.BACKGROUND:
                    label.showBackground = CZMAP.CesiumAttrib.getBoolean(value, false);
                    break;
                case CZMAP.LabelStyleProperty.BACKGROUND_COLOR:
                    label.backgroundColor = CZMAP.CesiumAttrib.getColor(value, Cesium.Color.DARKGREY);
                    break;
                default:
                    this._applyBillStyle(label, event.key, value);
                    break;
            }
        }
        _handleIconStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            ///
            const icon = this._getIcon();
            switch (event.key) {
                case CZMAP.StyleProperty.VISIBLE:
                    icon.show = value;
                    break;
                case CZMAP.IconStyleProperty.SOURCE:
                    icon.image = value;
                    break;
                case CZMAP.IconStyleProperty.COLOR:
                    icon.color = CZMAP.CesiumAttrib.getColor(value);
                    break;
                case CZMAP.IconStyleProperty.ROTATION:
                    icon.rotation = CZMAP.CesiumAttrib.getRadian(value, 0);
                    break;
                case CZMAP.IconStyleProperty.WIDTH:
                    icon.width = CZMAP.CesiumAttrib.getNumber(value, undefined);
                    break;
                case CZMAP.IconStyleProperty.HEIGHT:
                    icon.height = CZMAP.CesiumAttrib.getNumber(value, undefined);
                    break;
                default:
                    this._applyBillStyle(icon, event.key, value);
                    break;
            }
        }
        _handleModelStyle(event) {
            const value = event.target.get(event.key);
            const model = this._getModel();
            switch (event.key) {
                case CZMAP.StyleProperty.VISIBLE:
                    model.show = value;
                    break;
                case CZMAP.ModelStyleProperty.SOURCE:
                    model.uri = value;
                    break;
                case CZMAP.ModelStyleProperty.POSE:
                    this._updatePositionAndPose();
                    break;
                case CZMAP.ModelStyleProperty.SCALE:
                    model.scale = CZMAP.CesiumAttrib.getNumber(value, 1);
                    break;
            }
        }
        _updatePositionAndPose() {
            let position = this.geometry.coordinates.slice();
            const style = this.style;
            const refline = this.featureLayer.parent.refLine;
            if (refline) {
                const np = refline.findNearestPoint(position);
                if (np != null) {
                    position[0] = np[0];
                    position[1] = np[1];
                }
            }
            /// 
            this._transformCoordinates(position);
            /// 
            this._box.setMin(position);
            this._box.setMax(position);
            ///
            const pose = style.model ? style.model.pose : [0, 0, 0];
            const cpos = CZMAP.CesiumAttrib.getCartesian3Degree(position);
            /// 方位角减去90度，cesium默认方向为东
            const hpr = Cesium.HeadingPitchRoll.fromDegrees(pose[0] - 90, pose[1], pose[2], this._temp_hpr);
            const ori = Cesium.Transforms.headingPitchRollQuaternion(cpos, hpr, undefined, undefined, this._temp_ori);
            ///
            const vlo = this.vectorLayer.pointAnimation;
            /// 不起用动画
            if (!vlo.enable) {
                this._entity.position = cpos;
                this._entity.orientation = ori;
                return;
            }
            ///
            const p1 = this._temp_pos2;
            const p2 = this._temp_pos1;
            /// 第一个点
            if (p1 === undefined) {
                this._temp_pos1 = Cesium.Cartesian3.clone(cpos);
                this._temp_pos2 = Cesium.Cartesian3.clone(cpos);
                /// 使用当前位置和初始方位
                this._entity.position = cpos;
                this._entity.orientation = ori;
                return;
            }
            /// 和上一个点的位置是一样的
            if (Cesium.Cartesian3.equals(cpos, p1)) {
                return;
            }
            Cesium.Cartesian3.clone(cpos, p2);
            const time = vlo.duration;
            const t0 = this.view3d.czviewer.scene.lastRenderTime.clone(this._temp_date0);
            let t1, t2;
            if (vlo.maxDistance && vlo.maxDistance < Cesium.Cartesian3.distance(p1, p2)) {
                t1 = Cesium.JulianDate.addSeconds(t0, -time, this._temp_date2);
                t2 = t0.clone(this._temp_date1);
            }
            else {
                t1 = t0.clone(this._temp_date1);
                t2 = Cesium.JulianDate.addSeconds(t0, time, this._temp_date2);
            }
            const samp = new Cesium.SampledPositionProperty();
            samp.forwardExtrapolationType = Cesium.ExtrapolationType.HOLD;
            samp.addSample(t1, p1);
            samp.addSample(t2, p2);
            this._entity.position = samp;
            const vop = new Cesium.VelocityOrientationProperty(samp);
            const oldGetValue = vop.getValue;
            vop.getValue = (time, result) => {
                if (Cesium.JulianDate.compare(time, t2) >= 0)
                    time = Cesium.JulianDate.addSeconds(t2, -step, this._temp_date0);
                return oldGetValue.call(vop, time, result) || ori;
            };
            this._entity.orientation = vop;
            /// 交换
            const temp = this._temp_pos1;
            this._temp_pos1 = this._temp_pos2;
            this._temp_pos2 = temp;
        }
    }
    Point3D.fullrange = new Cesium.TimeInterval({
        start: new Cesium.JulianDate(),
        stop: new Cesium.JulianDate(3000000)
    });
    CZMAP.Point3D = Point3D;
})(CZMAP || (CZMAP = {}));
/// <reference path="Feature3D.ts" />
var CZMAP;
(function (CZMAP) {
    const step = 1.0 / 60.0;
    class PolylineItem {
    }
    /** @internal */
    class Polyline3D extends CZMAP.Feature3D {
        constructor(parent) {
            super(parent);
            this._items = [];
            this._box = new CZMAP.BoundingBox();
            this._updateHandle = 0;
        }
        get box() {
            return this._box;
        }
        _init() {
        }
        _clearWall() {
            const ets = this.view3d.entities;
            this._items.forEach(i => {
                ets.remove(i.wall);
                i.wall = undefined;
            });
        }
        _clearPolyline() {
            const pls = this.view3d.polylines;
            this._items.forEach(i => {
                pls.remove(i.polyline);
                i.polyline = undefined;
            });
        }
        _release() {
            this._clearWall();
            this._clearPolyline();
        }
        _onVisibleChangle() {
            const v = this.visible;
            this._items.forEach(i => {
                if (i.wall)
                    i.wall.show = v;
                if (i.polyline)
                    i.polyline.show = v;
            });
        }
        _updateWalls() {
            const wallStyle = this.style.wall;
            const minHeight = 0;
            const maxHeight = wallStyle.height;
            const ets = this.view3d.entities;
            this._items.forEach(it => {
                const num = it.positions.length;
                let p0 = it.positions[0];
                const pts2 = [p0];
                for (let i = 1; i < num; ++i) {
                    const p1 = it.positions[i];
                    const d = Cesium.Cartesian3.distance(p0, p1);
                    const num = Math.round(d / maxHeight);
                    if (num > 0) {
                        for (let i = 1; i <= num; ++i) {
                            pts2.push(Cesium.Cartesian3.lerp(p0, p1, i / num, new Cesium.Cartesian3()));
                        }
                    }
                    else {
                        pts2.push(p1);
                    }
                    p0 = p1;
                }
                const min = pts2.map(() => minHeight);
                const max = pts2.map(() => maxHeight);
                if (!it.wall)
                    it.wall = ets.add({ wall: {} });
                const wg = it.wall.wall;
                wg.positions = pts2;
                wg.minimumHeights = min;
                wg.maximumHeights = max;
            });
        }
        _createWalls() {
            if (!this.style.wall)
                return;
            this._updateWalls();
        }
        _createPoylines() {
            ///
            if (!this.style.stroke)
                return;
            this._items.forEach(item => {
                ///
                const pg = this.view3d.polylines.add({
                    show: true,
                    width: 1,
                    loop: false,
                    positions: item.positions
                });
                ///
                pg._czmap_obj = this.parent;
                item.polyline = pg;
            });
        }
        _updateGeometryImpl() {
            this._updateHandle = 0;
            /// 移除旧的模型
            this._release();
            ///
            const geo = this.feature.geometry;
            if (!geo)
                return;
            /// 处理单线和多线
            let coords;
            if (geo.type == CZMAP.GeometryType.POLYLINE)
                coords = [geo.coordinates];
            else if (geo.type == CZMAP.GeometryType.MULTI_POLYLINE)
                coords = geo.coordinates;
            else
                return;
            /// 投影变换
            this._transformCoordinates(coords);
            ///
            const box = new CZMAP.BoundingBox();
            this._items = coords.map(pts => {
                const positions = pts.map(pt => {
                    pt[2] = CZMAP.defaultValue(pt[2], 0);
                    let [x, y, z] = pt;
                    box.mergeXYZ(x, y, z);
                    return Cesium.Cartesian3.fromDegrees(...pt);
                });
                return {
                    polyline: undefined,
                    wall: undefined,
                    coords: pts,
                    positions,
                    length: calcLength(positions)
                };
            });
            /// 
            this._createPoylines();
            this._createWalls();
            ///
            this._box = box;
            this._notifyStyle();
        }
        _updateGeometry() {
            cancelAnimationFrame(this._updateHandle);
            this._updateHandle = requestAnimationFrame(() => this._updateGeometryImpl());
        }
        _handleGeometryChange(event) {
            this._updateGeometry();
        }
        _handleStyleChange(event) {
            if (!this.style.stroke)
                this._clearPolyline();
            if (!this.style.wall)
                this._clearWall();
            super._handleStyleChange(event);
        }
        _handleStrokeStyle(event) {
            const value = event.target.get(event.key);
            this._items.forEach(i => {
                const p = i.polyline;
                switch (event.key) {
                    case CZMAP.StyleProperty.VISIBLE:
                        p.show = value;
                        break;
                    case CZMAP.StrokeStyleProperty.WIDTH:
                        p.width = value;
                        break;
                    case CZMAP.StrokeStyleProperty.VISIBLE_RANGE:
                        p.distanceDisplayCondition = CZMAP.CesiumAttrib.getDisplayDistance(value);
                        break;
                    case CZMAP.StrokeStyleProperty.DETAIL:
                        p.material = Polyline3D.getStrokeMaterial(value);
                }
            });
        }
        _handleWallStyle(event) {
            const value = event.target.get(event.key);
            this._items.forEach(i => {
                const entity = i.wall;
                const wall = entity.wall;
                const wallStyle = this.style.wall;
                const height = wallStyle.height;
                const repeatY = wallStyle.imageRepeatY;
                switch (event.key) {
                    case CZMAP.StyleProperty.VISIBLE:
                        entity.show = value;
                        break;
                    case CZMAP.WallStyleProperty.VISIBLE_RANGE:
                        wall.distanceDisplayCondition = CZMAP.CesiumAttrib.getDisplayDistance(value);
                        break;
                    case CZMAP.WallStyleProperty.COLOR:
                        wall.material = CZMAP.CesiumAttrib.getColor(wallStyle.color);
                        break;
                    case CZMAP.WallStyleProperty.HEIGHT:
                        this._updateWalls();
                        break;
                    case CZMAP.WallStyleProperty.IMAGE:
                    case CZMAP.WallStyleProperty.IMAGE_REPEAT_Y:
                        wall.material = new Cesium.ImageMaterialProperty({
                            image: wallStyle.image,
                            repeat: new Cesium.Cartesian2(i.length / height * repeatY, repeatY),
                            transparent: true,
                        });
                        break;
                    case CZMAP.WallStyleProperty.OUTLINE_COLOR:
                    case CZMAP.WallStyleProperty.OUTLINE_WITDH:
                        if (wallStyle.outlineColor && wallStyle.outlineWidth) {
                            wall.outlineColor = CZMAP.CesiumAttrib.getColor(wallStyle.outlineColor);
                            wall.outlineWidth = wallStyle.outlineWidth;
                            wall.outline = true;
                        }
                        else {
                            wall.outline = false;
                        }
                        break;
                }
            });
        }
        static getStrokeMaterial(detail) {
            if (!detail) {
                return Cesium.Material.fromType(Cesium.Material.ColorType, {
                    color: Cesium.Color.WHITE
                });
            }
            switch (detail.type) {
                case CZMAP.StrokeDetailType.ARROW:
                    //type = 'PolylineArrow'; break;
                    return Cesium.Material.fromType(Cesium.Material.PolylineArrowType, {
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE)
                    });
                case CZMAP.StrokeDetailType.DASH:
                    const dash = detail;
                    return Cesium.Material.fromType(Cesium.Material.PolylineDashType, {
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE),
                        gapColor: CZMAP.CesiumAttrib.getColor(dash.dashColor, Cesium.Color.TRANSPARENT),
                        dashLength: CZMAP.Types.defaultValue(dash.dashLength, 16),
                        dashPattern: CZMAP.Types.defaultValue(dash.dashPattern, 255)
                    });
                case CZMAP.StrokeDetailType.GLOW:
                    const glow = detail;
                    return Cesium.Material.fromType(Cesium.Material.PolylineGlowType, {
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE),
                        glowPower: CZMAP.Types.defaultValue(glow.glowPower, 0.25),
                        taperPower: CZMAP.Types.defaultValue(glow.taperPower, 1.0)
                    });
                case CZMAP.StrokeDetailType.OUTLINE:
                    const outl = detail;
                    return Cesium.Material.fromType(Cesium.Material.PolylineOutlineType, {
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE),
                        outlineColor: CZMAP.CesiumAttrib.getColor(outl.outlineColor, Cesium.Color.BLACK),
                        outlineWidth: CZMAP.Types.defaultValue(outl.outlineWidth, 1.0)
                    });
                case CZMAP.StrokeDetailType.NORMAL:
                default:
                    return Cesium.Material.fromType(Cesium.Material.ColorType, {
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE)
                    });
            }
        }
        static getStrokeMaterialProperty(detail) {
            if (!detail)
                return Cesium.Color.WHITE;
            switch (detail.type) {
                case CZMAP.StrokeDetailType.NORMAL:
                    return CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE);
                case CZMAP.StrokeDetailType.DASH:
                    return new Cesium.PolylineDashMaterialProperty({
                        color: CZMAP.CesiumAttrib.getColor(detail.color),
                        gapColor: CZMAP.CesiumAttrib.getColor(detail.dashColor),
                        dashLength: CZMAP.Types.defaultValue(detail.dashLength, 16),
                        dashPattern: CZMAP.Types.defaultValue(detail.dashPattern, 255)
                    });
                case CZMAP.StrokeDetailType.GLOW:
                    return new Cesium.PolylineGlowMaterialProperty({
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE),
                        glowPower: CZMAP.Types.defaultValue(detail.glowPower, 0.25),
                        taperPower: CZMAP.Types.defaultValue(detail.taperPower, 1.0)
                    });
                case CZMAP.StrokeDetailType.ARROW:
                    return new Cesium.PolylineArrowMaterialProperty(CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE));
                case CZMAP.StrokeDetailType.OUTLINE:
                    return new Cesium.PolylineOutlineMaterialProperty({
                        color: CZMAP.CesiumAttrib.getColor(detail.color, Cesium.Color.WHITE),
                        outlineColor: CZMAP.CesiumAttrib.getColor(detail.outlineColor, Cesium.Color.BLACK),
                        outlineWidth: CZMAP.Types.defaultValue(detail.outlineWidth, 1.0)
                    });
            }
        }
    }
    CZMAP.Polyline3D = Polyline3D;
    function calcLength(positions) {
        let length = 0;
        if (positions.length > 0) {
            let p0 = positions[0];
            for (let i = 1; i < positions.length; ++i) {
                let p1 = positions[i];
                length += Cesium.Cartesian3.distance(p0, p1);
                p0 = p1;
            }
        }
        return length;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class StaticImageLayer3D extends CZMAP.StaticImageLayer {
        /**
         *
         */
        constructor(parent, options) {
            super(parent, options);
            const ops = options;
            ///
            var param = {};
            param.type = 'SingleTile';
            param.url = ops.url;
            param.visible = ops.visible;
            param.rectangle = Cesium.Rectangle.fromDegrees(...ops.extent);
            ///
            param.minimumLevel = CZMAP.Types.defaultValue(options.minLevel, 0);
            param.maximumLevel = CZMAP.Types.defaultValue(options.maxLevel, 18);
            ///
            this._ins = new Cegore.ImageLayer(param);
            this.view3d.cegore.images.add(this._ins);
            this._bb = CZMAP.BoundingBox.fromExtent(ops.extent);
            this.onProperty(CZMAP.LayerProperty.OPACITY, () => this._handleColorOpacity());
        }
        get view3d() { return this.map.view3d; }
        get layer() { return this._ins; }
        get boundBox() {
            return this._bb;
        }
        _onVisible() {
            this._ins.visible = this.visible;
        }
        _createInner() {
        }
        _destroyInner() {
            this.view3d.cegore.images.remove(this._ins);
        }
        _handleColorOpacity() {
            this._ins.alpha = this.opacity;
        }
    }
    CZMAP.StaticImageLayer3D = StaticImageLayer3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class TDTilesLayer3D extends CZMAP.TDTilesLayer {
        constructor(parent, options) {
            super(parent, options);
            this._view3d = parent.map.view3d;
            this._option = options;
            this._prepReady();
        }
        /** @override */
        _createInner() {
            if (this._3dtiles)
                return;
            const options = this._option;
            this._3dtiles = new Cesium.Cesium3DTileset({
                url: options.url,
                maximumScreenSpaceError: options.maxSSE,
                dynamicScreenSpaceErrorFactor: 20,
                show: options.visible
            });
            this._3dtiles.readyPromise.then(() => this._readyResolve(), (r) => this._readyReject(r));
            this._onTransformChange();
            this._view3d.czscene.primitives.add(this._3dtiles);
        }
        _destroyInner() {
            if (this._3dtiles) {
                this._view3d.czscene.primitives.remove(this._3dtiles);
                this._3dtiles = undefined;
            }
        }
        /**
         * 获取图层类型名称
         * @override
         */
        get type() { return 'TDTilesLayer3D'; }
        /**
         * 返回图层包围盒
         * @return
         */
        get boundBox() {
            const sp = this._3dtiles.boundingSphere;
            const pos = new Cegore.Position(sp.center);
            const size = sp.radius * 2;
            const llsize = size / 111000;
            return CZMAP.BoundingBox.formCenterSize([pos.x, pos.y, pos.z], [llsize, llsize, size]);
        }
        get maxSSE() { return this._option.maxSSE; }
        set maxSSE(maxSSE) {
            this._option.maxSSE = maxSSE;
            this._3dtiles.maximumScreenSpaceError = maxSSE;
        }
        /** @override */
        flyTo(option) {
            this._zoomOrFlyto(option);
        }
        get tdtiles() { return this._3dtiles; }
        /**
         * 设置显示和隐藏
         * @param {*} v
         * @override
         */
        _onVisible(v) {
            if (this._3dtiles)
                this._3dtiles.show = v;
        }
        /**
         *
         * @param option
         */
        _zoomOrFlyto(option) {
            /// 当所有模型就绪后
            if (!this._3dtiles)
                return;
            this._3dtiles.readyPromise.then(() => {
                this.view.flyToSphere(this._3dtiles.boundingSphere, option);
            });
        }
        _onTransformChange() {
            if (!this._3dtiles)
                return;
            this.ready.then(() => {
                if (!this._3dtiles.root)
                    return;
                const ts = this._3dtiles.root.transform;
                if (!Cesium.Matrix4.equals(ts, Cesium.Matrix4.IDENTITY)) {
                    console.warn('the 3dtileset has owner transform, abort layer setting.');
                    return;
                }
                const pos = this.position;
                const pose = this.pose;
                const scale = this.scale;
                const position = Cesium.Cartesian3.fromDegrees(...pos);
                const hpr = Cesium.HeadingPitchRoll.fromDegrees(pose[0], pose[1], pose[2]);
                const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
                const modelMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(position, orientation, new Cesium.Cartesian3(...scale), new Cesium.Matrix4());
                this._3dtiles.modelMatrix = modelMatrix;
            });
        }
    }
    CZMAP.TDTilesLayer3D = TDTilesLayer3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const MapTypeMaps = {
        'zmap': 'ZMapImage',
        'url': 'UrlTemplate',
        'UrlTemplate': 'UrlTemplate',
        'dem': 'ZMapDemImage',
        'tms': 'UrlTemplate'
    };
    const SchemeMaps = {
        [CZMAP.TileLayerScheme.Geographic]: 'Geographic-level-0',
        [CZMAP.TileLayerScheme.WebMercator]: 'WebMercator'
    };
    /** @internal */
    class TileLayer3D extends CZMAP.TileLayer {
        /**
         *
         */
        constructor(parent, options) {
            super(parent, options);
            const ops = options;
            const style = options;
            ///
            var param = {};
            param.type = MapTypeMaps[options.mapType];
            param.url = ops.url;
            param.visible = options.visible;
            param.rectangle = options.extent;
            ///
            param.minimumLevel = CZMAP.Types.defaultValue(options.minLevel, 1);
            param.maximumLevel = CZMAP.Types.defaultValue(options.maxLevel, 18);
            param.scheme = SchemeMaps[options.scheme];
            param.subdomains = options.subdomains;
            ///
            this._ins = new Cegore.ImageLayer(param);
            this.view3d.cegore.images.add(this._ins);
            this.onProperty(CZMAP.LayerProperty.OPACITY, () => this._handleColorOpacity());
        }
        get view3d() { return this.map.view3d; }
        get layer() { return this._ins; }
        get boundBox() {
            return new CZMAP.BoundingBox();
        }
        _onVisible() {
            this._ins.visible = this.visible;
        }
        _createInner() {
        }
        _destroyInner() {
            this.view3d.cegore.images.remove(this._ins);
        }
        _handleColorOpacity() {
            this._ins.alpha = this.opacity;
        }
    }
    CZMAP.TileLayer3D = TileLayer3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const defaultOptions = {
        filterParam: { split_X: 15, split_Y: 2, max_X: 75, max_Y: 100 },
        scale: [1, 1, 1],
        offset: [0, 0, 0],
        mode: 1,
        sliceNum: [8, 8]
    };
    /**
     * 体数据图层
     */
    class VolumeLayer3D extends CZMAP.VolumeLayer {
        constructor(parent, options) {
            super(parent, options);
            this._view3d = parent.map.view3d;
            this._option = options;
            this._box = new CZMAP.BoundingBox();
            this._box.setMin(options.volumeOptions.volumeMin);
            this._box.setMax(options.volumeOptions.volumeMax);
        }
        /** @override */
        _createInner() {
            if (this._volumeRender)
                return;
            const opts = this._option.volumeOptions;
            this._volumeRender = new ZMapVolume.VolumeRender(this._view3d.zmap3d, defaultOptions);
            // 切片工具
            this._volumeSliceTool = new ZMapVolume.SliceTool(this._view3d.zmap3d, {
            // style:{
            //     pointColor:undefined
            // }
            });
            // 参考网格工具
            this._volumeGridTool = new ZMapVolume.GridLine(this._view3d.zmap3d, {
                stepZ: 100,
                // style:{
                //     pointColor:undefined
                // }
            });
            // 范围剖切工具（动态剖切）
            this._volumeRectTool = new ZMapVolume.RectPlane(this._view3d.zmap3d, {
            // style:{
            //     pointColor:undefined
            // }
            });
            this._volumeSliceTool.show = false;
            this._volumeGridTool.show = false;
            this._volumeRectTool.show = false;
            // 实现了_Common接口的工具，均能绑定到vol上面，以实现自动更新视图
            // 如调用vol.scale = [1,1,2] (即z轴范围扩大两倍)
            // 相应的工具会自动扩大范围
            this._volumeRender.binding(this._volumeSliceTool);
            this._volumeRender.binding(this._volumeGridTool);
            this._volumeRender.binding(this._volumeRectTool);
            this._volumeRender.loadData({
                url: opts.volumeData,
                min: opts.volumeMin,
                max: opts.volumeMax,
                offset: opts.volumeOffset,
                scale: opts.volumeScale,
                mode: opts.volumeMode,
                rayDir: opts.volumeRayDir,
                sliceNum: opts.volumeSliceNum,
                colorMap: opts.volumeColorMap,
                dataValueRange: opts.volumeDataValueRange,
                sampleNum: opts.volumeSampleNum
            });
            this._volumeRender.showVolume();
        }
        _destroyInner() {
            if (this._volumeRender) {
                this._volumeRender.destroy();
                this._volumeRender = undefined;
            }
        }
        /**
         * 获取体数据对象
         */
        get volumeRender() { return this._volumeRender; }
        get volumeSlice() { return this._volumeSliceTool; }
        get volumeGrid() { return this._volumeGridTool; }
        get volumeRect() { return this._volumeRectTool; }
        /**
         * 设置显示和隐藏
         * @param {*} v
         * @override
         */
        _onVisible(v) {
            this._volumeRender.show = v;
        }
        setMode(mode) {
            if (mode === 'volume') {
                this._volumeRender.setVolume();
                this._volumeSliceTool.show = false;
            }
            if (mode === 'slice') {
                this._volumeRender.setSlice();
                this._volumeSliceTool.show = false;
            }
        }
        setColorMap(colorMap) {
            this._volumeRender.colorMap = colorMap;
        }
        setSlices(slices) {
            this._volumeRender.setSlice(slices);
        }
        showGrids(show) {
            this.volumeGrid.show = show;
        }
        isShowGrids() {
            return this.volumeGrid.show;
        }
    }
    CZMAP.VolumeLayer3D = VolumeLayer3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 可以移动的图层
     * @internal
     */
    class MoveableLayerUE extends CZMAP.MoveableLayer {
        constructor(parent, options) {
            super(parent, options);
        }
        /**
         * 获取包围盒
         */
        get boundBox() {
            return this._uvlayer.box;
        }
        flyTo(option) {
            this._uvlayer.flyTo(option);
        }
        move(actions) {
            if (!Array.isArray(actions))
                actions = [actions];
            this._uvlayer.move(actions);
        }
        setOpacity(opacity, color) {
            this.opacity = opacity;
            if (CZMAP.defined(color))
                this.color = color;
        }
        _onVisible(v) {
            this._uvlayer.setVisible(v);
        }
        _destroyInner() {
            this._uvlayer.removeLayer();
        }
        _onTransformChange() {
            const aa = {};
            aa.position = this.position;
            aa.rotate = this.pose;
            aa.scale = this.scale;
            this._uvlayer.updateLayer(aa);
        }
    }
    CZMAP.MoveableLayerUE = MoveableLayerUE;
})(CZMAP || (CZMAP = {}));
/// <reference path="MoveableLayerUE.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class DynActorLayerUE extends CZMAP.MoveableLayerUE {
        constructor(parent, option) {
            super(parent, option);
            this._option = option;
            this._uvlayer = new CZMAP.UELayerProxy(this.view, 'dynActor', this);
        }
        _createInner() {
            const { path, position, pose, scale } = this._option;
            this._uvlayer.createLayer({
                path,
                visible: false,
                position,
                rotate: pose,
                scale,
            });
        }
    }
    CZMAP.DynActorLayerUE = DynActorLayerUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class DecalLayerUE extends CZMAP.DecalLayer {
        constructor(parent, option) {
            super(parent, option);
            this._decalSize = 512;
            this._option = option;
            this._uvlayer = new CZMAP.UELayerProxy(this.view, 'decal', this);
            this._decalType = option.decalType;
            this._decalSize = CZMAP.defaultValue(option.decalSize, 512);
            this._decalWater = option.decalWater;
            if (option.image) {
                this._image = option.image.uri;
                this._size = option.image.size;
                this._box = new CZMAP.BoundingBox();
                this._imageReady = Promise.resolve();
            }
            else {
                this._buildByPolygon();
            }
        }
        async _fetchPolygon() {
            let polygons;
            const option = this._option;
            const url = option.uri || option.url;
            if (url) {
                const geojson = (await CZMAP.fetchJSON(url));
                polygons = [];
                geojson.features.forEach(f => {
                    const geo = f.geometry;
                    const type = geo === null || geo === void 0 ? void 0 : geo.type;
                    switch (type) {
                        case 'Polygon':
                            polygons.push(geo.coordinates);
                            break;
                        case 'MultiPolygon':
                            polygons.push(...geo.coordinates);
                            break;
                        default:
                            console.warn('Decal不支持此种类型：', type);
                            break;
                    }
                });
                return polygons;
            }
            if (option.polygons)
                polygons = option.polygons;
            else if (option.polygon)
                polygons = [option.polygon];
            else if (option.points)
                polygons = [[option.points]];
            return polygons;
        }
        _buildByPolygon() {
            this._imageReady = this._fetchPolygon().then(pg => this._build(pg));
        }
        _build(polygons) {
            const { height, thickness } = this._option;
            const { box, position, size, uri } = buildDecalImage({
                polygons,
                height,
                thickness,
                texsize: this._decalSize
            });
            this.position = position;
            this._size = size;
            this._image = uri;
            this._box = box;
        }
        get boundBox() {
            return this._box;
        }
        _onVisible(v) {
            this._uvlayer.setVisible(v);
        }
        _createInner() {
            this._imageReady.then(() => {
                this._uvlayer.createLayer({
                    visible: false,
                    image: CZMAP.absURL(this._image),
                    decalType: this._decalType,
                    decalWater: this._decalWater,
                    size: this._size,
                    color: this.color,
                    opacity: this.opacity
                });
            });
        }
        _destroyInner() {
            if (this._uvlayer) {
                this._uvlayer.removeLayer();
                this._uvlayer = undefined;
            }
        }
        _onTransformChange() {
            const { position, pose, scale } = this;
            this._uvlayer.updateLayer({ position, rotate: pose, scale });
        }
    }
    CZMAP.DecalLayerUE = DecalLayerUE;
    function buildDecalImage(option) {
        const height = option.height || 0;
        const thickness = option.thickness || 10;
        const box = new CZMAP.BoundingBox();
        box.mergeCoordinates(option.polygons);
        const ht = thickness / 2;
        box.minz = height - ht;
        box.maxz = height + ht;
        const center = Cesium.Cartesian3.fromDegrees(...box.getCenter());
        const martix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
        Cesium.Matrix4.inverseTransformation(martix, martix);
        const texsize = CZMAP.defaultValue(option.texsize, 512);
        const canvas = document.createElement('canvas');
        canvas.width = texsize;
        canvas.height = texsize;
        ///
        const polys = option.polygons.map(p => p.map(p => p.map(p => {
            const [x, y] = p;
            const position = Cesium.Cartesian3.fromDegrees(x, y, height);
            Cesium.Matrix4.multiplyByPoint(martix, position, position);
            return position;
        })));
        const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(polys.flat(2));
        const bsize = Cesium.Cartesian3.subtract(aabb.maximum, aabb.minimum, new Cesium.Cartesian3());
        Cesium.Cartesian3.multiplyByScalar(bsize, 0.05, bsize);
        Cesium.Cartesian3.add(aabb.maximum, bsize, aabb.maximum);
        Cesium.Cartesian3.subtract(aabb.minimum, bsize, aabb.minimum);
        Cesium.Cartesian3.subtract(aabb.maximum, aabb.minimum, bsize);
        const minx = aabb.minimum.x;
        const maxy = aabb.maximum.y;
        function toCanvasCoord(p) {
            return {
                x: (p.x - minx) / bsize.x * texsize,
                y: (maxy - p.y) / bsize.y * texsize
            };
        }
        //Path2D 
        const path = new Path2D();
        polys.flat().forEach(pl => {
            pl.forEach((p, i) => {
                const { x, y } = toCanvasCoord(p);
                if (i === 0)
                    path.moveTo(x, y);
                else
                    path.lineTo(x, y);
            });
            path.closePath();
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fill(path);
        const uri = canvas.toDataURL();
        //console.info(uri);
        return {
            box,
            position: box.getCenter(),
            size: [bsize.x / 2, bsize.y / 2, thickness / 2],
            uri
        };
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class FeatureLayerUE extends CZMAP.FeatureLayer {
        _createInner() {
            if (!this.geometry)
                return;
            ///
            if (this.geometry.type === CZMAP.GeometryType.POINT)
                this._render = new CZMAP.PointUE(this);
            if (this.geometry.type === CZMAP.GeometryType.POLYLINE)
                this._render = new CZMAP.PolylineUE(this);
        }
        _destroyInner() {
            if (this._render) {
                this._render.destroy();
                this._render = undefined;
            }
        }
        get render() {
            return this._render;
        }
        /** 飞到模型 */
        flyTo(option) {
            var _a;
            (_a = this._render) === null || _a === void 0 ? void 0 : _a.flyTo(option);
        }
    }
    CZMAP.FeatureLayerUE = FeatureLayerUE;
})(CZMAP || (CZMAP = {}));
/// <reference path="../FeatureInner.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 基于UnrealView的要素对象
     * @internal
     */
    class FeatureUE extends CZMAP.FeatureRender {
        constructor(parent, type) {
            super(parent);
            this._cachedUpdate = {};
            this._uvlayer = new CZMAP.UELayerProxy(this.viewue, type, parent);
        }
        /** 快捷方式到 map.view3d */
        get viewue() { return this.map.view; }
        _onVisibleChangle() {
            this._uvlayer.setVisible(this.visible);
        }
        _release() {
            this._uvlayer.removeLayer();
        }
        /**
         * 请求更新图层
         * @param style 图层样式
         */
        _requestUpdate(style) {
            ///
            CZMAP.deepAssign(this._cachedUpdate, style);
            ///
            cancelAnimationFrame(this._cachedHandle);
            this._cachedHandle = requestAnimationFrame(() => {
                this._preUpdateLayer(this._cachedUpdate);
                this._uvlayer.updateLayer(this._cachedUpdate);
                this._cachedUpdate = {};
            });
        }
        _preUpdateLayer(cachedUpdate) {
        }
        /** 飞到模型 */
        flyTo(option) {
            this._uvlayer.flyTo(option);
        }
    }
    CZMAP.FeatureUE = FeatureUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class FlowsLayerUE extends CZMAP.FlowsLayer {
        constructor(parent, option) {
            super(parent, option);
            this._box = new CZMAP.BoundingBox();
            this._flows = {};
            this._option = option;
            this._setFlows(option.flows);
            this._uvlayer = new CZMAP.UELayerProxy(this.view, 'flows', this);
        }
        get boundBox() {
            return this._box;
        }
        setFlowsParam(param) {
            this._setFlows(param);
        }
        _onVisible(v) {
            this._uvlayer.setVisible(v);
        }
        _createInner() {
            this._uvlayer.createLayer({
                visible: false,
                flows: this._flows,
                flowsType: this._option.flowsType,
                position: this.position
            });
        }
        _destroyInner() {
            this._uvlayer.removeLayer();
        }
        _onTransformChange() {
            const { position, pose, scale } = this;
            this._uvlayer.updateLayer({ position, rotate: pose, scale });
        }
        _setFlows(flows) {
            const flowsCopy = Object.assign({}, flows);
            if (flowsCopy.path) {
                const { position, pts, box } = toLocalCoords(flowsCopy.path);
                flowsCopy.path = pts;
                ///
                this.position = position;
                this._box = box;
            }
            Object.assign(this._flows, flowsCopy);
            if (this._uvlayer) {
                this._uvlayer.updateLayer({ flows: flowsCopy });
            }
        }
    }
    CZMAP.FlowsLayerUE = FlowsLayerUE;
    function toLocalCoords(points) {
        const box = new CZMAP.BoundingBox();
        box.mergeCoordinates(points);
        const position = box.getCenter();
        const center = Cesium.Cartesian3.fromDegrees(...position);
        const martix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
        Cesium.Matrix4.inverseTransformation(martix, martix);
        const pts = points.map((pt) => {
            const pos = Cesium.Cartesian3.fromDegrees(...pt);
            Cesium.Matrix4.multiplyByPoint(martix, pos, pos);
            return CZMAP.createOrUpdatePoint(pos.x, -pos.y, pos.z);
        });
        return {
            position, pts, box
        };
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class FoliageLayerUE extends CZMAP.FoliageLayer {
        constructor(parent, option) {
            super(parent, option);
            this._uelayer = new CZMAP.UELayerProxy(this.view, 'foliage', this);
            const items = toFoliageItemDetail(option.foliages);
            if (items.length > 0)
                this._uelayer.executeLayer({ 'add': items });
        }
        _addItems(items) {
            this._uelayer.executeLayer({ 'add': items });
        }
        _updateItems(items) {
            this._uelayer.executeLayer({ 'add': items });
        }
        _removeItems(items) {
            this._uelayer.executeLayer({ 'remove': items });
        }
        _createInner() {
            this._uelayer.createLayer({
                visible: this.visible,
                foliages: []
            });
        }
        _destroyInner() {
            this._uelayer.removeLayer();
        }
        _onVisible(v) {
            this._uelayer.setVisible(v);
        }
    }
    CZMAP.FoliageLayerUE = FoliageLayerUE;
    function toFoliageItemDetail(infoes) {
        const details = [];
        if (Array.isArray(infoes)) {
            infoes.forEach(info => info.items.forEach(item => {
                details.push(Object.assign({ mesh: info.mesh }, item));
            }));
        }
        return details;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class LayerManagerUE extends CZMAP.LayerManager {
        constructor(map) {
            super(map);
            this._register('tile', CZMAP.TileLayerUE);
            this._register('map', CZMAP.TileLayerUE);
            //this._register('model', ModelLayer);
            this._register('3dtiles', CZMAP.TDTilesLayerUE);
            this._register('feature', CZMAP.FeatureLayerUE);
            this._register('dynActor', CZMAP.DynActorLayerUE);
            this._register('wrappedUE', CZMAP.WrappedLayerUE);
            this._register('decal', CZMAP.DecalLayerUE);
            this._register('flows', CZMAP.FlowsLayerUE);
            this._register('volume', CZMAP.VolumeDataLayerUE);
            this._register('foliage', CZMAP.FoliageLayerUE);
        }
        get viewue() { return this.map.view; }
        get uview() { return this.viewue.uview; }
        get uvapi() { return this.viewue.uvapi; }
        _clearTerrain() {
            this.uvapi.setTerrain({ url: '' });
        }
        _applyTerrain(terrain) {
            const url = new URL(terrain.url + '/tile/dem/tms/layer.json');
            if (CZMAP.defined(terrain.option.heightScale))
                url.searchParams.set('scale', terrain.option.heightScale.toString());
            if (CZMAP.defined(terrain.option.heightScaleOffset))
                url.searchParams.set('scaleOffset', terrain.option.heightScaleOffset.toString());
            if (CZMAP.defined(terrain.option.heightOffset))
                url.searchParams.set('offset', terrain.option.heightOffset.toString());
            this.uvapi.setTerrain({
                url: url.toString(),
                maxSSE: terrain.option.maxSSE,
                opacity: terrain.opacity
            });
        }
    }
    CZMAP.LayerManagerUE = LayerManagerUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function getCssColor(v) {
        if (v instanceof Cesium.Color)
            return v.toCssColorString();
        return v;
    }
    function calcBorder(left, top, right, bottom, radius) {
        const path = new Path2D();
        const r90 = Math.PI / 2;
        ///
        if (radius) {
            const s = Math.min(right - left, bottom - top);
            const r = Math.min(radius, s / 2);
            path.moveTo(left + r, top);
            path.lineTo(right - r, top);
            path.arc(right - r, top + r, r, r90 * 3, r90 * 4, false);
            path.lineTo(right, bottom - r);
            path.arc(right - r, bottom - r, r, 0, r90, false);
            path.lineTo(left + r, bottom);
            path.arc(left + r, bottom - r, r, r90, r90 * 2, false);
            path.lineTo(left, top + r);
            path.arc(left + r, top + r, r, r90 * 2, r90 * 3, false);
        }
        else {
            path.moveTo(0, 0);
            path.lineTo(right, 0);
            path.lineTo(right, bottom);
            path.lineTo(0, bottom);
            path.lineTo(0, 0);
        }
        return path;
    }
    class LabelRender {
        static instance() {
            return labelRender;
        }
        static render2Image(label) {
            return labelRender.render(label).toImage();
        }
        constructor() {
            this._canvas = document.createElement('canvas');
            this._ctx = this._canvas.getContext('2d');
        }
        get canvas() { return this._canvas; }
        render(label) {
            if (!(label instanceof CZMAP.LabelStyle)) {
                label = new CZMAP.LabelStyle(label);
            }
            const ctx = this._ctx;
            ctx.font = label.font;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const tm = ctx.measureText(label.text);
            const [paddingx, paddingy] = label.padding;
            const bbWidth = label.background ? label.backgroundBorderWidth : 0;
            const width = tm.width + paddingx * 2 + label.borderWidth * 2 + bbWidth * 2;
            const height = Math.abs(tm.actualBoundingBoxDescent - tm.actualBoundingBoxAscent) + paddingy * 2 + label.borderWidth * 2 + bbWidth * 2;
            const ox = paddingx + label.borderWidth + bbWidth;
            const oy = paddingy + label.borderWidth + bbWidth;
            this._canvas.width = width;
            this._canvas.height = height;
            this._canvas.style.width = width + 'px';
            this._canvas.style.height = height + 'px';
            /// 修改canvas尺寸后，canvas的状态会重置
            ctx.font = label.font;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            if (label.background) {
                ctx.fillStyle = getCssColor(label.backgroundColor);
                const borderPath = calcBorder(bbWidth / 2, bbWidth / 2, width - bbWidth / 2, height - bbWidth / 2, label.backgroundBorderRadius);
                ctx.fill(borderPath);
                if (label.backgroundBorderWidth) {
                    ctx.lineWidth = label.backgroundBorderWidth;
                    ctx.strokeStyle = label.backgroundBorderColor;
                    ctx.stroke(borderPath);
                }
            }
            if (label.borderWidth && label.borderColor) {
                ctx.strokeStyle = getCssColor(label.borderColor);
                ctx.lineWidth = label.borderWidth;
                ctx.strokeText(label.text, ox, oy);
            }
            ctx.fillStyle = getCssColor(label.color);
            ctx.fillText(label.text, ox, oy);
            return this;
        }
        toDataURL() {
            return this._canvas.toDataURL();
        }
        toImage() {
            return { src: this.toDataURL(), width: this.canvas.width, height: this.canvas.height };
        }
    }
    CZMAP.LabelRender = LabelRender;
    const labelRender = new LabelRender();
})(CZMAP || (CZMAP = {}));
/// <reference path="FeatureUE.ts" />
/// <reference path="../../utils/LabelRender.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class PointUE extends CZMAP.FeatureUE {
        /**
         */
        constructor(parent) {
            super(parent, 'point');
            /// 
            this._box = new CZMAP.BoundingBox();
            this._uvlayer.createLayer({ visible: true });
        }
        get box() {
            return this._box;
        }
        get position() { return this.geometry.coordinates; }
        ;
        /** 飞到模型 */
        flyTo(option) {
            this._uvlayer.uvapi.flyTo({
                target: this.position,
                option
            });
        }
        _init() {
        }
        _handleGeometryChange() {
            this._updatePositionAndPose();
        }
        _handleStyleChange(event) {
            super._handleStyleChange(event);
        }
        /**
         */
        _handleLabelStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            ///
            const label = { [event.key]: value };
            this._requestUpdate({ label });
        }
        _handleIconStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            const icon = {};
            switch (event.key) {
                case CZMAP.IconStyleProperty.SOURCE:
                    icon.src = CZMAP.absURL(value);
                    break;
                default:
                    icon[event.key] = value;
                    break;
            }
            this._requestUpdate({ icon });
        }
        _handleModelStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            const model = {};
            switch (event.key) {
                case CZMAP.StyleProperty.VISIBLE:
                    model.visible = value;
                    break;
                case CZMAP.ModelStyleProperty.SOURCE:
                    model.src = value;
                    break;
                case CZMAP.ModelStyleProperty.SCALE:
                    model.scale = value;
                    break;
                case CZMAP.ModelStyleProperty.POSE:
                    model.pose = value;
                    break;
            }
            this._requestUpdate({ model });
        }
        _updatePositionAndPose() {
            this._requestUpdate({ position: this.position });
        }
        _preUpdateLayer(cachedUpdate) {
            const label = cachedUpdate.label;
            if (!label)
                return;
            const lc = {
                visible: label.visible,
                offset: label.offset,
                horizontalOrigin: label.horizontalOrigin,
                verticalOrigin: label.verticalOrigin,
                visibleRange: label.visibleRange,
                fadeDistance: label.fadeDistance,
                scaleDistance: label.scaleDistance,
                depthDistance: label.depthDistance
            };
            if (CZMAP.defined(label.text) ||
                CZMAP.defined(label.font) ||
                CZMAP.defined(label.color) ||
                CZMAP.defined(label.padding) ||
                CZMAP.defined(label.borderColor) ||
                CZMAP.defined(label.borderWidth) ||
                CZMAP.defined(label.background) ||
                CZMAP.defined(label.backgroundColor) ||
                CZMAP.defined(label.backgroundBorderColor) ||
                CZMAP.defined(label.backgroundBorderWidth) ||
                CZMAP.defined(label.backgroundBorderRadius)) {
                const labelRender = CZMAP.LabelRender.instance();
                labelRender.render(this.style.label);
                lc.src = labelRender.toDataURL();
                lc.width = labelRender.canvas.width;
                lc.height = labelRender.canvas.height;
            }
            delete cachedUpdate.label;
            cachedUpdate.labelIcon = lc;
        }
    }
    CZMAP.PointUE = PointUE;
})(CZMAP || (CZMAP = {}));
/// <reference path="FeatureUE.ts" />
var CZMAP;
(function (CZMAP) {
    class PolylineItem {
    }
    /** @internal */
    class PolylineUE extends CZMAP.FeatureUE {
        constructor(parent) {
            super(parent, 'polyline');
            this._items = [];
            this._box = new CZMAP.BoundingBox();
            this._updateHandle = 0;
            this._uvlayer.createLayer({ visible: true });
        }
        get box() {
            return this._box;
        }
        setAnimationPos(pos) {
            this._uvlayer.executeLayer({ setAnimationPos: pos });
        }
        startAnimation(seconds) {
            this._uvlayer.executeLayer({ startAnimation: seconds });
        }
        _init() {
        }
        _updateGeometryImpl() {
            var _a, _b;
            this._updateHandle = 0;
            ///
            const geo = this.feature.geometry;
            if (!geo)
                return;
            /// 处理单线和多线
            let coords;
            if (geo.type == CZMAP.GeometryType.POLYLINE)
                coords = [geo.coordinates];
            else if (geo.type == CZMAP.GeometryType.MULTI_POLYLINE)
                coords = geo.coordinates;
            else
                return;
            /// 投影变换
            this._transformCoordinates(coords);
            ///
            const box = new CZMAP.BoundingBox();
            this._items = coords.map(pts => {
                const positions = pts.map(pt => {
                    pt[2] = CZMAP.defaultValue(pt[2], 0);
                    let [x, y, z] = pt;
                    box.mergeXYZ(x, y, z);
                    return Cesium.Cartesian3.fromDegrees(...pt);
                });
                return {
                    polyline: undefined,
                    wall: undefined,
                    coords: pts,
                    positions,
                    length: calcLength(positions)
                };
            });
            /// 
            this._requestUpdate({
                positions: coords[0],
                style: {
                    wall: (_a = this.style.wall) === null || _a === void 0 ? void 0 : _a.toStyleOption(),
                    stroke: (_b = this.style.stroke) === null || _b === void 0 ? void 0 : _b.toStyleOption()
                },
            });
            ///
            this._box = box;
            this._notifyStyle();
        }
        _updateGeometry() {
            cancelAnimationFrame(this._updateHandle);
            this._updateHandle = requestAnimationFrame(() => this._updateGeometryImpl());
        }
        _handleGeometryChange(event) {
            this._updateGeometry();
        }
        _handleStyleChange(event) {
            super._handleStyleChange(event);
        }
        _handleStrokeStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            const stroke = {};
            switch (event.key) {
                case CZMAP.StyleProperty.VISIBLE:
                    stroke.visible = value;
                    break;
                case CZMAP.StrokeStyleProperty.FOLLOW_SURFACE:
                    stroke.followSurface = value;
                    break;
                case CZMAP.StrokeStyleProperty.DETAIL:
                    stroke.detail = value;
                    break;
                case CZMAP.StrokeStyleProperty.DEPTH_FAIL_DETAIL:
                    stroke.depthFailDetail = value;
                    break;
                case CZMAP.StrokeStyleProperty.WIDTH:
                    stroke.width = value;
                    break;
                case CZMAP.StrokeStyleProperty.DEPTH_CHECK:
                    stroke.depthCheck = value;
                    break;
                default:
                    stroke[event.key] = value;
                    //this._applyBillStyle(icon, event.key, value);
                    break;
            }
            this._requestUpdate({ style: { stroke } });
        }
        _handleWallStyle(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            const wall = {};
            switch (event.key) {
                case CZMAP.WallStyleProperty.IMAGE:
                    wall.image = CZMAP.absURL(value);
                    break;
                default:
                    wall[event.key] = value;
                    break;
            }
            this._requestUpdate({ style: { wall } });
        }
    }
    CZMAP.PolylineUE = PolylineUE;
    function calcLength(positions) {
        let length = 0;
        if (positions.length > 0) {
            let p0 = positions[0];
            for (let i = 1; i < positions.length; ++i) {
                let p1 = positions[i];
                length += Cesium.Cartesian3.distance(p0, p1);
                p0 = p1;
            }
        }
        return length;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class TDTilesLayerUE extends CZMAP.TDTilesLayer {
        constructor(parent, option) {
            super(parent, option);
            this._option = option;
            this._uvlayer = new CZMAP.UELayerProxy(this.view, '3dtiles', this);
        }
        get ready() {
            return this._uvlayer.ready;
        }
        get boundBox() {
            return this._uvlayer.box;
        }
        get uvapi() { return this._uvlayer.uvapi; }
        get maxSSE() { return this._option.maxSSE; }
        set maxSSE(maxSSE) {
            this._option.maxSSE = maxSSE;
            this._uvlayer.updateLayer({ maxSSE });
        }
        flyTo(option) {
            this._uvlayer.flyTo();
        }
        setMaterial(material) {
            this._uvlayer.updateLayer({ material });
        }
        _onVisible(v) {
            this._uvlayer.setVisible(v);
        }
        _createInner() {
            const { url, maxSSE, position, pose, scale, material } = this._option;
            this._uvlayer.createLayer({
                visible: false,
                url: CZMAP.absURL(url),
                maxSSE,
                position,
                rotate: pose,
                scale,
                material
            });
        }
        _destroyInner() {
            this._uvlayer.removeLayer();
        }
        _onTransformChange() {
            const { position, pose, scale } = this;
            this._uvlayer.updateLayer({ position, rotate: pose, scale });
        }
    }
    CZMAP.TDTilesLayerUE = TDTilesLayerUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class TileLayerUE extends CZMAP.TileLayer {
        constructor(parent, options) {
            super(parent, options);
            this._options = options;
            this._uvlayer = new CZMAP.UELayerProxy(this.view, 'image', this);
            const { url, mapType } = this._options;
            if (url && (mapType == 'zmap' || mapType == 'ZMapImage')) {
                this._uvlayer.createLayer({
                    url: CZMAP.absURL(this._options.url + '/tms/tilemapresource.xml'),
                    visible: false
                });
            }
        }
        get ready() {
            return this._uvlayer.ready;
        }
        get boundBox() {
            return this._uvlayer.box;
        }
        _onVisible(v) {
            this._uvlayer.setVisible(v);
        }
        _createInner() {
        }
        _destroyInner() {
            this._uvlayer.removeLayer();
        }
    }
    CZMAP.TileLayerUE = TileLayerUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class UnrealViewerHelp {
        constructor(view) {
            this._view = view;
        }
        get uview() { return this._view.uview; }
        get uvapi() { return this._view.uvapi; }
    }
    CZMAP.UnrealViewerHelp = UnrealViewerHelp;
})(CZMAP || (CZMAP = {}));
/// <reference path="../../map/mapue/UnrealViewerHelp.ts" />
var CZMAP;
(function (CZMAP) {
    const all_layers = new Map();
    /**
     * UE图层包装器
     * @internal
     */
    class UELayerProxy extends CZMAP.UnrealViewerHelp {
        constructor(view, type, layer) {
            super(view);
            this._id = -1;
            this._bbox = new CZMAP.BoundingBox();
            this._created = false;
            this._type = type;
            this._layer = layer;
            this._ready = new Promise((resolve) => {
                this._resolve = resolve;
            });
            this._processColorOpacity();
        }
        get ready() { return this._ready; }
        /** 获取UE图层ID */
        get id() { return this._id; }
        /** 获取图层对象 */
        get layer() { return this._layer; }
        get box() { return this._bbox; }
        /** 根据ID获取图层 */
        static getWrapperByID(id) {
            return all_layers.get(id);
        }
        static getLayerByID(id) {
            var _a;
            return (_a = all_layers.get(id)) === null || _a === void 0 ? void 0 : _a.layer;
        }
        /** 是否有效 */
        isValid() {
            return this._id != -1;
        }
        /** 创建图层 */
        async createLayer(define) {
            /// 
            this._created = true;
            this._id = await this.uvapi.createLayer(this._type, define);
            ///
            all_layers.set(this._id, this);
            ///
            this._resolve();
        }
        /** 飞行到图层 */
        async flyTo(option) {
            await this._ready;
            this.uvapi.flyTo({
                layerID: this._id,
                option
            });
        }
        async move(actions) {
            await this._ready;
            this.uvapi.moveLayer(this._id, actions);
        }
        /** 设置图层显示或者隐藏 */
        async setVisible(visible) {
            await this._ready;
            this.uvapi.setVisible(this._id, visible);
        }
        async setOpacity(opacity, color) {
            await this._ready;
            this.uvapi.setLayerOpacity(this._id, opacity, color);
        }
        /** 切换显示隐藏 */
        async switchVisible() {
            await this._ready;
            this.uvapi.switchVisible(this._id);
        }
        /** 更新图层 */
        async updateLayer(option) {
            await this._ready;
            this.uvapi.updateLayer(this._id, option);
        }
        async executeLayer(param) {
            await this._ready;
            this.uvapi.executeLayer(this._id, param);
        }
        /** 移除图层 */
        async removeLayer() {
            if (this._created) {
                await this._ready;
                all_layers.delete(this._id);
                this.uvapi.removeLayer(this._id);
                this._id = -1;
                ///
                this._created = false;
                this._ready = new Promise((resolve) => {
                    this._resolve = resolve;
                });
            }
        }
        /**
         * @inner
         * @param min 最小值
         * @param max 最大值
         */
        notify_setBoundBox(min, max) {
            this._bbox.setMin(min);
            this._bbox.setMax(max);
        }
        _processColorOpacity() {
            if (this._layer) {
                this._layer.onProperty(CZMAP.LayerProperty.COLOR, () => this._handleColorOpacity());
                this._layer.onProperty(CZMAP.LayerProperty.OPACITY, () => this._handleColorOpacity());
            }
        }
        _handleColorOpacity() {
            this.setOpacity(this._layer.opacity, this._layer.color);
        }
    }
    CZMAP.UELayerProxy = UELayerProxy;
})(CZMAP || (CZMAP = {}));
/// <reference path="MoveableLayerUE.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class VolumeDataLayerUE extends CZMAP.VolumeLayer {
        constructor(parent, option) {
            super(parent, option);
            this._gridVisible = false;
            this._uvlayer = new CZMAP.UELayerProxy(this.view, 'volume', this);
            this._grids = new CZMAP.CoordGridUE(this.view);
        }
        _onVisible(v) {
            this._grids.setVisible(v && this._gridVisible);
            this._uvlayer.setVisible(v);
        }
        _createInner() {
            var _a;
            const vo = this._option.volumeOptions;
            const sliceNum = (_a = vo.volumeSliceNum) !== null && _a !== void 0 ? _a : [8, 8];
            const position = this._vbox.getCenter();
            const scale = calcSizeMeter(this._vbox);
            this._uvlayer.createLayer({
                volume: {
                    url: CZMAP.absURL(vo.volumeData),
                    cols: sliceNum[0],
                    rows: sliceNum[1]
                },
                colors: CZMAP.absURL(vo.volumeColorMap),
                overlay: CZMAP.absURL(vo.volumeOverlay),
                visible: false,
                position,
                rotate: [0, 0, 0],
                scale,
            });
            this._grids.setVisible(false);
            const opt = CZMAP.deepAssign({
                dataBox: this._box,
                displayBox: this._vbox
            }, this._option.gridOptions);
            this._grids.build(opt);
        }
        _destroyInner() {
            this._uvlayer.removeLayer();
            this._grids.close();
        }
        setMode(mode) {
            this._uvlayer.updateLayer({ mode });
        }
        setSlices(slices) {
            this._uvlayer.updateLayer({ planes: slices });
        }
        setColorMap(colorMap) {
            this._uvlayer.updateLayer({ colors: CZMAP.absURL(colorMap) });
        }
        showGrids(show) {
            this._gridVisible = show;
            this._grids.setVisible(show && this.visible);
        }
        isShowGrids() {
            return this._grids.getVisible();
        }
    }
    CZMAP.VolumeDataLayerUE = VolumeDataLayerUE;
    function calcSizeMeter(box) {
        const position = box.getCenter();
        const [sx, sy, sz] = box.getSize();
        const R = 6378137;
        const r = Math.cos(position.y / 180.0 * Math.PI) * R;
        const msx = sy / 180.0 * Math.PI * r;
        const msy = sx / 180.0 * Math.PI * R;
        return [msx, msy, sz];
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="MoveableLayerUE.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class WrappedLayerUE extends CZMAP.MoveableLayerUE {
        constructor(parent, option) {
            super(parent, option);
            this._option = option;
            this._uvlayer = new CZMAP.UELayerProxy(this.view, 'wrapped', this);
        }
        get wrappedLayer() { return this._option.wrappedLayer; }
        _createInner() {
            const { wrappedLayer } = this._option;
            this._uvlayer.createLayer({
                layer: wrappedLayer,
                visible: false,
            });
        }
    }
    CZMAP.WrappedLayerUE = WrappedLayerUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 解析字符串为对应对象的工具
     */
    class Parse {
        /**
         * 解析Boolean值
         * @param {*} v
         * @return {boolean}
         */
        static parseBoolean(v, def) {
            if (CZMAP.Types.isBool(v))
                return v;
            if (CZMAP.Types.isString(v)) {
                const up = v.toUpperCase();
                return up === 'TRUE' || this.parseInteger(up) != 0;
            }
            ///
            return (CZMAP.Types.isDefined(v) ? true : CZMAP.Types.isDefined(def) ? def : false);
        }
        /**
         * 解析数字，如果输入参数不是数字则返回0
         * @param {*} v
         * @return {Number}
         */
        static parseNumber(v, defVal) {
            const n = Number.parseFloat(v);
            defVal = CZMAP.Types.defaultValue(defVal, 0);
            return Number.isNaN(n) ? defVal : n;
        }
        /**
         * 解析整数，如果输入参数不是数字则返回0
         * @param {*} v
         */
        static parseInteger(v, defVal) {
            const n = Number.parseInt(v);
            defVal = CZMAP.Types.defaultValue(defVal, 0);
            return Number.isNaN(n) ? defVal : n;
        }
        /**
         * 解析字符串为数值数组
         * @param {string} v 字符串
         * @param {string} s 分隔符
         * @param {number} num 数字的最小长度
         */
        static parseArray(v, s, num) {
            if (CZMAP.Types.isArray(v)) {
                const vn = v;
                const n = v.length;
                for (let i = 0; i < n; ++i)
                    vn[i] = this.parseNumber(v[i]);
            }
            else if (CZMAP.Types.isString(v)) {
                const str = v;
                v = str.split(s);
                const n = v.length;
                for (let i = 0; i < n; ++i) {
                    v[i] = this.parseNumber(v[i]);
                }
            }
            else {
                v = [];
            }
            ///
            while (v.length < num) {
                const vn = v;
                vn.push(0);
            }
            ///
            return v;
        }
        /**
         * 构建指定类型的解析函数
         * @param {*} s 字符串分隔符
         * @param {*} num 数组长度
         * @return 解析函数
         */
        static createParseArray(s, num) {
            return (v) => this.parseArray(v, s, num);
        }
        /**
         * 解析点位
         * @param p
         * @param def
         * @returns
         */
        static parsePoint(p, def) {
            let ps;
            if (CZMAP.Types.isString(p)) {
                ps = p.split(',');
            }
            else if (CZMAP.Types.isObject(p)) {
                const po = p;
                ps = [po.x, po.y, po.z];
            }
            else if (CZMAP.Types.isArray(p)) {
                ps = p;
            }
            else {
                ps = [0, 0, 0];
                if (def) {
                    ps[0] = def[0];
                    ps[1] = def[1];
                    ps[2] = def[2];
                }
                return ps;
            }
            ps[0] = Number.parseFloat(ps[0]);
            ps[1] = Number.parseFloat(ps[1]);
            ps[2] = Number.parseFloat(ps[2]);
            if (Number.isNaN(ps[0]))
                ps[0] = def ? def[0] : 0;
            if (Number.isNaN(ps[1]))
                ps[1] = def ? def[1] : 0;
            if (Number.isNaN(ps[2]))
                ps[2] = def ? def[2] : 0;
            return ps;
        }
    }
    CZMAP.Parse = Parse;
})(CZMAP || (CZMAP = {}));
/// <reference path="../../utils/Parse.ts" />
var CZMAP;
(function (CZMAP) {
    ;
    class ZFclsModel {
        /**
         * 要素树转要素列表
         * @param features
         * @param items
         */
        static tree2map(features, items) {
            /// 
            if (!items)
                items = new Map();
            features.forEach(f => {
                if (f.complex) {
                    this.tree2map(f.children, items);
                }
                else {
                    items.set(f.id, f);
                }
            });
            ///
            return items;
        }
        /**
         * 合并子模型
         * @param items
         * @param mergef
         */
        static merge(items, mergef) {
            /// 获取名称列表
            const names = [], index = [];
            items.forEach(item => {
                names.push(item.name);
                index.push(item);
            });
            /// 对名称进行合并
            const mnames = mergef(names);
            /// 合并结果
            const merged = [];
            mnames.forEach(m => {
                const mm = {
                    name: m.name,
                    items: []
                };
                m.index.forEach(i => {
                    mm.items.push(index[i]);
                });
                ///
                merged.push(mm);
            });
            ///
            return merged;
        }
        static filterSimpleModel(fea, simples) {
            if (!fea.complex) {
                simples.push(fea);
                return;
            }
            ///
            fea.children.forEach(sub => ZFclsModel.filterSimpleModel(sub, simples));
        }
    }
    ZFclsModel.parsePosition = CZMAP.Parse.parsePoint;
    CZMAP.ZFclsModel = ZFclsModel;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class Cluster {
        constructor() {
            this._clusterPixel = 100;
        }
        get clusterPixel() { return this._clusterPixel; }
        set clusterPixel(pixel) { this._clusterPixel = pixel; }
    }
    CZMAP.Cluster = Cluster;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let MapEventsType;
    (function (MapEventsType) {
        /** 鼠标悬停事件 */
        MapEventsType["MOUSE_OVER"] = "mouseover";
        /** 鼠标移出事件 */
        MapEventsType["MOUSE_OUT"] = "mouseout";
        /** 鼠标点击事件 */
        MapEventsType["MOUSE_CLICK"] = "click";
        /** 鼠标右键点击事件 */
        MapEventsType["MOUSE_RCLICK"] = "rclick";
        /** 鼠标双击事件 */
        MapEventsType["MOUSE_DBLCLICK"] = "dblclick";
    })(MapEventsType = CZMAP.MapEventsType || (CZMAP.MapEventsType = {}));
    /**
     * 地图鼠标事件
     */
    class MapMouseEvent extends CZMAP.Event {
        constructor(type, x, y, object, ext) {
            super(type);
            this.x = 0;
            this.y = 0;
            /**
             * X坐标
             */
            this.x = x;
            /**
             * Y坐标
             */
            this.y = y;
            /**
             * 鼠标当前对象
             */
            this.object = object;
            this.ext = ext;
        }
    }
    CZMAP.MapMouseEvent = MapMouseEvent;
    /**
     * 地图事件
     *
     * @description
     *
     */
    class MapEvents extends CZMAP.BaseObject {
        /**
         *
         */
        constructor(view) {
            super();
            /**
             * 地图对象
             */
            this.map = view.map;
            /**
             * 视图对象
             */
            this.view = view;
        }
    }
    CZMAP.MapEvents = MapEvents;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 地图模式
     */
    let MapMode;
    (function (MapMode) {
        /** 二维模式 */
        MapMode[MapMode["Mode2D"] = 1] = "Mode2D";
        /** 三维（WebGL）模式 */
        MapMode[MapMode["Mode3D"] = 2] = "Mode3D";
        /** 云渲染模式 */
        MapMode[MapMode["ModeCloud"] = 3] = "ModeCloud";
    })(MapMode = CZMAP.MapMode || (CZMAP.MapMode = {}));
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    ;
    function initDateTime(datetime) {
        const defDateTime = { year: 2022, month: 4, day: 22, hour: 0, minite: 0, second: 0 };
        return Object.assign(defDateTime, datetime);
    }
    CZMAP.initDateTime = initDateTime;
    let WeatherType;
    (function (WeatherType) {
        WeatherType["Sunny"] = "Sunny";
        WeatherType["Cloudy"] = "Cloudy";
        WeatherType["Partly_Cloudy"] = "Partly_Cloudy";
        WeatherType["Foggy"] = "Foggy";
        WeatherType["Overcast"] = "Overcast";
        WeatherType["Rain"] = "Rain";
        WeatherType["Rain_Light"] = "Rain_Light";
        WeatherType["Rain_Thunderstorm"] = "Rain_Thunderstorm";
        WeatherType["Sand_Dust_Calm"] = "Sand_Dust_Calm";
        WeatherType["Sand_Dust_Storm"] = "Sand_Dust_Storm";
        WeatherType["Snow"] = "Snow";
        WeatherType["Snow_Blizzard"] = "Snow_Blizzard";
        WeatherType["Snow_Light"] = "Snow_Light";
    })(WeatherType = CZMAP.WeatherType || (CZMAP.WeatherType = {}));
    class MapView extends CZMAP.BaseObject {
        /**
         *
         */
        constructor(map, dom) {
            super();
            this._dom = dom;
            this._map = map;
        }
        /**
         * 获取地图对象
         */
        get map() { return this._map; }
        get dom() { return this._dom; }
        _disposeInternal() {
            super._disposeInternal();
            //this.layerManager.removeAllLayer();
        }
        /**
         */
        get events() { return this.getEvents(); }
        /**  */
        get gridTool() { return this.getGridTool(); }
        /**  */
        get drawTool() { return this.getDrawTool(); }
        /**
         * 测量功能
         */
        get measureTool() { return this.getMeasureTool(); }
        /**
         * 测量距离
         */
        measureDistance(option) { this.measureTool.distance(option); }
        /**
         * 测量面积
         * @deprecated 拼写错误
         */
        measureArae(option) { this.measureTool.arae(option); }
        /**
         * 测量面积
         */
        measureArea(option) { this.measureTool.arae(option); }
        /** 测量角度 */
        measureAngle(option) { this.measureTool.angle(option); }
        /** 取消测量 */
        measureCancel() { this.measureTool.stop(); }
        /**
         * 清除测量
         */
        measureClear() { this.measureTool.clear(); }
        /**
         * 缩放到指定地点
         */
        zoomTo(extent, options) {
            const opt = Object.assign({ duration: 0 }, options);
            this.flyTo(extent, opt);
        }
        /**
         * 飞行到指定地点
         */
        flyTo(extent, options) {
            options = options || {};
            const center = CZMAP.Extents.getCenter(extent);
            const radius = Math.max(CZMAP.Extents.getWidth(extent), CZMAP.Extents.getHeight(extent)) / 2;
            let distance = options.distance;
            if (!CZMAP.Types.isDefined(distance))
                distance = radius * 111000;
            ///
            this.fly(Object.assign({
                position: [center[0], center[1], 0],
                distance,
            }, options));
        }
        /** 飞行到包围球 */
        flyToSphere(sphere, option) {
            this.fly(Object.assign({
                position: new Cegore.Position(sphere.center),
                distance: sphere.radius * 3,
            }, option));
        }
        /** 飞行到包围矩形 */
        flyToBox(box, option) {
            if (box.isEmpty())
                return;
            const min = Cesium.Cartesian3.fromDegrees(...box.getMin());
            const max = Cesium.Cartesian3.fromDegrees(...box.getMax());
            const radius = Cesium.Cartesian3.distance(min, max);
            this.fly(Object.assign({
                position: box.getCenter(),
                distance: radius * 3
            }, option));
        }
        /**
         * 查看目标点
         * @param target 目标点
         */
        lookAt(target) {
            const vi = this.getViewInfo();
            CZMAP.calcTargetHeadingPitch(vi, target);
            this.setViewInfo(vi, { duration: 0 });
        }
        /**
         * 飞行到目标点并旋转
         * @param option 选项
         */
        rotateAt(option) {
            this.cancelRotate();
            const flyOption = option.flyOption;
            const speed = option.speed || 3;
            let lastTime;
            let timeCost = 0;
            const doRotate = () => {
                const now = new Date().getTime();
                if (!lastTime) {
                    lastTime = now;
                    timeCost = 0;
                }
                const deltaTime = (now - lastTime) / 1000;
                timeCost += deltaTime;
                lastTime = now;
                flyOption.heading += speed * deltaTime;
                flyOption.duration = 0;
                this.fly(flyOption);
                ///
                if (timeCost < option.duration)
                    this._rotateHandle = requestAnimationFrame(doRotate);
            };
            if (flyOption.duration) {
                this.fly(flyOption);
                setTimeout(doRotate, flyOption.duration * 1000 + 200);
            }
            else {
                doRotate();
            }
        }
        /** 取消旋转 */
        cancelRotate() {
            if (this._rotateHandle) {
                cancelAnimationFrame(this._rotateHandle);
                this._rotateHandle = undefined;
            }
        }
        /** 设置植被风速 */
        setFoliageWind(wind) { }
        ;
        /** 移除信息窗口 */
        removeInfoWindow(infoWindow) {
            return infoWindow.close();
        }
    }
    CZMAP.MapView = MapView;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class MapEvent2D extends CZMAP.MapEvents {
        constructor(map) {
            super(map);
        }
        set enableTip(enable) { }
    }
    CZMAP.MapEvent2D = MapEvent2D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class MapView2D extends CZMAP.MapView {
        getEvents() {
            throw new Error("Method not implemented.");
        }
        getGridTool() {
            throw new Error("Method not implemented.");
        }
        getDrawTool() {
            throw new Error("Method not implemented.");
        }
        getMeasureTool() {
            throw new Error("Method not implemented.");
        }
        createTunnelEffct() {
            throw new Error("Method not implemented.");
        }
        createTunnelTransparent() {
            throw new Error("Method not implemented.");
        }
        createTerrainClips(options) {
            throw new Error("Method not implemented.");
        }
        clearTerrainClips() {
            throw new Error("Method not implemented.");
        }
        constructor(map, dom) {
            super(map, dom);
            var viewopt = {};
            var tileopt = {};
            ///
            this._events = new CZMAP.MapEvent2D(this.map);
            this._layerManager = new CZMAP.LayerManager2D(map);
        }
        get layerManager() {
            return this._layerManager;
        }
        get cluster() { throw new Error("Method not implemented."); return null; }
        /**
         * 获取事件管理类
         */
        get envents() { return this._events; }
        /** 启用/禁用地图交互 */
        eanbleInput(enable) {
            throw new Error("Method not implemented.");
        }
        /** 设置场景光照 */
        setSceneLight(scene) {
        }
        /** 设置时间 */
        setDateTime(datetime) {
            throw new Error("Method not implemented.");
        }
        /** 设置天气 */
        setWeather(weather) {
            throw new Error("Method not implemented.");
        }
        /** 设置季节 */
        setSeason(weather) {
            console.error('Method not implemented.');
        }
        setCloud(scene) {
            throw new Error("Method not implemented.");
        }
        /**
         * 拾取指定坐标的模型
         * @param x 屏幕坐标X
         * @param y 屏幕坐标Y
         */
        pick(x, y) {
            return undefined;
        }
        fly() {
            throw new Error("Method not implemented.");
        }
        completeFly() {
            throw new Error("Method not implemented.");
        }
        cancelFly() {
            throw new Error("Method not implemented.");
        }
        lockTo(layer) {
            throw new Error("Method not implemented.");
        }
        unlockTo() {
            throw new Error("Method not implemented.");
        }
        /**
         * 获取视图信息
         */
        getViewInfo() {
            return { position: [0, 0, 0] };
        }
        /**
         * 设置视图信息
         * @param info
         */
        setViewInfo(info) {
        }
        getExtend() {
            return [0, 0, 0, 0];
        }
        ///
        createPathRoam() { return null; }
        createClipPlane(option) { return null; }
        /** 创建信息窗口 */
        createInfoWindow(option) {
            return null;
        }
        /**
         * ZMap2D.Map 对象
         */
        get zmap2d() { return null; }
        /**
         * OpenLayers Map 对象
         */
        get olmap() { return null; }
        /**
         * OpenLayers View 对象
         */
        get olview() { return null; }
    }
    CZMAP.MapView2D = MapView2D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 地形开挖
     * @internal
     */
    class ClipTerrain extends CZMAP.BaseObject {
        /**
         *
         */
        constructor(map) {
            super();
            /// 
            this._wall = undefined;
            this._floor = undefined;
            ///
            this._clips = undefined;
            /**
             * 当前区域的包围球
             */
            this._sphere = new Cesium.BoundingSphere();
            this._enable = true;
            this._enableWall = true;
            this._enableFloor = true;
            this._floor_color = 'yellow';
            this._floor_image = undefined;
            this._border_width = 0;
            this._border_color = 'white';
            this._wall_color = 'blue';
            this._wall_image = undefined;
            this._useServerCut = false;
            this._useServerDEM = false;
            this.map = map;
            this.view3d = map.view3d;
        }
        /**
         *
         * @param {Object} options
         * @param {Array<>} options.points 地形开挖点数组
         * @param {Number} options.depth 开挖深度
         * @param {Object} options.border 边界
         * @param {Number} options.border.width 边界宽度
         * @param {String} options.border.color 边界颜色
         * @param {Object} options.floor 地板贴图
         * @param {String} options.floor.color 地板颜色
         * @param {String} options.floor.image 地板贴图
         * @param {String} options.wall 墙壁贴图
         * @param {String} options.wall.color 墙壁颜色
         * @param {String} options.wall.image 墙壁贴图
         * @param options.useServerCut=false  使用服务端开挖
         * @param options.useServerDEM=false  使用服务端高程
         */
        create(options) {
            this.close();
            let points;
            if (CZMAP.Types.isArray(options.points)) {
                points = options.points;
            }
            else if (CZMAP.Types.isArray(options.extent)) {
                const ex = options.extent;
                points = [CZMAP.Extents.getBottomLeft(ex), CZMAP.Extents.getBottomRight(ex),
                    CZMAP.Extents.getTopRight(ex), CZMAP.Extents.getTopLeft(ex)];
            }
            else {
                throw 'need param <points> or <extent>';
            }
            ///
            this._points = this._preperPoints(points);
            this._depth = CZMAP.Types.defaultValue(options.depth, -1000);
            if (CZMAP.Types.isDefined(options.border)) {
                this._border_width = CZMAP.Types.defaultValue(options.border.width, 1.0);
                this._border_color = CZMAP.Types.defaultValue(options.border.color, 'white');
            }
            else {
                this._border_width = 0;
                this._border_color = 'white';
            }
            if (CZMAP.Types.isDefined(options.floor)) {
                this._floor_color = options.floor.color;
                this._floor_image = options.floor.image;
            }
            else {
                this._floor_color = 'yellow';
                this._floor_image = undefined;
            }
            if (CZMAP.Types.isDefined(options.wall)) {
                this._wall_color = options.wall.color;
                this._wall_image = options.wall.image;
            }
            else {
                this._wall_color = 'blue';
                this._wall_image = undefined;
            }
            this._enable = true;
            this._enableWall = true;
            this._enableFloor = true;
            /// 
            this._useServerCut = CZMAP.Types.defaultValue(options.useServerCut, this._useServerCut);
            this._useServerDEM = CZMAP.Types.defaultValue(options.useServerDEM, this._useServerDEM);
            this._createClips();
            this._createWall();
            this._createFloor();
        }
        close() {
            this.enabled = false;
            if (this._clips)
                this._clips.enabled = false;
            if (this._wall)
                this.view3d.czviewer.entities.remove(this._wall);
            if (this._floor)
                this.view3d.czviewer.entities.remove(this._floor);
            this._clips = undefined;
            this._wall = undefined;
            this._floor = undefined;
            if (this._wallListener) {
                this._wallListener();
                this._wallListener = undefined;
            }
        }
        set enabled(v) {
            this._enable = v;
            if (this._clips)
                this._clips.enabled = v;
            this.enabledWall = v;
            this.enabledFloor = v;
            const terrain = getTerrain(this.map.layers);
            if (this._useServerCut && terrain) {
                if (v)
                    terrain.setClip({ clip: this._lonlats, height: this._depth - 10, wall: false, floor: false });
                else
                    terrain.setClip({ clip: [], height: this._depth - 10, wall: false, floor: false });
            }
        }
        get enabled() { return this._enable; }
        set enabledWall(v) {
            this._enableWall = v;
            if (this._wall)
                this._wall.show = v;
        }
        get enabledWall() { return this._enableWall; }
        set enabledFloor(v) {
            this._enableFloor = v;
            if (this._floor)
                this._floor.show = v;
        }
        get enabledFloor() { return this._enableFloor; }
        /**
         * 创建地形开挖
         */
        _createClips() {
            const terrain = getTerrain(this.map.layers);
            if (this._useServerCut && terrain) {
                const extent = CZMAP.Extents.createOrUpdateFromCoordinates(this._lonlats);
                const center = CZMAP.Extents.getCenter(extent);
                this._lonlats.forEach(e => {
                    e[0] = (e[0] - center[0]) * 0.99 + center[0];
                    e[1] = (e[1] - center[1]) * 0.99 + center[1];
                });
                terrain.setClip({ clip: this._lonlats, height: this._depth - 10, wall: false, floor: false });
                return;
            }
            const pts = this._points;
            const num = pts.length;
            // Create center points for each clipping plane
            const up = new Cesium.Cartesian3();
            const midpoint = new Cesium.Cartesian3();
            const right = new Cesium.Cartesian3();
            const normal = new Cesium.Cartesian3();
            const clips = [];
            for (var i = 0; i < num; ++i) {
                const p0 = pts[i];
                const p1 = pts[(i + 1) % num];
                if (Cesium.Cartesian3.equals(p0, p1))
                    continue;
                /// 求线段的中点
                Cesium.Cartesian3.add(p0, p1, midpoint);
                Cesium.Cartesian3.multiplyByScalar(midpoint, 0.5, midpoint);
                /// 根据中点归一化，求取上方向
                Cesium.Cartesian3.normalize(midpoint, up);
                /// 求取右方向
                Cesium.Cartesian3.subtract(p1, midpoint, right);
                Cesium.Cartesian3.normalize(right, right);
                /// 叉乘求取切面的法相量
                Cesium.Cartesian3.cross(right, up, normal);
                Cesium.Cartesian3.normalize(normal, normal);
                // Compute distance by pretending the plane is at the origin
                var originCenteredPlane = new Cesium.Plane(normal, 0.0);
                var distance = Cesium.Plane.getPointDistance(originCenteredPlane, midpoint);
                ///
                clips.push(new Cesium.ClippingPlane(normal, distance));
            }
            ///
            this._clips = new Cesium.ClippingPlaneCollection({
                planes: clips,
                edgeWidth: this._border_width,
                edgeColor: CZMAP.CesiumAttrib.getColor(this._border_color),
                enabled: this._enable,
            });
            /// 
            this.view3d.czviewer.scene.globe.clippingPlanes = this._clips;
        }
        /**
         * 创建地形开挖的侧面（墙壁）
         */
        _createWall() {
            const globe = this.view3d.czviewer.scene.globe;
            const interpNum = 100;
            const pts = this._points;
            const num = pts.length;
            let totalDistance = 0;
            const distances = [0];
            for (let i = 1; i < num; ++i) {
                let dist = Cesium.Cartesian3.distance(pts[i - 1], pts[i]);
                distances[i] = dist;
                totalDistance += dist;
            }
            const interpCar = new Cesium.Cartesian3();
            const interpDistance = totalDistance / interpNum;
            const interpPoints = [Cesium.Cartographic.fromCartesian(pts[0])];
            for (let i = 1; i < num; ++i) {
                const start = pts[i - 1], end = pts[i];
                const inum = Math.floor(distances[i] / interpDistance) + 1;
                for (let j = 1; j < inum; ++j) {
                    Cesium.Cartesian3.lerp(start, end, j / inum, interpCar);
                    interpPoints.push(Cesium.Cartographic.fromCartesian(interpCar));
                }
                interpPoints.push(Cesium.Cartographic.fromCartesian(end));
            }
            const terrain = getTerrain(this.map.layers);
            if (this._useServerDEM && terrain) {
                const gsize = 50;
                const extent = CZMAP.Extents.createOrUpdateFromCoordinates(this._lonlats);
                const size = CZMAP.Extents.getSize(extent);
                const maxsize = Math.max(size[0], size[1]);
                CZMAP.Extents.buffer(extent, maxsize * 0.02, extent);
                var url = terrain.url;
                if (url.indexOf('?') == -1) {
                    if (!Cegore.StringUtil.endsWidth(url, '/tile/dem', true))
                        url += '/tile/dem';
                    ///
                    url += '?';
                }
                ///
                url += '&origin=left|top';
                url += '&id=100,0,0';
                url += `&size=${gsize},${gsize}`;
                url += '&range=' + extent.join(',');
                url += '&style=float';
                fetch(url)
                    .then(r => { if (r.ok)
                    return r.arrayBuffer(); })
                    .then(b => {
                    let fdata;
                    const blength = gsize * gsize * Float32Array.BYTES_PER_ELEMENT;
                    if (!CZMAP.Types.isDefined(b) || b.byteLength != blength) {
                        fdata = new Float32Array(blength);
                    }
                    else {
                        fdata = new Float32Array(b);
                    }
                    const rb = new RasterBlock(fdata, extent, gsize, gsize);
                    interpPoints.forEach(e => {
                        e.height = rb.getCellValue(Cesium.Math.toDegrees(e.longitude), Cesium.Math.toDegrees(e.latitude));
                    });
                    ///
                    this._updateWall(interpPoints);
                });
            }
            else {
                let lastUpdate = 0;
                let lastCamerPos = new Cesium.Cartesian3();
                const camera = this.view3d.czviewer.camera;
                let chDistance = this._sphere.radius * 10;
                chDistance = chDistance * chDistance;
                const update = () => {
                    const now = new Date().getTime();
                    let cost = now - lastUpdate;
                    if (cost < 2000)
                        return;
                    const dist = Cesium.Cartesian3.distanceSquared(lastCamerPos, camera.positionWC);
                    if (dist < chDistance)
                        return;
                    lastUpdate = now;
                    camera.positionWC.clone(lastCamerPos);
                    /// 计算插值点的高程
                    for (let i = 0, ii = interpPoints.length; i < ii; ++i) {
                        const c = interpPoints[i];
                        c.height = globe.getHeight(c);
                        if (!CZMAP.Types.isNumber(c.height))
                            c.height = 0;
                    }
                    this._updateWall(interpPoints);
                };
                update();
                /// 定时刷新
                this._wallListener = camera.moveEnd.addEventListener(update);
            }
        }
        _updateWall(pts) {
            /// 构造“墙”的高程信息
            const carts = pts;
            const num = carts.length;
            const positions = new Array(num);
            const mins = new Array(num), maxs = new Array(num);
            for (let i = 0; i < num; ++i) {
                const c = carts[i];
                positions[i] = Cesium.Cartographic.toCartesian(c);
                mins[i] = this._depth;
                maxs[i] = c.height + 1;
            }
            if (this._wall) {
                this._wall.wall.positions = positions;
                this._wall.wall.minimumHeights = mins;
                this._wall.wall.maximumHeights = maxs;
            }
            else {
                const wall = new Cesium.WallGraphics({
                    positions: positions,
                    maximumHeights: maxs,
                    minimumHeights: mins,
                    //outline : true,
                    material: createMaterial(this._wall_color, this._wall_image),
                });
                this._wall = this.view3d.czviewer.entities.add({
                    wall
                });
            }
        }
        /**
         * 创建地形开挖地面（地板）
         */
        _createFloor() {
            const pts = this._points;
            this._floor = this.view3d.czviewer.entities.add({
                polygon: {
                    hierarchy: new Cesium.PolygonHierarchy(pts),
                    material: createMaterial(this._floor_color, this._floor_image),
                    height: this._depth,
                    //perPositionHeight : true
                }
            });
        }
        /**
         *
         * @param {Array<>} pts
         */
        _preperPoints(pts) {
            this._lonlats = pts = pts.slice(0);
            let num = pts.length;
            const p0 = pts[0], pn = pts[num - 1];
            if (p0[0] != pn[0] || p0[1] != pn[1]) {
                pts.push(p0);
                num += 1;
            }
            const area = signedArea(pts);
            if (area < 0)
                pts.reverse();
            const opts = [];
            for (let i = 0; i < num; ++i) {
                const pt = pts[i];
                opts[i] = Cesium.Cartesian3.fromDegrees(pt[0], pt[1], this._depth);
            }
            ///
            Cesium.BoundingSphere.fromPoints(opts, this._sphere);
            ///
            return opts;
        }
    }
    CZMAP.ClipTerrain = ClipTerrain;
    /**
     * 计算带方向的面积
     * @param pts 多边形点序列
     */
    function signedArea(pts) {
        if (pts == null || pts.length < 3)
            return 0;
        var point_num = pts.length;
        var p0 = pts[point_num - 1];
        var p1 = pts[0];
        var p2 = pts[1];
        var s = p1[1] * (p0[0] - p2[0]);
        for (var i = 1; i < point_num; ++i) {
            p0 = p1;
            p1 = p2;
            p2 = pts[(i + 1) % point_num];
            ///
            s += p1[1] * (p0[0] - p2[0]);
        }
        ///
        return s / 2.0;
    }
    function createMaterial(color, image) {
        if (image) {
            return new Cesium.ImageMaterialProperty({
                image: image,
                color: CZMAP.CesiumAttrib.getColor(color, Cesium.Color.WHITE),
            });
        }
        else {
            return CZMAP.CesiumAttrib.getColor(color, Cesium.Color.WHITE);
        }
    }
    function getTerrain(lm) {
        var terrains = [];
        function enumChild(layer) {
            if (layer instanceof CZMAP.TerrainLayer) {
                terrains.push(layer);
                return;
            }
            const chds = layer.children;
            chds.forEach(e => enumChild(e));
        }
        enumChild(lm);
        return terrains[terrains.length - 1];
    }
    class RasterBlock {
        constructor(b, extent, xnum, ynum) {
            this.data = b;
            this.extent = CZMAP.Extents.clone(extent);
            this.size = CZMAP.Extents.getSize(extent);
            this.xnum = xnum;
            this.ynum = ynum;
            this.xres = this.size[0] / xnum;
            this.yres = this.size[1] / ynum;
        }
        getCellValue(x, y) {
            ///
            const c = Math.floor((x - this.extent[0]) / this.xres);
            const r = Math.floor((this.extent[3] - y) / this.yres);
            /// 
            return this.data[r * this.xnum + c];
        }
    }
    function getCellValue(b, extent, size, x, y) {
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class MapMouseEvent3D extends CZMAP.MapMouseEvent {
        constructor(type, x, y, object, ext) {
            super(type, x, y, object, ext);
        }
    }
    CZMAP.MapMouseEvent3D = MapMouseEvent3D;
    /**
     * 三维地图事件
     * @internal
     */
    class MapEvent3D extends CZMAP.MapEvents {
        constructor(view) {
            super(view);
            this.view3d = view;
            ///
            this._handler = new Cesium.ScreenSpaceEventHandler(this.view3d.czviewer.scene.canvas);
            this._handler.setInputAction((e) => this._onMouseMoved(e), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this._handler.setInputAction((e) => this._onLeftClick(e), Cesium.ScreenSpaceEventType.LEFT_CLICK);
            this._handler.setInputAction((e) => this._onRightClick(e), Cesium.ScreenSpaceEventType.RIGHT_CLICK);
            this._handler.setInputAction((e) => this._onDoubleClick(e), Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
        }
        _onMouseMoved(movement) {
            ///
            clearTimeout(this._timer);
            this._timer = setTimeout(() => {
                const pt = movement.endPosition;
                let picked = this.view3d.pick(pt.x, pt.y);
                ///
                if (this._last) {
                    if (this._last.layer === picked.layer)
                        return;
                    ////
                    this._fire(CZMAP.MapEventsType.MOUSE_OUT, pt, this._last.layer, this._last);
                    this._last = undefined;
                }
                /// 
                if (picked.layer) {
                    this._fire(CZMAP.MapEventsType.MOUSE_OVER, pt, picked.layer, picked);
                    this._last = picked;
                }
            }, 200);
        }
        _onClickEvent(movement, type) {
            const pt = movement.position;
            let picked = this.view3d.pick(pt.x, pt.y);
            ///
            this._fire(type, pt, picked.layer, picked);
        }
        _onLeftClick(movement) {
            this._onClickEvent(movement, CZMAP.MapEventsType.MOUSE_CLICK);
        }
        _onRightClick(movement) {
            this._onClickEvent(movement, CZMAP.MapEventsType.MOUSE_RCLICK);
        }
        _onDoubleClick(movement) {
            this._onClickEvent(movement, CZMAP.MapEventsType.MOUSE_DBLCLICK);
        }
        _fire(type, pt, layer, pickInfo) {
            const evt = new MapMouseEvent3D(type, pt.x, pt.y, layer);
            evt.pickInfo = pickInfo;
            this.dispatchEvent(evt);
        }
        _disposeInternal() {
            super._disposeInternal();
            this._handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this._handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
            this._handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
            this._handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
            this._handler.destroy();
        }
    }
    CZMAP.MapEvent3D = MapEvent3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class MapView3D extends CZMAP.MapView {
        /**
         *
         */
        constructor(map, dom, option) {
            super(map, dom);
            ///
            option = CZMAP.deepAssign({ images: [] }, option);
            this._zmap3d = new ZMap3D.Map(dom, option, { navigation: true });
            ///
            this._cegore = this._zmap3d.cegore;
            this._cesium = this._zmap3d.cesium;
            this._czviewer = this._cesium.viewer;
            this._czviewer['vueCheck'] = new Proxy({}, {
                defineProperty(target, key, descriptor) {
                    console.error('检测到Vue等框架污染核心渲染对象，这将严重影响渲染性能！');
                    return false;
                }
            });
            this._czviewer.clock.currentTime = new Cesium.JulianDate(2459295, 11086, Cesium.TimeStandard.TAI);
            this._czviewer.cesiumWidget.useDefaultRenderLoop = false;
            ///
            this._czviewer.scene.logarithmicDepthBuffer = false;
            ///
            this._measure = new CZMAP.MeasureTool3D(this);
            ///
            this._events = new CZMAP.MapEvent3D(this);
            ///
            this._gridTool = new CZMAP.GridTool3D(this);
            this._drawTool = new CZMAP.DrawTool3D(this);
            ///
            this._czsource = new Cesium.CustomDataSource("MapView3D-Source");
            this._czsource.clustering.enabled = false;
            this.czviewer.dataSources.add(this._czsource);
            /// 
            this._clusterSource = new Cesium.CustomDataSource("MapView3D-ClusterSource");
            this._clusterSource.clustering.enabled = true;
            this.czviewer.dataSources.add(this._clusterSource);
            ///
            this._cluster3D = new CZMAP.Cluster3D(this, this._clusterSource);
            ///
            this._polylines = new Cesium.PolylineCollection();
            this.czscene.primitives.add(this._polylines);
            this._pathTails = new CZMAP.PathTailCollection(this._czviewer);
            ///
            this._layerManager = new CZMAP.LayerManager3D(map);
        }
        get layerManager() {
            return this._layerManager;
        }
        _disposeInternal() {
            super._disposeInternal();
            this._events.dispose();
        }
        /** 启用/禁用地图交互 */
        eanbleInput(enable) {
            this.czscene.screenSpaceCameraController.enableInputs = enable;
        }
        /**
         * 拾取指定坐标的模型
         * @param x 屏幕坐标X
         * @param y 屏幕坐标Y
         */
        pick(x, y, option) {
            option = option || {};
            const viewer = this.czviewer;
            const scene = this.czviewer.scene;
            const pixel = new Cesium.Cartesian2(x, y);
            const pick = { position: undefined, layer: undefined, pickedObject: undefined, cartesian: undefined };
            const pickPosition = Cesium.defaultValue(option.pickPosition, true);
            const pickObject = Cesium.defaultValue(option.pickObject, true);
            ///
            if (pickObject) {
                pick.pickedObject = scene.pick(pixel);
            }
            ///
            if (pickPosition) {
                ///
                if (scene.pickPositionSupported && (!pickObject || (Cesium.defined(pick.pickedObject) && pick.pickedObject.primitive))) {
                    pick.cartesian = scene.pickPosition(pixel);
                }
                else {
                    const ray = viewer.camera.getPickRay(pixel);
                    pick.cartesian = scene.globe.pick(ray, scene);
                    if (pickObject && !pick.pickedObject) {
                        pick.pickedObject = scene.globe.terrainProvider;
                    }
                }
            }
            ///
            if (Cesium.defined(pick.cartesian)) {
                const cartographic = Cesium.Cartographic.fromCartesian(pick.cartesian);
                const lng = Cesium.Math.toDegrees(cartographic.longitude);
                const lat = Cesium.Math.toDegrees(cartographic.latitude);
                const height = cartographic.height;
                pick.position = [lng, lat, height];
            }
            ///
            const picked = pick.pickedObject;
            if (picked) {
                if (picked._czmap_obj)
                    pick.layer = picked._czmap_obj;
                if (picked.id && picked.id._czmap_obj)
                    pick.layer = picked.id._czmap_obj;
                if (picked.node && picked.node._czmap_obj)
                    pick.layer = picked.node._czmap_obj;
                if (picked.primitive && picked.primitive._czmap_obj)
                    pick.layer = picked.primitive._czmap_obj;
            }
            ///
            return pick;
        }
        /**
         * 飞行到指定地点
         */
        fly(options) {
            const distance = CZMAP.defaultValue(options.distance, 1) * CZMAP.Parse.parseNumber(options.distanceScale, 1);
            const offset = new Cegore.HeadingPitchDistance(CZMAP.Parse.parseNumber(options.heading, 0), CZMAP.Parse.parseNumber(-options.pitch, -45), distance);
            this.cegore.camera.flyToSphere({
                center: options.position,
                radius: distance, offset,
                duration: options.duration
            });
        }
        completeFly() {
            this.czscene.camera.completeFlight();
        }
        cancelFly() {
            this.czscene.camera.cancelFlight();
        }
        lockTo(layer) {
            layer.ready.then(() => {
                const eye = this.cegore.camera.position;
                const center = layer.boundBox.getCenter();
                this.cegore.camera.lookAtFromTo(eye, new Cegore.Position(center));
            });
        }
        unlockTo() {
            //this.czviewer.trackedEntity = null;
            this.cegore.camera.clearLookAt();
        }
        /**
         * 获取视图信息
         */
        getViewInfo() {
            const camera = this.czviewer.camera;
            const cart = camera.positionCartographic;
            return {
                position: [
                    Cesium.Math.toDegrees(cart.longitude),
                    Cesium.Math.toDegrees(cart.latitude),
                    (cart.height),
                ],
                heading: Cesium.Math.toDegrees(camera.heading),
                pitch: (-Cesium.Math.toDegrees(camera.pitch)),
                roll: Cesium.Math.toDegrees(camera.roll)
            };
        }
        /**
         * 设置视图信息
         * @param info
         */
        setViewInfo(info, options) {
            options = CZMAP.Types.defaultValue(options, {});
            this.czviewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(info.position[0], info.position[1], info.position[2]),
                orientation: {
                    heading: CZMAP.Types.isDefined(info.heading) ? Cesium.Math.toRadians(info.heading) : undefined,
                    pitch: CZMAP.Types.isDefined(info.pitch) ? Cesium.Math.toRadians(-info.pitch) : undefined,
                    roll: CZMAP.Types.isDefined(info.roll) ? Cesium.Math.toRadians(info.roll) : undefined
                },
                duration: options.duration
            });
        }
        /** @override */
        getExtend() {
            return CZMAP.abstract();
        }
        /** @override */
        getEvents() {
            return this._events;
        }
        /** 设置场景光照 */
        setSceneLight(scene) {
            CZMAP.abstract();
        }
        /** 设置时间 */
        setDateTime(datetime) {
            const dt = CZMAP.initDateTime(datetime);
            const date = new Date(`${dt.year}-${dt.month}-${dt.day} ${dt.hour}:${dt.minite}:${dt.second}`);
            this.czviewer.clock.currentTime = Cesium.JulianDate.fromDate(date);
        }
        /** 设置天气 */
        setWeather(weather) {
            console.error('Method not implemented.');
        }
        /** 设置季节 */
        setSeason(weather) {
            console.error('Method not implemented.');
        }
        setCloud(cloud) {
            console.error('Method not implemented.');
        }
        /** @override */
        getGridTool() {
            return this._gridTool;
        }
        /** @override */
        getDrawTool() {
            return this._drawTool;
        }
        /** @override */
        getMeasureTool() {
            return this._measure;
        }
        /** @override */
        createPathRoam() {
            return new CZMAP.PathRoam3D(this);
        }
        /** @override */
        createClipPlane(option) {
            switch (option.type) {
                case CZMAP.ClipPlaneType.AXIS_PLANE:
                    return new CZMAP.AxisClipPlane3D(this, option.box);
                case CZMAP.ClipPlaneType.PATH_PLANE:
                    return new CZMAP.PathClipPlane3D(this, option.box);
            }
        }
        /** @override */
        createTunnelEffct() {
            return new CZMAP.TunnelEffct3D(this);
        }
        /**
         * 创建巷道透明工具
         * @override
         */
        createTunnelTransparent() { return new CZMAP.TunnelTransparent3D(this); }
        /**
         * 切割地形
         * @override
         */
        createTerrainClips(options) {
            if (!this._clips)
                this._clips = new CZMAP.ClipTerrain(this.map);
            this._clips.create(options);
            ///
            return this._clips;
        }
        clearTerrainClips() {
            if (this._clips)
                this._clips.close();
        }
        /**
         * 计算目标点像素大小
         * @param position 目标点
         * @returns 一个像素的大小（米单位）
         */
        calcPixelSize(position) {
            const camera = this._czviewer.scene.camera;
            const { clientWidth, clientHeight } = this._czviewer.canvas;
            Cesium.Cartesian3.clone(position, bs4PixelSize.center);
            /// 计算像素大小，缩放模型，保持像素大小不变
            return camera.getPixelSize(bs4PixelSize, clientWidth, clientHeight);
        }
        /** 创建信息窗口 */
        createInfoWindow(option) {
            return new CZMAP.InfoWindow3D(this, option);
        }
        /**
         * ZMap3D.Map 对象
         */
        get zmap3d() { return this._zmap3d; }
        /**
         * cegore viewer 对象
         */
        get cegore() { return this._cegore; }
        /**
         * Cesium 接口
         */
        get cesium() { return this._cesium; }
        /**
         * Cesium Viewer 对象
         */
        get czviewer() { return this._czviewer; }
        /** 获取场景对象 */
        get czscene() { return this._czviewer.scene; }
        /**
         *
         */
        get entities() { return this._czsource.entities; }
        /**
         *
         */
        get clusterEntities() { return this._clusterSource.entities; }
        /** 获取多边形集合 */
        get polylines() { return this._polylines; }
        /** 获取路径尾迹 */
        get pathTails() { return this._pathTails; }
    }
    CZMAP.MapView3D = MapView3D;
    const bs4PixelSize = new Cesium.BoundingSphere(new Cesium.Cartesian3(), 0);
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class MapMouseEventUE extends CZMAP.MapMouseEvent {
        constructor(type, x, y, layer, pickInfo) {
            super(type, x, y, layer);
            this.pickInfo = pickInfo;
        }
    }
    CZMAP.MapMouseEventUE = MapMouseEventUE;
    /** @internal */
    class MapEventsUE extends CZMAP.MapEvents {
        constructor(view) {
            super(view);
            view.uvapi.on('mouse_event', e => this._on_mouse_event(e));
        }
        _on_mouse_event(e) {
            this.dispatchEvent(e.data);
        }
    }
    CZMAP.MapEventsUE = MapEventsUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const WeatherTypes = {
        [CZMAP.WeatherType.Sunny]: 'Clear_Skies',
        [CZMAP.WeatherType.Cloudy]: 'Cloudy',
        [CZMAP.WeatherType.Partly_Cloudy]: 'Partly_Cloudy',
        [CZMAP.WeatherType.Foggy]: 'Foggy',
        [CZMAP.WeatherType.Overcast]: 'Overcast',
        [CZMAP.WeatherType.Rain]: 'Rain',
        [CZMAP.WeatherType.Rain_Light]: 'Rain_Light',
        [CZMAP.WeatherType.Rain_Thunderstorm]: 'Rain_Thunderstorm',
        [CZMAP.WeatherType.Sand_Dust_Calm]: 'Sand_Dust_Calm',
        [CZMAP.WeatherType.Sand_Dust_Storm]: 'Sand_Dust_Storm',
        [CZMAP.WeatherType.Snow]: 'Snow',
        [CZMAP.WeatherType.Snow_Blizzard]: 'Snow_Blizzard',
        [CZMAP.WeatherType.Snow_Light]: 'Snow_Light'
    };
    function asPoint(pos) {
        if (pos instanceof Cegore.Position) {
            return [pos.x, pos.y, pos.z];
        }
        else {
            return pos;
        }
    }
    /** @internal */
    class MapViewUE extends CZMAP.MapView {
        constructor(map, dom, option) {
            super(map, dom);
            option = CZMAP.deepAssign({ dom, inputMode: 'ASDW' }, option);
            this._uview = new CZMAP.UnrealViewer(option);
            this._uvapi = new CZMAP.UnrealViewerAPI(this._uview);
            this._layerManager = new CZMAP.LayerManagerUE(map);
            this._events = new CZMAP.MapEventsUE(this);
            this._gridTool = new CZMAP.GridToolUE(this);
            this._drawTool = new CZMAP.DrawToolUE(this);
            this._measureTool = new CZMAP.MeasureToolUE(this);
            ///
            this.uvapi.clearScene();
            /// 
            this.uvapi.initScene({
                center: option.center,
                autoCenter: option.autoCenter,
                time: '2022-03-18 14:00:00',
                zone: 8,
            });
            this.setInputMode(option.inputMode);
            if (CZMAP.defined(option.dragButton))
                this._uvapi.input.dragButton = option.dragButton;
            if (CZMAP.defined(option.rightDragButton))
                this._uvapi.input.rightDragButton = option.rightDragButton;
        }
        get uview() { return this._uview; }
        get uvapi() { return this._uvapi; }
        get layerManager() { return this._layerManager; }
        _disposeInternal() {
            super._disposeInternal();
            this._events.dispose();
        }
        /**
         * 设置交互模式
         * @param mode 交互模式
         */
        setInputMode(mode) {
            this._uvapi.setInputMode(mode);
        }
        /** 启用/禁用地图交互 */
        eanbleInput(enable) {
            this._uvapi.enableInput(enable);
        }
        pick(x, y) {
            //throw new Error("Method not implemented.");
            return this.uvapi.pick(x, y);
        }
        fly(option) {
            this.uvapi.flyTo({ target: asPoint(option.position), option });
        }
        completeFly() {
        }
        cancelFly() {
        }
        lookAt(target) {
            const vi = this.getViewInfo();
            CZMAP.calcTargetHeadingPitch(vi, target);
            this.setViewInfo(vi, { duration: 500 });
        }
        lockTo(layer) {
            throw new Error("Method not implemented.");
        }
        unlockTo() {
            throw new Error("Method not implemented.");
        }
        getViewInfo() {
            return this.uvapi.getViewInfo();
        }
        setViewInfo(info, options) {
            this.uvapi.setViewInfo(info);
        }
        getExtend() {
            throw new Error("Method not implemented.");
        }
        getEvents() {
            return this._events;
        }
        /** 设置场景光照 */
        setSceneLight(scene) {
            this._uvapi.setSceneLight(scene);
        }
        /** 设置场景的时间 */
        setDateTime(datetime) {
            const dt = CZMAP.initDateTime(datetime);
            this._uvapi.initScene({
                zone: 8,
                time: `${dt.year}-${dt.month}-${dt.day} ${dt.hour}:${dt.minite}:${dt.second}`
            });
        }
        /** 设置场景的天气 */
        setWeather(weather) {
            if (typeof weather.weatherType === 'string') {
                const weatherName = WeatherTypes[weather.weatherType];
                if (weatherName) {
                    this._uvapi.initScene({
                        weather: {
                            name: weatherName,
                            duration: weather.duration
                        }
                    });
                }
            }
            else if (typeof weather.weatherType === 'object') {
                this._uvapi.initScene({
                    weather: {
                        detail: weather.weatherType,
                        duration: weather.duration
                    }
                });
            }
        }
        setSeason(season) {
            this._uvapi.setSeason(season);
        }
        /** 设置植被风速 */
        setFoliageWind(wind) {
            this._uvapi.setFoliageWind(wind);
        }
        setCloud(cloud) {
            this._uvapi.setCloud(cloud);
        }
        getGridTool() {
            return this._gridTool;
        }
        getDrawTool() {
            return this._drawTool;
        }
        getMeasureTool() {
            return this._measureTool;
        }
        createPathRoam() {
            return new CZMAP.PathRoamUE(this);
        }
        createClipPlane(option) {
            throw new Error("Method not implemented.");
        }
        createTunnelEffct() {
            throw new Error("Method not implemented.");
        }
        createTunnelTransparent() {
            throw new Error("Method not implemented.");
        }
        createTerrainClips(options) {
            throw new Error("Method not implemented.");
        }
        clearTerrainClips() {
            throw new Error("Method not implemented.");
        }
        /** 创建信息窗口 */
        createInfoWindow(option) {
            return new CZMAP.InfoWindowUE(this, option);
        }
    }
    CZMAP.MapViewUE = MapViewUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 视图命令
     * @internal
     */
    let UnrealViewerCmd;
    (function (UnrealViewerCmd) {
        UnrealViewerCmd["InitScene"] = "InitScene";
        UnrealViewerCmd["SetSceneLight"] = "SetSceneLight";
        UnrealViewerCmd["SetWeather"] = "SetWeather";
        UnrealViewerCmd["SetSeason"] = "SetSeason";
        UnrealViewerCmd["SetFoliageWind"] = "SetFoliageWind";
        UnrealViewerCmd["SetCloud"] = "SetCloud";
        UnrealViewerCmd["ClearScene"] = "ClearScene";
        UnrealViewerCmd["SetTerrain"] = "SetTerrain";
        UnrealViewerCmd["SetViewInfo"] = "SetViewInfo";
        UnrealViewerCmd["FlyTo"] = "FlyTo";
        UnrealViewerCmd["CompleteFlyTo"] = "CompleteFlyTo";
        UnrealViewerCmd["CancelFlyTo"] = "CancelFlyTo";
        //AddImage = 'AddImage',
        //Add3dTileset = 'Add3dTileset',
        UnrealViewerCmd["CreateLayer"] = "CreateLayer";
        UnrealViewerCmd["UpdateLayer"] = "UpdateLayer";
        UnrealViewerCmd["RemoveLayer"] = "RemoveLayer";
        UnrealViewerCmd["SetVisible"] = "SetVisible";
        UnrealViewerCmd["SetLayerOpacity"] = "SetLayerOpacity";
        UnrealViewerCmd["SwitchVisible"] = "SwitchVisible";
        UnrealViewerCmd["ExecuteLayer"] = "ExecuteLayer";
        UnrealViewerCmd["MoveLayer"] = "MoveLayer";
        //AddPoint = 'AddPoint'
        UnrealViewerCmd["AddOverlay"] = "AddOverlay";
        UnrealViewerCmd["RemoveOverlay"] = "RemoveOverlay";
        UnrealViewerCmd["Pick"] = "Pick";
    })(UnrealViewerCmd || (UnrealViewerCmd = {}));
    /**
     * 视图通知
     * @internal
     */
    let UnrealViewerNotify;
    (function (UnrealViewerNotify) {
        UnrealViewerNotify["ViewInfo"] = "Notify-ViewInfo";
        UnrealViewerNotify["LayerInfo"] = "Noitfy-LayerInfo";
        UnrealViewerNotify["MouseEvent"] = "Notify-MouseEvent";
        UnrealViewerNotify["OverlayInfo"] = "Notify-OverlayInfo";
        UnrealViewerNotify["PathRoamInfo"] = "Noitfy-PathRoam";
    })(UnrealViewerNotify || (UnrealViewerNotify = {}));
    /**
     * 提供基于UnrealEngine的视图功能接口
     * @internal
     */
    class UnrealViewerAPI extends CZMAP.Observable {
        /**
         * 构造 UnrealViewerAPI
         * @param uviewer 视图
         */
        constructor(uviewer) {
            super();
            this._nextSEQ = 1;
            this._nextOverlay = 1;
            this._zoomFact = 0.005;
            this._inputMode = 'ASDW';
            /** 当前视图信息 */
            this._viewInfo = {
                position: [0, 0, 0],
                heading: 0,
                pitch: 0,
                roll: 0
            };
            /** 异步执行等待结果的命令列表 */
            this._asyncCmds = new Map();
            /** 通知命令列表 */
            this._notifys = new Map();
            /** Overlay列表 */
            this._overlays = new Map();
            /** 路径漫游列表 */
            this._pathroams = new Map();
            this._multiPointer = new CZMAP.MultiPointInput();
            this._uviewer = uviewer;
            this._uviewer.on(CZMAP.UnrealViewerEvents.RTC_RESPONSE, this._onResponse, this);
            this._notifys.set(UnrealViewerNotify.ViewInfo, this._notify_viewInfo);
            this._notifys.set(UnrealViewerNotify.MouseEvent, this._notify_mosue_event);
            this._notifys.set(UnrealViewerNotify.LayerInfo, this._notify_layerinfo);
            this._notifys.set(UnrealViewerNotify.OverlayInfo, this._notify_overlayinfo);
            this._notifys.set(UnrealViewerNotify.PathRoamInfo, this._notify_pathroam);
            ///
            this._uviewer.ready.then(() => this._bindInput());
        }
        get input() { return this._multiPointer; }
        setInputMode(mode) {
            const isGlobe = mode === 'Globe';
            this._inputMode = mode;
            this._multiPointer.enable = mode === 'Globe';
            this.initScene({ inputMode: mode });
            this._uviewer.setLockOnMousedown(!isGlobe);
        }
        enableInput(enable) {
            if (enable) {
                this._multiPointer.enable = this._inputMode === 'Globe';
                this.initScene({ inputMode: this._inputMode });
            }
            else {
                this._multiPointer.enable = false;
                this.initScene({ inputMode: 'Globe' });
            }
        }
        _bindInput() {
            let vi;
            let op = false;
            const targetPosition = new Cesium.Cartesian3();
            const targetDirection = new Cesium.Cartesian3();
            const currectPosition = new Cesium.Cartesian3();
            const dom = this._uviewer.sceneDOM;
            this._multiPointer.bind(dom);
            this._multiPointer.option.onBeginAction = () => {
                vi = CZMAP.deepCopy(this._viewInfo);
                op = true;
            };
            this._multiPointer.option.onEndAction = () => {
                op = false;
            };
            let moveDistance;
            this._multiPointer.option.onBeginDragging = () => {
                moveDistance = undefined;
            };
            this._multiPointer.option.onEndDragging = () => {
                moveDistance = undefined;
            };
            const doMove = async (x, y, dx, dy) => {
                if (!CZMAP.defined(moveDistance)) {
                    const resp = await this.pickPosition(x, y);
                    if (resp.result) {
                        Cesium.Cartesian3.fromDegrees(...vi.position, undefined, currectPosition);
                        Cesium.Cartesian3.fromDegrees(...resp.result.position, undefined, targetPosition);
                        moveDistance = Cesium.Cartesian3.distance(currectPosition, targetPosition);
                    }
                    else {
                        moveDistance = vi.position[2];
                    }
                }
                const dist = Math.sqrt(dx * dx + dy * dy);
                const height = vi.position[2];
                const angle = (Math.PI / 2 - Math.atan2(dy, -dx)) / Math.PI * 180;
                const offset = dist * moveDistance * 0.002;
                const [lon, lat] = CZMAP.calcOffsetPoint2(vi.position, offset, angle + vi.heading, 0, true);
                vi.position = [lon, lat, height];
                this.setViewInfo(vi);
            };
            let zoomCart = new Cesium.Cartographic();
            function toPoint(c, pt) {
                const cart = Cesium.Cartographic.fromCartesian(c, undefined, zoomCart);
                pt[0] = Cesium.Math.toDegrees(cart.longitude);
                pt[1] = Cesium.Math.toDegrees(cart.latitude);
                pt[2] = cart.height;
            }
            let zoomTarget;
            let zoomX, zoomY;
            let lastZoomTime = 0;
            const applyZoom = async (zoom, x, y) => {
                if (zoom === 0)
                    return;
                /// 计算两个滚轮zoom的时间
                const zoomTime = (new Date()).getTime();
                const zoomDelay = zoomTime - lastZoomTime;
                lastZoomTime = zoomTime;
                /// 
                if (!op && zoomDelay > 90) {
                    vi = CZMAP.deepCopy(this._viewInfo);
                    // console.warn('copy viewinfo', zoomDelay);
                }
                if (zoomX !== x || zoomY !== y || !CZMAP.defined(zoomTarget)) {
                    const resp = await this.pickPosition(x, y);
                    if (!(resp === null || resp === void 0 ? void 0 : resp.result)) {
                        return;
                    }
                    ///
                    zoomTarget = resp.result.position;
                    Cesium.Cartesian3.fromDegrees(...zoomTarget, undefined, targetPosition);
                    zoomX = x;
                    zoomY = y;
                }
                Cesium.Cartesian3.fromDegrees(...vi.position, undefined, currectPosition);
                Cesium.Cartesian3.subtract(targetPosition, currectPosition, targetDirection);
                Cesium.Cartesian3.multiplyByScalar(targetDirection, this._zoomFact * zoom, targetDirection);
                Cesium.Cartesian3.add(currectPosition, targetDirection, currectPosition);
                toPoint(currectPosition, vi.position);
            };
            const applyRotate = (r) => {
                if (r === 0)
                    return;
                vi.heading += r;
            };
            const applyTilting = (t) => {
                if (t === 0)
                    return;
                vi.pitch += t;
                if (vi.pitch > 90)
                    vi.pitch = 90;
                else if (vi.pitch < -90)
                    vi.pitch = -90;
            };
            const doZoomRotate = async (zoom, rotate, x, y) => {
                await applyZoom(zoom, x, y);
                applyRotate(rotate);
                this.setViewInfo(vi);
            };
            const doTilting = (t) => {
                applyTilting(t);
                this.setViewInfo(vi);
            };
            this._multiPointer.option.onDragging = args => {
                doMove(args.x, args.y, args.dx, args.dy);
            };
            this._multiPointer.option.onRightDragging = args => {
                applyRotate(args.dx / 4);
                applyTilting(args.dy / 4);
                this.setViewInfo(vi);
            };
            this._multiPointer.option.onRotateScale = args => doZoomRotate(args.d1 - args.d0, (args.r0 - args.r1) / Math.PI * 180, args.ct.x, args.ct.y);
            this._multiPointer.option.onTilting = args => doTilting(args.dy);
        }
        /**
         * 发送命令
         * @param cmd 命令
         * @param data 命令数据
         * @returns 返回命令序号
         */
        _sendCommand(cmd, data) {
            const seq = this._nextSEQ++;
            this._uviewer.ready.then(() => {
                console.debug('send command:', seq, cmd, data);
                this._uviewer.emitUIInteraction({
                    uvcmd: {
                        cmd, data, seq
                    }
                });
            });
            return seq;
        }
        _sendConsoleCmd(cmd) {
            this._uviewer.ready.then(() => {
                console.debug('send console command:', cmd);
                this._uviewer.emitCommand(cmd);
            });
        }
        /**
         * 发送命令
         * @param cmd 命令
         * @param data 命令数据
         * @returns 一个Promise，当命令执行成功后resolve
         */
        _sendCommandAnd(cmd, data) {
            const seq = this._sendCommand(cmd, data);
            const promise = new Promise((resolve, reject) => {
                this._asyncCmds.set(seq, { resolve, reject });
            });
            ///
            return promise;
        }
        /**
         * 接收到视图发来的消息事件
         * @param event 消息事件
         * @returns
         */
        _onResponse(event) {
            let resp;
            try {
                resp = JSON.parse(event.data);
            }
            catch (ex) {
                console.error(ex);
            }
            if (!resp)
                return;
            // 命令的回复
            if (resp.uvcmd) {
                const uvcmd = resp.uvcmd;
                const promise = this._asyncCmds.get(uvcmd.seq);
                if (promise) {
                    promise.resolve(uvcmd);
                    this._asyncCmds.delete(uvcmd.seq);
                }
            }
            // 视图的通知
            if (resp.uvnotify) {
                const ntf = resp.uvnotify;
                const cb = this._notifys.get(ntf.ncmd);
                if (cb)
                    cb.call(this, ntf);
            }
        }
        /**
         * 初始化场景
         * @param option 初始化选项
         */
        initScene(option) {
            this._sendCommand(UnrealViewerCmd.InitScene, option);
        }
        setSceneLight(sceneLight) {
            this._sendCommand(UnrealViewerCmd.SetSceneLight, { sceneLight });
        }
        setWeater(weather) {
            this._sendCommand(UnrealViewerCmd.SetWeather, { weather });
        }
        setSeason(season) {
            this._sendCommand(UnrealViewerCmd.SetSeason, { season });
        }
        setFoliageWind(foliageWind) {
            this._sendCommand(UnrealViewerCmd.SetFoliageWind, { foliageWind });
        }
        setCloud(option) {
            this._sendCommand(UnrealViewerCmd.SetCloud, option);
        }
        /**
         * 清空场景
         */
        clearScene() {
            this._sendCommand(UnrealViewerCmd.ClearScene, {});
        }
        /**
         * 设置地形数据
         * @param option 地形参数
         */
        setTerrain(option) {
            if (option.url)
                option.url = absURL(option.url);
            this._sendCommand(UnrealViewerCmd.SetTerrain, option);
        }
        /**
         * 创建图层
         * @param type 图层类型
         * @param define 图层定义
         * @returns 返回图层的ID
         */
        async createLayer(type, define) {
            const cv = { type, define };
            ///
            return (await this._sendCommandAnd(UnrealViewerCmd.CreateLayer, cv)).data.layerID;
        }
        /**
         * 更新图层
         * @param layerID 图层ID
         * @param option 图层定义
         */
        updateLayer(layerID, option) {
            const data = Object.assign({ layerID }, option);
            this._sendCommand(UnrealViewerCmd.UpdateLayer, data);
        }
        /**
         * 设置图层不透明度
         * @param layerID 图层ID
         * @param opacity 不透明度
         * @param color 颜色
         */
        setLayerOpacity(layerID, opacity, color) {
            this._sendCommand(UnrealViewerCmd.SetLayerOpacity, { layerID, opacity, color });
        }
        /**
         * 执行图层扩展命令
         * @param layerID 图层ID
         * @param param 扩展命令参数
         */
        executeLayer(layerID, param) {
            const data = { layerID, param };
            this._sendCommand(UnrealViewerCmd.ExecuteLayer, data);
        }
        /**
         * 移动图层
         * @param layerID 图层ID
         * @param actions “活动”列表
         */
        moveLayer(layerID, actions) {
            const data = { layerID, actions };
            this._sendCommand(UnrealViewerCmd.MoveLayer, data);
        }
        /**
         * 移除图层
         * @param layerID 图层ID
         */
        removeLayer(layerID) {
            const data = { layerID };
            this._sendCommand(UnrealViewerCmd.RemoveLayer, data);
        }
        /**
         * 添加表层对象（Overlay）
         * @param position Overlay的空间位置
         * @param of Overlay回调函数
         * @returns Overlay ID
         */
        addOverlay(position, of) {
            const id = this._nextOverlay++;
            const data = { id, position };
            this._sendCommand(UnrealViewerCmd.AddOverlay, data);
            this._overlays.set(id, of);
            return id;
        }
        /**
         * 更新表册对象（Overlay）
         * @param id
         * @param position
         */
        updateOverlay(id, position) {
            const data = { id, position };
            this._sendCommand(UnrealViewerCmd.AddOverlay, data);
        }
        /**
         * 移除表层对象（Overlay）
         * @param id Overlay ID
         */
        removeOverlay(id) {
            this._overlays.delete(id);
            this._sendCommand(UnrealViewerCmd.RemoveOverlay, { id });
        }
        /**
         * 获取视图信息
         * @returns 当前视图信息
         */
        getViewInfo() {
            return CZMAP.deepCopy(this._viewInfo);
        }
        setViewInfo(vi) {
            this._sendCommand(UnrealViewerCmd.SetViewInfo, vi);
        }
        /**
         * 飞行到目标地点
         * @param option 飞行选项
         */
        flyTo(option) {
            this._sendCommand(UnrealViewerCmd.FlyTo, option);
        }
        completeFlyTo() {
            this._sendCommand(UnrealViewerCmd.CompleteFlyTo);
        }
        cancelFlyTo() {
            this._sendCommand(UnrealViewerCmd.CancelFlyTo);
        }
        /**
         * 设置图层是否可见
         * @param layerID 图层ID
         * @param visible 是否可见
         */
        setVisible(layerID, visible) {
            this._sendCommand(UnrealViewerCmd.SetVisible, { layerID, visible });
        }
        /**
         * 切换图层的可见性
         * @param layerID 图层ID
         */
        switchVisible(layerID) {
            this._sendCommand(UnrealViewerCmd.SwitchVisible, { layerID });
        }
        resize(width, height) {
            this._sendConsoleCmd({
                'Resolution.Width': width,
                'Resolution.Height': height,
            });
        }
        async pick(x, y) {
            const cv = { x, y, pickPosition: false };
            return (await this._sendCommandAnd(UnrealViewerCmd.Pick, cv)).data;
        }
        async pickPosition(x, y) {
            const cv = { x, y, pickPosition: true };
            return (await this._sendCommandAnd(UnrealViewerCmd.Pick, cv)).data;
        }
        regPathRoam(id, roam) {
            this._pathroams.set(id, roam);
        }
        unregPathRoam(id) {
            this._pathroams.delete(id);
        }
        _notify_viewInfo(ntf) {
            this._viewInfo = ntf.ndata;
        }
        _notify_mosue_event(ntf) {
            const mei = ntf.ndata;
            const [x, y] = mei.pixel;
            console.debug(`mouse event:${mei.type}, layer:${mei.layerID}`);
            const pickInfo = {
                layer: CZMAP.UELayerProxy.getLayerByID(mei.layerID),
                pixel: mei.pixel,
                position: mei.position,
                pickedObject: ntf.ndata.info
            };
            const event = new CZMAP.MapMouseEventUE(mei.type, x, y, pickInfo.layer, pickInfo);
            this.dispatchEvent('mouse_event', event);
        }
        _notify_layerinfo(ntf) {
            const info = ntf.ndata;
            const wrapper = CZMAP.UELayerProxy.getWrapperByID(info.layerID);
            if (wrapper) {
                wrapper.notify_setBoundBox(info.box.min, info.box.max);
            }
        }
        _notify_overlayinfo(ntf) {
            ntf.ndata.ids.forEach(it => {
                const [id, x, y] = it;
                const cb = this._overlays.get(id);
                try {
                    if (cb)
                        cb(x, y);
                }
                catch (ex) {
                    console.warn('notfiy overlayinfo error', ex);
                }
            });
        }
        _notify_pathroam(ntf) {
            const roam = this._pathroams.get(ntf.ndata.layerID);
            if (roam)
                roam.notify_pathroam(ntf.ndata);
        }
    }
    CZMAP.UnrealViewerAPI = UnrealViewerAPI;
    /** 用于相对路径转绝对路径的a标签 */
    const a = document.createElement('a');
    /**
     * 相对URL路径转绝对路径
     * @param src 待转化的URL
     * @returns 转换后的绝对路径
     */
    function absURL(src) {
        if (!CZMAP.defined(src)) {
            return undefined;
        }
        a.href = src;
        return a.href;
    }
    CZMAP.absURL = absURL;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 发送到客户端的消息类型
     * @internal
     */
    let ToClientMessageType;
    (function (ToClientMessageType) {
        ToClientMessageType[ToClientMessageType["QualityControlOwnership"] = 0] = "QualityControlOwnership";
        ToClientMessageType[ToClientMessageType["Response"] = 1] = "Response";
        ToClientMessageType[ToClientMessageType["Command"] = 2] = "Command";
        ToClientMessageType[ToClientMessageType["FreezeFrame"] = 3] = "FreezeFrame";
        ToClientMessageType[ToClientMessageType["UnfreezeFrame"] = 4] = "UnfreezeFrame";
        ToClientMessageType[ToClientMessageType["VideoEncoderAvgQP"] = 5] = "VideoEncoderAvgQP";
        ToClientMessageType[ToClientMessageType["LatencyTest"] = 6] = "LatencyTest";
        ToClientMessageType[ToClientMessageType["InitialSettings"] = 7] = "InitialSettings";
        ToClientMessageType[ToClientMessageType["FileExtension"] = 8] = "FileExtension";
        ToClientMessageType[ToClientMessageType["FileMimeType"] = 9] = "FileMimeType";
        ToClientMessageType[ToClientMessageType["FileContents"] = 10] = "FileContents";
    })(ToClientMessageType || (ToClientMessageType = {}));
    ;
    /**
     * 发送到服务器端消息类型
     * @internal
     */
    let MessageType;
    (function (MessageType) {
        /**********************************************************************/
        /*
         * Control Messages. Range = 0..49.
         */
        MessageType[MessageType["IFrameRequest"] = 0] = "IFrameRequest";
        MessageType[MessageType["RequestQualityControl"] = 1] = "RequestQualityControl";
        MessageType[MessageType["FpsRequest"] = 2] = "FpsRequest";
        MessageType[MessageType["AverageBitrateRequest"] = 3] = "AverageBitrateRequest";
        MessageType[MessageType["StartStreaming"] = 4] = "StartStreaming";
        MessageType[MessageType["StopStreaming"] = 5] = "StopStreaming";
        MessageType[MessageType["LatencyTest"] = 6] = "LatencyTest";
        MessageType[MessageType["RequestInitialSettings"] = 7] = "RequestInitialSettings";
        /**********************************************************************/
        /*
         * Input Messages. Range = 50..89.
         */
        // Generic Input Messages. Range = 50..59.
        MessageType[MessageType["UIInteraction"] = 50] = "UIInteraction";
        MessageType[MessageType["Command"] = 51] = "Command";
        // Keyboard Input Message. Range = 60..69.
        MessageType[MessageType["KeyDown"] = 60] = "KeyDown";
        MessageType[MessageType["KeyUp"] = 61] = "KeyUp";
        MessageType[MessageType["KeyPress"] = 62] = "KeyPress";
        // Mouse Input Messages. Range = 70..79.
        MessageType[MessageType["MouseEnter"] = 70] = "MouseEnter";
        MessageType[MessageType["MouseLeave"] = 71] = "MouseLeave";
        MessageType[MessageType["MouseDown"] = 72] = "MouseDown";
        MessageType[MessageType["MouseUp"] = 73] = "MouseUp";
        MessageType[MessageType["MouseMove"] = 74] = "MouseMove";
        MessageType[MessageType["MouseWheel"] = 75] = "MouseWheel";
        // Touch Input Messages. Range = 80..89.
        MessageType[MessageType["TouchStart"] = 80] = "TouchStart";
        MessageType[MessageType["TouchEnd"] = 81] = "TouchEnd";
        MessageType[MessageType["TouchMove"] = 82] = "TouchMove";
        // Gamepad Input Messages. Range = 90..99
        MessageType[MessageType["GamepadButtonPressed"] = 90] = "GamepadButtonPressed";
        MessageType[MessageType["GamepadButtonReleased"] = 91] = "GamepadButtonReleased";
        MessageType[MessageType["GamepadAnalog"] = 92] = "GamepadAnalog";
        /**************************************************************************/
    })(MessageType || (MessageType = {}));
    ;
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
     * @internal
     */
    let MouseButton;
    (function (MouseButton) {
        MouseButton[MouseButton["MainButton"] = 0] = "MainButton";
        MouseButton[MouseButton["AuxiliaryButton"] = 1] = "AuxiliaryButton";
        MouseButton[MouseButton["SecondaryButton"] = 2] = "SecondaryButton";
        MouseButton[MouseButton["FourthButton"] = 3] = "FourthButton";
        MouseButton[MouseButton["FifthButton"] = 4] = "FifthButton"; // Browser Forward button.
    })(MouseButton || (MouseButton = {}));
    ;
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
     * @internal
     */
    let MouseButtonsMask;
    (function (MouseButtonsMask) {
        MouseButtonsMask[MouseButtonsMask["PrimaryButton"] = 1] = "PrimaryButton";
        MouseButtonsMask[MouseButtonsMask["SecondaryButton"] = 2] = "SecondaryButton";
        MouseButtonsMask[MouseButtonsMask["AuxiliaryButton"] = 4] = "AuxiliaryButton";
        MouseButtonsMask[MouseButtonsMask["FourthButton"] = 8] = "FourthButton";
        MouseButtonsMask[MouseButtonsMask["FifthButton"] = 16] = "FifthButton"; // Browser Forward button.
    })(MouseButtonsMask || (MouseButtonsMask = {}));
    ;
    /**
     * @internal
     */
    const MouseButtonsMaskMap = [
        [MouseButton.MainButton, MouseButtonsMask.PrimaryButton],
        [MouseButton.SecondaryButton, MouseButtonsMask.SecondaryButton],
        [MouseButton.AuxiliaryButton, MouseButtonsMask.AuxiliaryButton],
        [MouseButton.FourthButton, MouseButtonsMask.FourthButton],
        [MouseButton.FifthButton, MouseButtonsMask.FifthButton]
    ];
    /**
     * 特别的按键
     * @internal
     */
    let SpecialKeyCodes;
    (function (SpecialKeyCodes) {
        SpecialKeyCodes[SpecialKeyCodes["BackSpace"] = 8] = "BackSpace";
        SpecialKeyCodes[SpecialKeyCodes["Shift"] = 16] = "Shift";
        SpecialKeyCodes[SpecialKeyCodes["Control"] = 17] = "Control";
        SpecialKeyCodes[SpecialKeyCodes["Alt"] = 18] = "Alt";
        SpecialKeyCodes[SpecialKeyCodes["RightShift"] = 253] = "RightShift";
        SpecialKeyCodes[SpecialKeyCodes["RightControl"] = 254] = "RightControl";
        SpecialKeyCodes[SpecialKeyCodes["RightAlt"] = 255] = "RightAlt";
    })(SpecialKeyCodes || (SpecialKeyCodes = {}));
    ;
    /**
     * 云渲染回调通知
     * @internal
     */
    class UnrealViewerEvents extends CZMAP.BaseObjectEvents {
    }
    UnrealViewerEvents.RTC_RESPONSE = 'rtc_response';
    CZMAP.UnrealViewerEvents = UnrealViewerEvents;
    /**
     * 获取按键时间的KeyCode
     * @param e
     * @returns
     * @internal
     */
    function getKeyCode(e) {
        if (e.keyCode === SpecialKeyCodes.Shift && e.code === 'ShiftRight')
            return SpecialKeyCodes.RightShift;
        else if (e.keyCode === SpecialKeyCodes.Control && e.code === 'ControlRight')
            return SpecialKeyCodes.RightControl;
        else if (e.keyCode === SpecialKeyCodes.Alt && e.code === 'AltRight')
            return SpecialKeyCodes.RightAlt;
        else
            return e.keyCode;
    }
    function isKeyCodeBrowserKey(keyCode) {
        // Function keys or tab key.
        return keyCode >= 112 && keyCode <= 123 || keyCode === 9;
    }
    /**
     * 获取dom对象
     * @param dom domID或者对象
     * @returns
     * @internal
     */
    function findDom(dom) {
        if (typeof dom === 'string')
            return document.getElementById(dom);
        else
            return dom;
    }
    const WS_OPEN_STATE = 1;
    const DefaultUnrealViewerOption = {
        suppressBrowserKeys: true,
        fakeMouseWithTouches: false,
        dataChannelMaxBytes: 65535
    };
    /**
     * Unreal Viewer
     * @internal
     */
    class UnrealViewer extends CZMAP.Observable {
        constructor(option) {
            super();
            this._autoPlayAudio = true;
            this._qualityController = false;
            this._freezeFrame = {
                receiving: false,
                size: 0,
                jpeg: undefined,
                height: 0,
                width: 0,
                valid: false
            };
            this._is_reconnection = false;
            this._print_inputs = false;
            this._lockOnMouseDown = true;
            this._next_multi_id = 0;
            this._ready = new Promise(resolve => this._resolve = resolve);
            this._option = CZMAP.deepAssign(DefaultUnrealViewerOption, option);
            this._option.showConnectInfo = this._option.showConnectInfo || !!CZMAP.urlSearchs.get('showConnectInfo');
            this._playerDiv = findDom(this._option.dom);
            this._playerDiv.style.position = 'relative';
            this._setupConnectionOverlay();
            this._setupConnectInfo();
            this._setupFreezeFrameOverlay();
            ///
            if (option.autoConnect)
                this.connect();
        }
        get ready() { return this._ready; }
        get sceneDOM() { return this._videoElement; }
        /**
         * 鼠标按下时是否锁定鼠标消息
         * @param lock
         */
        setLockOnMousedown(lock) {
            this._lockOnMouseDown = lock;
        }
        /**
         * 连接信号服务器
         */
        connect() {
            if (this._ws) {
                this._playStream();
                return;
            }
            this._showConnectionOverlay(false);
            this._showConnectionInfo(true);
            const signalServer = CZMAP.defaultValue(this._option.signalServer, this._option.singleServer);
            const ws = this._ws = new WebSocket(signalServer);
            this._appendConnectInfo(`开始连接到信号服务：${signalServer}`);
            function logInSS(msg) {
                console.log(`%c[Inbound SS (${msg.type})]`, "background: lightblue; color: black", msg);
            }
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                switch (msg.type) {
                    case 'config':
                        logInSS(msg);
                        this._onConfig(msg);
                        this._appendConnectInfo(`信号服务器已连接，等待创建渲染实例...`);
                        break;
                    case 'playerCount':
                        logInSS(msg);
                        break;
                    case 'streamConnected':
                        logInSS(msg);
                        this._appendConnectInfo('渲染实例已创建，构建点对点通讯...');
                        break;
                    case 'offer':
                        logInSS(msg);
                        this._onWebRtcOffer(msg);
                        break;
                    case 'answer':
                        logInSS(msg);
                        this._onWebRtcAnswer(msg);
                        break;
                    case 'iceCandidate':
                        this._onWebRtcIce(msg.candidate);
                        break;
                    case 'warning':
                        console.warn(msg.warning);
                        break;
                    default:
                        console.log(`Invalid SS message type: ${msg.type}`);
                        break;
                }
            };
            ws.onerror = (event) => {
                console.log(`WS error`);
                this._appendConnectInfo(`连接失败!`);
            };
            ws.onclose = (event) => {
                console.log(`WS closed: ${JSON.stringify(event.code)} - ${event.reason}`);
                this._appendConnectInfo(`连接已断开。代码：[${event.code}]，信息：[${event.reason}]。`);
                this._ws = undefined;
                this._is_reconnection = true;
                // destroy `webRtcPlayerObj` if any
                let playerDiv = this._playerDiv;
                if (this._webRtcPlayerObj) {
                    playerDiv.removeChild(this._webRtcPlayerObj.video);
                    this._webRtcPlayerObj.close();
                    this._webRtcPlayerObj = undefined;
                }
            };
        }
        updateSize() {
            if (!this._videoElement)
                return;
            const { clientWidth, clientHeight } = this._videoElement;
            this.emitCommand({
                'Resolution.Width': clientWidth,
                'Resolution.Height': clientHeight,
            });
        }
        /** 连接到信号服务器，开始配置 */
        _onConfig(config) {
            this._setupWebRtcPlayer(config);
            this._resizePlayerStyle();
            this._registerInputs();
            clearInterval(this._updateSizeHandle);
            this._updateSizeHandle = setInterval(() => {
                if (!this._videoElement)
                    return;
                const { clientWidth, clientHeight } = this._videoElement;
                if (clientWidth == this._lastViewWidth && clientHeight == this._lastViewHeight)
                    return;
                this._lastViewWidth = clientWidth;
                this._lastViewHeight = clientHeight;
                this.emitCommand({
                    'Resolution.Width': clientWidth,
                    'Resolution.Height': clientHeight,
                });
            }, 1000);
        }
        _onWebRtcOffer(webRTCData) {
            this._webRtcPlayerObj.receiveOffer(webRTCData);
            this._webRtcPlayerObj.aggregateStats(1 * 1000 /*Check every 1 second*/);
        }
        _onWebRtcAnswer(webRTCData) {
            this._webRtcPlayerObj.receiveAnswer(webRTCData);
            this._webRtcPlayerObj.aggregateStats(1 * 1000 /*Check every 1 second*/);
        }
        _onWebRtcIce(candidate) {
            if (this._webRtcPlayerObj)
                this._webRtcPlayerObj.handleCandidateFromServer(candidate);
        }
        /** 设置并初始化WebRtcPlayer */
        _setupWebRtcPlayer(config) {
            const ws = this._ws;
            const freezeFrame = this._freezeFrame;
            const freezeFrameImage = this._freezeFrameImage;
            const webRtcPlayerObj = this._webRtcPlayerObj = new CZMAP.WebRtcPlayer(config);
            this._autoPlayAudio = typeof config.autoPlayAudio !== 'undefined' ? config.autoPlayAudio : true;
            this._videoElement = webRtcPlayerObj.video;
            this._audioElement = webRtcPlayerObj.audio;
            this._setupVideoStyle();
            ///
            this._playerDiv.appendChild(this._videoElement);
            this._playerDiv.appendChild(this._audioElement);
            /// 
            function logOutSS(msg) {
                console.log(`%c[Outbound SS message (${msg.type})]`, "background: lightgreen; color: black", msg);
            }
            ///
            webRtcPlayerObj.onWebRtcOffer = function (offer) {
                if (ws && ws.readyState === WS_OPEN_STATE) {
                    logOutSS(offer);
                    ws.send(JSON.stringify(offer));
                }
            };
            webRtcPlayerObj.onWebRtcCandidate = function (candidate) {
                if (ws && ws.readyState === WS_OPEN_STATE) {
                    ws.send(JSON.stringify({
                        type: 'iceCandidate',
                        candidate: candidate
                    }));
                }
            };
            webRtcPlayerObj.onWebRtcAnswer = function (answer) {
                if (ws && ws.readyState === WS_OPEN_STATE) {
                    logOutSS(answer);
                    ws.send(JSON.stringify(answer));
                }
            };
            webRtcPlayerObj.onVideoInitialised = () => {
                this._appendConnectInfo('视频已连接...');
                if (ws && ws.readyState === WS_OPEN_STATE) {
                    this._resizePlayerStyle();
                    this._playStream();
                }
            };
            webRtcPlayerObj.onDataChannelConnected = () => {
                this._appendConnectInfo('数据通道已建立...');
                if (ws && ws.readyState === WS_OPEN_STATE) {
                    this._requestQualityControl();
                    this._resolve();
                }
            };
            webRtcPlayerObj.onDataChannelClose = () => {
                this._appendConnectInfo('数据通道已关闭...');
                this._showConnectionInfo(true);
            };
            const showFreezeFrame = () => {
                let base64 = btoa(freezeFrame.jpeg.reduce((data, byte) => data + String.fromCharCode(byte), ''));
                freezeFrameImage.src = 'data:image/jpeg;base64,' + base64;
                freezeFrameImage.onload = () => {
                    freezeFrame.height = freezeFrameImage.naturalHeight;
                    freezeFrame.width = freezeFrameImage.naturalWidth;
                    this._resizeFreezeFrameOverlay();
                    this._showFreezeFrameOverlay();
                    webRtcPlayerObj.setVideoEnabled(false);
                };
            };
            function processFreezeFrameMessage(view) {
                // Reset freeze frame if we got a freeze frame message and we are not "receiving" yet.
                if (!freezeFrame.receiving) {
                    freezeFrame.receiving = true;
                    freezeFrame.valid = false;
                    freezeFrame.size = 0;
                    freezeFrame.jpeg = undefined;
                }
                // Extract total size of freeze frame (across all chunks)
                freezeFrame.size = (new DataView(view.slice(1, 5).buffer)).getInt32(0, true);
                // Get the jpeg part of the payload
                let jpegBytes = view.slice(1 + 4);
                // Append to existing jpeg that holds the freeze frame
                if (freezeFrame.jpeg) {
                    let jpeg = new Uint8Array(freezeFrame.jpeg.length + jpegBytes.length);
                    jpeg.set(freezeFrame.jpeg, 0);
                    jpeg.set(jpegBytes, freezeFrame.jpeg.length);
                    freezeFrame.jpeg = jpeg;
                }
                // No existing freeze frame jpeg, make one
                else {
                    freezeFrame.jpeg = jpegBytes;
                    freezeFrame.receiving = true;
                    console.log(`received first chunk of freeze frame: ${freezeFrame.jpeg.length}/${freezeFrame.size}`);
                }
                // Uncomment for debug
                //console.log(`Received freeze frame chunk: ${freezeFrame.jpeg.length}/${freezeFrame.size}`);
                // Finished receiving freeze frame, we can show it now
                if (freezeFrame.jpeg.length === freezeFrame.size) {
                    freezeFrame.receiving = false;
                    freezeFrame.valid = true;
                    console.log(`received complete freeze frame ${freezeFrame.size}`);
                    showFreezeFrame();
                }
                // We received more data than the freeze frame payload message indicate (this is an error)
                else if (freezeFrame.jpeg.length > freezeFrame.size) {
                    console.error(`received bigger freeze frame than advertised: ${freezeFrame.jpeg.length}/${freezeFrame.size}`);
                    freezeFrame.jpeg = undefined;
                    freezeFrame.receiving = false;
                }
            }
            webRtcPlayerObj.onNewVideoTrack = (streams) => {
                if (webRtcPlayerObj.video && webRtcPlayerObj.video.srcObject && webRtcPlayerObj.onVideoInitialised) {
                    webRtcPlayerObj.onVideoInitialised();
                }
            };
            webRtcPlayerObj.onDataChannelMessage = (data) => {
                let view = new Uint8Array(data);
                const dataType = view[0];
                const asString = () => new TextDecoder("utf-16").decode(data.slice(1));
                switch (dataType) {
                    case ToClientMessageType.QualityControlOwnership:
                        let ownership = view[1] === 0 ? false : true;
                        this._qualityController = ownership;
                        console.log("Received quality controller message, will control quality: " + ownership);
                        break;
                    case ToClientMessageType.Response:
                        let response = asString();
                        this._onRtcPlayerResponse(response);
                        break;
                    case ToClientMessageType.Command:
                        break;
                    case ToClientMessageType.FreezeFrame:
                        processFreezeFrameMessage(view);
                        break;
                    case ToClientMessageType.UnfreezeFrame:
                        this._invalidateFreezeFrameOverlay();
                        break;
                    case ToClientMessageType.VideoEncoderAvgQP:
                        this._VideoEncoderQP = asString();
                        break;
                    case ToClientMessageType.LatencyTest:
                        let latencyTimingsAsString = asString();
                        console.log("Got latency timings from UE.");
                        console.log(latencyTimingsAsString);
                        let latencyTimingsFromUE = JSON.parse(latencyTimingsAsString);
                        if (webRtcPlayerObj) {
                            webRtcPlayerObj.latencyTestTimings.SetUETimings(latencyTimingsFromUE);
                        }
                        break;
                    case ToClientMessageType.InitialSettings:
                        let settingsJSON = JSON.parse(asString());
                        break;
                    case ToClientMessageType.FileExtension:
                    case ToClientMessageType.FileMimeType:
                    case ToClientMessageType.FileContents:
                        break;
                    default:
                        console.error(`unrecognized data received, packet ID ${dataType}`);
                }
            };
            ///
            return webRtcPlayerObj.video;
        }
        /** 开始播放音视频流 */
        async _playStream() {
            try {
                const webRtcPlayerObj = this._webRtcPlayerObj;
                const video = webRtcPlayerObj.video;
                if (!webRtcPlayerObj || !video) {
                    console.error("Could not player video stream because webRtcPlayerObj.video was not valid.");
                    return;
                }
                const audio = webRtcPlayerObj.audio;
                if (audio && audio.srcObject && this._autoPlayAudio) {
                    await audio.play();
                }
                ///
                await video.play();
                ///
                this._requestInitialSettings();
                this._requestQualityControl();
                this._showFreezeFrameOverlay();
                this._showConnectionOverlay(false);
                this._appendConnectInfo('云渲染已连接', true);
            }
            catch (reason) {
                console.error(reason);
                console.log("浏览器不支持自动播放视频，请点击播放按钮");
                ///
                this._showConnectionOverlay(true);
                this._appendConnectInfo('浏览器不支持自动播放视频，请点击“开始”按钮！');
            }
        }
        _resizePlayerStyle() {
            this._resizeFreezeFrameOverlay();
            this.updateSize();
            this._playerElementClientRect = this._videoElement.getBoundingClientRect();
        }
        _setupVideoStyle() {
            const video = this._videoElement;
            video.tabIndex = 0;
            setStyle(video, {
                position: 'absolute',
                left: '0', top: '0',
                right: '0', bottom: '0',
                width: '100%', height: '100%'
            });
        }
        _setupConnectionOverlay() {
            const cov = this._connectOverlay = document.createElement('div');
            cov.innerText = "开始";
            cov.className = 'map-mapview-cloud-connect';
            setStyle(cov, {
                display: 'block', zIndex: '100',
                position: 'absolute',
                left: '0', top: '0', right: '0', bottom: '0',
                width: '200px', height: '200px',
                marginTop: 'auto', marginBottom: 'auto',
                marginRight: 'auto', marginLeft: 'auto',
                fontSize: '50px', lineHeight: '200px',
                textAlign: 'center', verticalAlign: 'middle',
                borderRadius: '25px', backgroundColor: 'rgba(125,125,125,0.5)',
                cursor: 'pointer'
            });
            ///
            cov.onclick = () => this.connect();
            ///
            this._playerDiv.appendChild(cov);
        }
        _setupConnectInfo() {
            const cov = this._connectInfo = document.createElement('textarea');
            setStyle(cov, {
                display: 'block', zIndex: '100',
                position: 'absolute', visibility: 'hidden',
                left: '0', right: '0', bottom: '10px',
                width: '600px', height: '150px',
                margin: 'auto', padding: '5px',
                backgroundColor: 'rgba(125, 125, 125)'
            });
            ///
            if (this._option.showConnectInfo)
                this._playerDiv.appendChild(cov);
        }
        _showConnectionOverlay(show) {
            const vis = show ? 'visible' : 'hidden';
            this._connectOverlay.style.visibility = vis;
        }
        _showConnectionInfo(show) {
            const vis = show ? 'visible' : 'hidden';
            this._connectInfo.style.visibility = vis;
        }
        _appendConnectInfo(info, close) {
            this._connectInfo.value += info + '\n';
            if (close) {
                fadeTool.fadeOut(this._connectInfo);
            }
        }
        _clearConnectInfo() {
            this._connectInfo.value = '';
        }
        _setupFreezeFrameOverlay() {
            const freezeFrameOverlay = this._freezeFrameOverlay = document.createElement('div');
            freezeFrameOverlay.style.display = 'none';
            freezeFrameOverlay.style.pointerEvents = 'none';
            freezeFrameOverlay.style.position = 'absolute';
            freezeFrameOverlay.style.zIndex = '20';
            this._freezeFrameImage = document.createElement('img');
            this._freezeFrameImage.style.position = 'absolute';
            freezeFrameOverlay.appendChild(this._freezeFrameImage);
            this._playerDiv.appendChild(this._freezeFrameOverlay);
        }
        _showFreezeFrameOverlay() {
            if (this._freezeFrame.valid) {
                this._freezeFrameOverlay.classList.add("freezeframeBackground");
                this._freezeFrameOverlay.style.display = 'block';
            }
        }
        _invalidateFreezeFrameOverlay() {
            this._freezeFrame.valid = false;
            this._freezeFrameOverlay.style.display = 'none';
            this._freezeFrameOverlay.classList.remove("freezeframeBackground");
            if (this._webRtcPlayerObj) {
                this._webRtcPlayerObj.setVideoEnabled(true);
            }
        }
        _resizeFreezeFrameOverlay() {
            const freezeFrame = this._freezeFrame;
            if (freezeFrame.width !== 0 && freezeFrame.height !== 0) {
                let displayWidth = 0;
                let displayHeight = 0;
                let displayTop = 0;
                let displayLeft = 0;
                let playerDiv = this._playerDiv;
                this._freezeFrameOverlay.style.width = playerDiv.offsetWidth + 'px';
                this._freezeFrameOverlay.style.height = playerDiv.offsetHeight + 'px';
                this._freezeFrameOverlay.style.left = 0 + 'px';
                this._freezeFrameOverlay.style.top = 0 + 'px';
                this._freezeFrameImage.style.width = displayWidth + 'px';
                this._freezeFrameImage.style.height = displayHeight + 'px';
                this._freezeFrameImage.style.left = displayLeft + 'px';
                this._freezeFrameImage.style.top = displayTop + 'px';
            }
        }
        _onRtcPlayerResponse(resp) {
            this.dispatchEvent(UnrealViewerEvents.RTC_RESPONSE, resp);
        }
        /** 发送数据到渲染器 */
        _sendInputData(data) {
            if (this._webRtcPlayerObj) {
                //resetAfkWarningTimer();
                this._webRtcPlayerObj.send(data);
            }
        }
        _emitMessageType(messageType) {
            this._sendInputData(new Uint8Array([messageType]).buffer);
        }
        /**
         * A generic message has a type and a descriptor.
         * @param messageType
         * @param descriptor
         */
        _emitDescriptor(messageType, descriptor) {
            // Convert the dscriptor object into a JSON string.
            let descriptorAsString = (typeof descriptor === 'string') ? descriptor : JSON.stringify(descriptor);
            // Add the UTF-16 JSON string to the array byte buffer, going two bytes at
            // a time.
            let data = new DataView(new ArrayBuffer(1 + 2 + 2 * descriptorAsString.length));
            let byteIdx = 0;
            data.setUint8(byteIdx, messageType);
            byteIdx++;
            data.setUint16(byteIdx, descriptorAsString.length, true);
            byteIdx += 2;
            for (let i = 0; i < descriptorAsString.length; i++) {
                data.setUint16(byteIdx, descriptorAsString.charCodeAt(i), true);
                byteIdx += 2;
            }
            this._sendInputData(data.buffer);
        }
        /**
         * A UI interation will occur when the user presses a button powered by
         * JavaScript as opposed to pressing a button which is part of the pixel
         * streamed UI from the UE client.
         * @param descriptor
         * @returns
         */
        emitUIInteraction(descriptor) {
            const maxBytes = this._option.dataChannelMaxBytes;
            const maxChars = (maxBytes - 3 / 2) | 0;
            const content = (typeof descriptor === 'string') ? descriptor : JSON.stringify(descriptor);
            console.log(`emitUIInteraction, length:${(content.length / 1024).toFixed(1)}`);
            if (content.length < maxChars) {
                this._emitDescriptor(MessageType.UIInteraction, content);
                return;
            }
            const id = this._next_multi_id++;
            const groupChars = maxChars - 50;
            const groups = Math.ceil(content.length / groupChars) | 0;
            for (let i = 0; i < groups; ++i) {
                const start = i * groupChars;
                const part = `multi:${id}:${i}:${groups}:${content.substring(start, start + groupChars)}`;
                this._emitDescriptor(MessageType.UIInteraction, part);
            }
        }
        /**
         * A build-in command can be sent to UE client. The commands are defined by a
         * JSON descriptor and will be executed automatically.
         * The currently supported commands are:
         *
         * 1. A command to run any console command:
         *  "{ ConsoleCommand: <string> }"
         *
         * 2. A command to change the resolution to the given width and height.
         *  "{ Resolution.Width: <value>, Resolution.Height: <value> } }"
         *
         * @param descriptor
         */
        emitCommand(descriptor) {
            this._emitDescriptor(MessageType.Command, descriptor);
        }
        _requestInitialSettings() {
            this._emitMessageType(MessageType.RequestInitialSettings);
        }
        _requestQualityControl() {
            if (this._qualityController)
                this._emitMessageType(MessageType.RequestQualityControl);
        }
        _normalize(x, y) {
            const width = this._videoElement.clientWidth;
            const height = this._videoElement.clientHeight;
            return [x / width, y / height];
        }
        /** 归一并量子化无符号数 */
        normalizeAndQuantizeUnsigned(x, y) {
            const [nx, ny] = this._normalize(x, y);
            if (nx < 0.0 || ny < 0.0 || nx > 1.0 || ny > 1.0) {
                return { inRange: false, x: 65535, y: 65535 };
            }
            else {
                return { inRange: true, x: nx * 65536, y: ny * 65536 };
            }
        }
        /** 归一并量子化有符号数 */
        normalizeAndQuantizeSigned(x, y) {
            const [nx, ny] = this._normalize(x, y);
            return { x: nx * 0.5 * 32767, y: ny * 0.5 * 32767 };
        }
        /** 解码量子化的无符号数 */
        unquantizeAndDenormalizeUnsigned(x, y) {
            return {
                x: (x / 65536) * this._videoElement.clientWidth,
                y: (y / 65536) * this._videoElement.clientHeight
            };
        }
        emitKeyDown(keyCode, repeat) {
            if (this._print_inputs) {
                console.log(`key down ${keyCode}, repeat = ${repeat}`);
            }
            this._sendInputData(new Uint8Array([MessageType.KeyDown, keyCode, repeat]).buffer);
        }
        emitKeyUp(keyCode) {
            if (this._print_inputs) {
                console.log(`key up ${keyCode}`);
            }
            this._sendInputData(new Uint8Array([MessageType.KeyUp, keyCode]).buffer);
        }
        emitKeyPress(charCode) {
            if (this._print_inputs) {
                console.log(`key press ${charCode}`);
            }
            let data = new DataView(new ArrayBuffer(3));
            data.setUint8(0, MessageType.KeyPress);
            data.setUint16(1, charCode, true);
            this._sendInputData(data.buffer);
        }
        /** 发送鼠标移动消息 */
        emitMouseMove(x, y, deltaX, deltaY) {
            if (this._print_inputs) {
                console.log(`x: ${x}, y:${y}, dX: ${deltaX}, dY: ${deltaY}`);
            }
            let coord = this.normalizeAndQuantizeUnsigned(x, y);
            let delta = this.normalizeAndQuantizeSigned(deltaX, deltaY);
            let Data = new DataView(new ArrayBuffer(9));
            Data.setUint8(0, MessageType.MouseMove);
            Data.setUint16(1, coord.x, true);
            Data.setUint16(3, coord.y, true);
            Data.setInt16(5, delta.x, true);
            Data.setInt16(7, delta.y, true);
            this._sendInputData(Data.buffer);
        }
        /** 发送鼠标按下消息 */
        emitMouseDown(button, x, y) {
            if (this._print_inputs) {
                console.log(`mouse button ${button} down at (${x}, ${y})`);
            }
            let coord = this.normalizeAndQuantizeUnsigned(x, y);
            let Data = new DataView(new ArrayBuffer(6));
            Data.setUint8(0, MessageType.MouseDown);
            Data.setUint8(1, button);
            Data.setUint16(2, coord.x, true);
            Data.setUint16(4, coord.y, true);
            this._sendInputData(Data.buffer);
        }
        /** 发送鼠标弹起消息 */
        emitMouseUp(button, x, y) {
            if (this._print_inputs) {
                console.log(`mouse button ${button} up at (${x}, ${y})`);
            }
            let coord = this.normalizeAndQuantizeUnsigned(x, y);
            let Data = new DataView(new ArrayBuffer(6));
            Data.setUint8(0, MessageType.MouseUp);
            Data.setUint8(1, button);
            Data.setUint16(2, coord.x, true);
            Data.setUint16(4, coord.y, true);
            this._sendInputData(Data.buffer);
        }
        /** 发送鼠标滚轮消息 */
        emitMouseWheel(delta, x, y) {
            if (this._print_inputs) {
                console.log(`mouse wheel with delta ${delta} at (${x}, ${y})`);
            }
            let coord = this.normalizeAndQuantizeUnsigned(x, y);
            let Data = new DataView(new ArrayBuffer(7));
            Data.setUint8(0, MessageType.MouseWheel);
            Data.setInt16(1, delta, true);
            Data.setUint16(3, coord.x, true);
            Data.setUint16(5, coord.y, true);
            this._sendInputData(Data.buffer);
        }
        // If the user has any mouse buttons pressed then release them.
        releaseMouseButtons(buttons, x, y) {
            for (let item of MouseButtonsMaskMap) {
                if (buttons & item[1]) {
                    this.emitMouseUp(item[0], x, y);
                }
            }
        }
        // If the user has any mouse buttons pressed then press them again.
        pressMouseButtons(buttons, x, y) {
            for (let item of MouseButtonsMaskMap) {
                if (buttons & item[1]) {
                    this.emitMouseDown(item[0], x, y);
                }
            }
        }
        /**
         * 注册输入事件
         */
        _registerInputs() {
            this._registerKeyboardEvents();
            this._registerMouseEvents();
            this._registerTouchEvents();
            this._registerMouseEnterAndLeaveEvents();
        }
        /** 注册键盘事件 */
        _registerKeyboardEvents() {
            const playerElement = this._videoElement;
            playerElement.onkeydown = e => {
                ///
                this.emitKeyDown(getKeyCode(e), e.repeat);
                // Backspace is not considered a keypress in JavaScript but we need it
                // to be so characters may be deleted in a UE4 text entry field.
                if (e.keyCode === SpecialKeyCodes.BackSpace) {
                    this.emitKeyPress(SpecialKeyCodes.BackSpace);
                }
                ///
                if (this._option.suppressBrowserKeys && isKeyCodeBrowserKey(e.keyCode)) {
                    e.preventDefault();
                }
            };
            playerElement.onkeyup = e => {
                ///
                this.emitKeyUp(getKeyCode(e));
                ///
                if (this._option.suppressBrowserKeys && isKeyCodeBrowserKey(e.keyCode)) {
                    e.preventDefault();
                }
            };
            playerElement.onkeypress = e => this.emitKeyPress(e.charCode);
        }
        /** 鼠标进入和离开事件 */
        _registerMouseEnterAndLeaveEvents() {
            const playerElement = this._videoElement;
            playerElement.onmouseenter = (e) => {
                if (this._print_inputs) {
                    console.log('mouse enter');
                }
                this._emitMessageType(MessageType.MouseEnter);
                playerElement.pressMouseButtons(e);
            };
            playerElement.onmouseleave = (e) => {
                if (this._print_inputs) {
                    console.log('mouse leave');
                }
                this._emitMessageType(MessageType.MouseLeave);
                playerElement.releaseMouseButtons(e);
            };
        }
        /** 注册鼠标事件 */
        _registerMouseEvents() {
            const playerDom = this._videoElement;
            // Respond to lock state change events
            document.addEventListener('pointerlockchange', () => {
                const locked = document.pointerLockElement === playerDom;
                console.log(`Pointer locked:${locked}`);
            });
            let isPointerLocked = false;
            /// 鼠标按下时捕获鼠标
            playerDom.onmousedown = (e) => {
                if (this._lockOnMouseDown) {
                    playerDom.requestPointerLock();
                    isPointerLocked = true;
                }
                this.emitMouseDown(e.button, e.offsetX, e.offsetY);
            };
            /// 鼠标弹起
            playerDom.onmouseup = (e) => {
                if (isPointerLocked) {
                    document.exitPointerLock();
                    isPointerLocked = false;
                }
                this.emitMouseUp(e.button, e.offsetX, e.offsetY);
            };
            /// 鼠标移动
            playerDom.onmousemove = (e) => {
                playerDom.focus();
                this.emitMouseMove(e.offsetX, e.offsetY, e.movementX, e.movementY);
                e.preventDefault();
            };
            playerDom.onwheel = (e) => { this.emitMouseWheel(e['wheelDelta'], e.offsetX, e.offsetY); e.preventDefault(); };
            playerDom.pressMouseButtons = (e) => this.pressMouseButtons(e.buttons, e.offsetX, e.offsetY);
            playerDom.releaseMouseButtons = (e) => this.releaseMouseButtons(e.buttons, e.offsetX, e.offsetY);
        }
        _registerTouchEvents() {
            const playerElement = this._videoElement;
            // We need to assign a unique identifier to each finger.
            // We do this by mapping each Touch object to the identifier.
            let fingers = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
            let fingerIds = {};
            const rememberTouch = (touch) => {
                let finger = fingers.pop();
                if (finger === undefined) {
                    console.log('exhausted touch indentifiers');
                }
                fingerIds[touch.identifier] = finger;
            };
            const forgetTouch = (touch) => {
                fingers.push(fingerIds[touch.identifier]);
                delete fingerIds[touch.identifier];
            };
            const emitTouchData = (type, touches) => {
                let data = new DataView(new ArrayBuffer(2 + 7 * touches.length));
                data.setUint8(0, type);
                data.setUint8(1, touches.length);
                let byte = 2;
                for (let t = 0; t < touches.length; t++) {
                    let touch = touches[t];
                    let x = touch.clientX - playerElement.offsetLeft;
                    let y = touch.clientY - playerElement.offsetTop;
                    if (this._print_inputs) {
                        console.log(`F${fingerIds[touch.identifier]}=(${x}, ${y})`);
                    }
                    let coord = this.normalizeAndQuantizeUnsigned(x, y);
                    data.setUint16(byte, coord.x, true);
                    byte += 2;
                    data.setUint16(byte, coord.y, true);
                    byte += 2;
                    data.setUint8(byte, fingerIds[touch.identifier]);
                    byte += 1;
                    data.setUint8(byte, 255 * touch.force); // force is between 0.0 and 1.0 so quantize into byte.
                    byte += 1;
                    data.setUint8(byte, coord.inRange ? 1 : 0); // mark the touch as in the player or not
                    byte += 1;
                }
                this._sendInputData(data.buffer);
            };
            if (this._option.fakeMouseWithTouches) {
                let finger = undefined;
                playerElement.ontouchstart = (e) => {
                    if (finger === undefined) {
                        let firstTouch = e.changedTouches[0];
                        finger = {
                            id: firstTouch.identifier,
                            x: firstTouch.clientX - this._playerElementClientRect.left,
                            y: firstTouch.clientY - this._playerElementClientRect.top
                        };
                        // Hack: Mouse events require an enter and leave so we just
                        // enter and leave manually with each touch as this event
                        // is not fired with a touch device.
                        playerElement.onmouseenter(e);
                        this.emitMouseDown(MouseButton.MainButton, finger.x, finger.y);
                    }
                    e.preventDefault();
                };
                playerElement.ontouchend = (e) => {
                    for (let t = 0; t < e.changedTouches.length; t++) {
                        let touch = e.changedTouches[t];
                        if (touch.identifier === finger.id) {
                            let x = touch.clientX - this._playerElementClientRect.left;
                            let y = touch.clientY - this._playerElementClientRect.top;
                            this.emitMouseUp(MouseButton.MainButton, x, y);
                            // Hack: Manual mouse leave event.
                            playerElement.onmouseleave(e);
                            finger = undefined;
                            break;
                        }
                    }
                    e.preventDefault();
                };
                playerElement.ontouchmove = (e) => {
                    for (let t = 0; t < e.touches.length; t++) {
                        let touch = e.touches[t];
                        if (touch.identifier === finger.id) {
                            let x = touch.clientX - this._playerElementClientRect.left;
                            let y = touch.clientY - this._playerElementClientRect.top;
                            this.emitMouseMove(x, y, x - finger.x, y - finger.y);
                            finger.x = x;
                            finger.y = y;
                            break;
                        }
                    }
                    e.preventDefault();
                };
            }
            else {
                playerElement.ontouchstart = (e) => {
                    // Assign a unique identifier to each touch.
                    for (let t = 0; t < e.changedTouches.length; t++) {
                        rememberTouch(e.changedTouches[t]);
                    }
                    if (this._print_inputs) {
                        console.log('touch start');
                    }
                    emitTouchData(MessageType.TouchStart, e.changedTouches);
                    e.preventDefault();
                };
                playerElement.ontouchend = (e) => {
                    if (this._print_inputs) {
                        console.log('touch end');
                    }
                    emitTouchData(MessageType.TouchEnd, e.changedTouches);
                    // Re-cycle unique identifiers previously assigned to each touch.
                    for (let t = 0; t < e.changedTouches.length; t++) {
                        forgetTouch(e.changedTouches[t]);
                    }
                    e.preventDefault();
                };
                playerElement.ontouchmove = (e) => {
                    if (this._print_inputs) {
                        console.log('touch move');
                    }
                    emitTouchData(MessageType.TouchMove, e.touches);
                    e.preventDefault();
                };
            }
        }
    }
    CZMAP.UnrealViewer = UnrealViewer;
    function showTextOverlay(text) {
        let textOverlay = document.createElement('div');
        textOverlay.id = 'messageOverlay';
        textOverlay.innerHTML = text ? text : '';
        //setOverlay('textDisplayState', textOverlay);
    }
    function setStyle(dom, style) {
        if (!dom)
            return;
        ///
        CZMAP.deepAssign(dom.style, style);
    }
    ;
    /**
     * Dom淡入淡出工具
     * @internal
     */
    class FadeTool {
        constructor() {
            this._fadeMap = new Map();
            this._lastTime = 0;
            requestAnimationFrame(e => this._fadeProc(e));
        }
        fadeOut(dom) {
            this.fade(dom, true);
        }
        fadeIn(dom) {
            this.fade(dom, false);
        }
        fade(dom, fadeOut) {
            const fadeout = fadeOut ? -1 : 1;
            const opacity = fadeOut ? 1 : 0;
            const info = this._fadeMap.get(dom);
            if (!info) {
                this._fadeMap.set(dom, { opacity, fadeout });
            }
            else {
                info.fadeout = fadeout;
            }
        }
        _fadeProc(ts) {
            if (this._lastTime == 0)
                this._lastTime = ts;
            const passed = (ts - this._lastTime) / 2500;
            this._lastTime = ts;
            for (let [dom, fi] of this._fadeMap) {
                let finished = false;
                fi.opacity += fi.fadeout * passed;
                if (fi.opacity < 0) {
                    fi.opacity = 0;
                    finished = true;
                }
                else if (fi.opacity > 1) {
                    fi.opacity = 1;
                    finished = true;
                }
                dom.style.opacity = fi.opacity.toFixed(2);
                if (finished) {
                    this._fadeMap.delete(dom);
                    dom.style.visibility = (fi.opacity == 1) ? 'visible' : 'hidden';
                }
            }
            requestAnimationFrame(e => this._fadeProc(e));
        }
    }
    const fadeTool = new FadeTool();
})(CZMAP || (CZMAP = {}));
// Copyright Epic Games, Inc. All Rights Reserved.
var CZMAP;
(function (CZMAP) {
    const SDPConstraints = {
        offerToReceiveAudio: true,
        offerToReceiveVideo: true,
        /** @ts-ignore */
        voiceActivityDetection: false
    };
    class LatencyTestTimings {
        Reset() {
            this.TestStartTimeMs = null;
            this.UEReceiptTimeMs = null;
            this.UEEncodeMs = null;
            this.UECaptureToSendMs = null,
                this.UETransmissionTimeMs = null;
            this.BrowserReceiptTimeMs = null;
            this.FrameDisplayDeltaTimeMs = null;
        }
        SetUETimings(UETimings) {
            this.UEReceiptTimeMs = UETimings.ReceiptTimeMs;
            this.UEEncodeMs = UETimings.EncodeMs;
            this.UECaptureToSendMs = UETimings.CaptureToSendMs;
            this.UETransmissionTimeMs = UETimings.TransmissionTimeMs;
            this.BrowserReceiptTimeMs = Date.now();
            this.OnAllLatencyTimingsReady(this);
        }
        SetFrameDisplayDeltaTime(DeltaTimeMs) {
            if (this.FrameDisplayDeltaTimeMs == null) {
                this.FrameDisplayDeltaTimeMs = Math.round(DeltaTimeMs);
                this.OnAllLatencyTimingsReady(this);
            }
        }
        OnAllLatencyTimingsReady(Timings) {
        }
    }
    class WebRtcPlayer {
        constructor(parOptions) {
            this.forceTURN = false;
            this.forceMaxBundle = false;
            this.startVideoMuted = false;
            this.autoPlayAudio = false;
            this.forceMonoAudio = false;
            this.useMic = false;
            this.preferSFU = false;
            parOptions = typeof parOptions !== 'undefined' ? parOptions : {};
            const urlParams = new URLSearchParams(window.location.search);
            //**********************
            //Config setup
            //**********************
            this.cfg = typeof parOptions.peerConnectionOptions !== 'undefined' ? parOptions.peerConnectionOptions : {};
            /** @ts-ignore */
            this.cfg.sdpSemantics = 'unified-plan';
            // If this is true in Chrome 89+ SDP is sent that is incompatible with UE Pixel Streaming 4.26 and below.
            // However 4.27 Pixel Streaming does not need this set to false as it supports `offerExtmapAllowMixed`.
            // tdlr; uncomment this line for older versions of Pixel Streaming that need Chrome 89+.
            /** @ts-ignore */
            this.cfg.offerExtmapAllowMixed = false;
            this.forceTURN = urlParams.has('ForceTURN');
            if (this.forceTURN) {
                console.log("Forcing TURN usage by setting ICE Transport Policy in peer connection config.");
                this.cfg.iceTransportPolicy = "relay";
            }
            this.cfg.bundlePolicy = "balanced";
            this.forceMaxBundle = urlParams.has('ForceMaxBundle');
            if (this.forceMaxBundle) {
                this.cfg.bundlePolicy = "max-bundle";
            }
            //**********************
            //Variables
            //**********************
            this.pcClient = null;
            this.dcClient = null;
            this.tnClient = null;
            // See https://www.w3.org/TR/webrtc/#dom-rtcdatachannelinit for values (this is needed for Firefox to be consistent with Chrome.)
            this.dataChannelOptions = { ordered: true };
            // This is useful if the video/audio needs to autoplay (without user input) as browsers do not allow autoplay non-muted of sound sources without user interaction.
            this.startVideoMuted = typeof parOptions.startVideoMuted !== 'undefined' ? parOptions.startVideoMuted : false;
            this.autoPlayAudio = typeof parOptions.autoPlayAudio !== 'undefined' ? parOptions.autoPlayAudio : true;
            // To force mono playback of WebRTC audio
            this.forceMonoAudio = urlParams.has('ForceMonoAudio');
            if (this.forceMonoAudio) {
                console.log("Will attempt to force mono audio by munging the sdp in the browser.");
            }
            // To enable mic in browser use SSL/localhost and have ?useMic in the query string.
            this.useMic = urlParams.has('useMic');
            if (!this.useMic) {
                console.log("Microphone access is not enabled. Pass ?useMic in the url to enable it.");
            }
            // When ?useMic check for SSL or localhost
            let isLocalhostConnection = location.hostname === "localhost" || location.hostname === "127.0.0.1";
            let isHttpsConnection = location.protocol === 'https:';
            if (this.useMic && !isLocalhostConnection && !isHttpsConnection) {
                this.useMic = false;
                console.error("Microphone access in the browser will not work if you are not on HTTPS or localhost. Disabling mic access.");
                console.error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
            }
            // Prefer SFU or P2P connection
            this.preferSFU = urlParams.has('preferSFU');
            console.log(this.preferSFU ?
                "The browser will signal it would prefer an SFU connection. Remove ?preferSFU from the url to signal for P2P usage." :
                "The browser will signal for a P2P connection. Pass ?preferSFU in the url to signal for SFU usage.");
            // Latency tester
            this.latencyTestTimings = new LatencyTestTimings();
            this.video = this.createWebRtcVideo();
            this.audio = this.createWebRtcAudio();
            this.availableVideoStreams = new Map();
        }
        //**********************
        //Functions
        //**********************
        //Create Video element and expose that as a parameter
        createWebRtcVideo() {
            const video = document.createElement('video');
            video.id = "streamingVideo";
            video.playsInline = true;
            video.disablePictureInPicture = true;
            video.muted = this.startVideoMuted;
            ;
            video.addEventListener('loadedmetadata', e => CZMAP.tryCatchCall(this.onVideoInitialised), true);
            // Check if request video frame callback is supported
            if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
                // The API is supported! 
                const onVideoFrameReady = (now, metadata) => {
                    if (metadata.receiveTime && metadata.expectedDisplayTime) {
                        const receiveToCompositeMs = metadata.presentationTime - metadata.receiveTime;
                        this.aggregatedStats.receiveToCompositeMs = receiveToCompositeMs;
                    }
                    // Re-register the callback to be notified about the next frame.
                    video.requestVideoFrameCallback(onVideoFrameReady);
                };
                // Initially register the callback to be notified about the first frame.
                video.requestVideoFrameCallback(onVideoFrameReady);
            }
            return video;
        }
        createWebRtcAudio() {
            const audio = document.createElement('audio');
            audio.id = 'streamingAudio';
            return audio;
        }
        onsignalingstatechange(state) {
            console.info('Signaling state change. |', state.srcElement.signalingState, "|");
        }
        ;
        oniceconnectionstatechange(state) {
            console.info('Browser ICE connection |', state.srcElement.iceConnectionState, '|');
        }
        ;
        onicegatheringstatechange(state) {
            console.info('Browser ICE gathering |', state.srcElement.iceGatheringState, '|');
        }
        ;
        handleOnTrack(e) {
            if (e.track) {
                console.log('Got track. | Kind=' + e.track.kind + ' | Id=' + e.track.id + ' | readyState=' + e.track.readyState + ' |');
            }
            if (e.track.kind == "audio") {
                this.handleOnAudioTrack(e.streams[0]);
                return;
            }
            else
                (e.track.kind == "video");
            {
                for (const s of e.streams) {
                    if (!this.availableVideoStreams.has(s.id)) {
                        this.availableVideoStreams.set(s.id, s);
                    }
                }
                this.video.srcObject = e.streams[0];
                // All tracks are added "muted" by WebRTC/browser and become unmuted when media is being sent
                e.track.onunmute = () => {
                    this.video.srcObject = e.streams[0];
                    this.onNewVideoTrack(e.streams);
                };
            }
        }
        ;
        handleOnAudioTrack(audioMediaStream) {
            // do nothing the video has the same media stream as the audio track we have here (they are linked)
            if (this.video.srcObject == audioMediaStream) {
                return;
            }
            // video element has some other media stream that is not associated with this audio track
            else if (this.video.srcObject && this.video.srcObject !== audioMediaStream) {
                this.audio.srcObject = audioMediaStream;
            }
        }
        onDataChannel(dataChannelEvent) {
            // This is the primary data channel code path when we are "receiving"
            console.log("Data channel created for us by browser as we are a receiving peer.");
            this.dcClient = dataChannelEvent.channel;
            this.setupDataChannelCallbacks(this.dcClient);
        }
        createDataChannel(pc, label, options) {
            // This is the primary data channel code path when we are "offering"
            let datachannel = pc.createDataChannel(label, options);
            console.log(`Created datachannel (${label})`);
            this.setupDataChannelCallbacks(datachannel);
            return datachannel;
        }
        setupDataChannelCallbacks(datachannel) {
            try {
                // Inform browser we would like binary data as an ArrayBuffer (FF chooses Blob by default!)
                datachannel.binaryType = "arraybuffer";
                datachannel.onopen = (e) => {
                    console.log("Data channel connected");
                    CZMAP.tryCatchCallByThis(this, this.onDataChannelConnected);
                };
                datachannel.onclose = (e) => {
                    console.log("Data channel onclose", e);
                    CZMAP.tryCatchCallByThis(this, this.onDataChannelClose);
                };
                datachannel.onmessage = (e) => {
                    CZMAP.tryCatchCallByThis(this, this.onDataChannelMessage, e.data);
                };
                datachannel.onerror = function (e) {
                    console.error("Data channel error", e);
                };
                return datachannel;
            }
            catch (e) {
                console.warn('No data channel', e);
                return null;
            }
        }
        onicecandidate(e) {
            let candidate = e.candidate;
            if (candidate && candidate.candidate) {
                console.log("%c[Browser ICE candidate]", "background: violet; color: black", "| Type=", candidate.type, "| Protocol=", candidate.protocol, "| Address=", candidate.address, "| Port=", candidate.port, "|");
                CZMAP.tryCatchCallByThis(this, this.onWebRtcCandidate, candidate);
            }
        }
        ;
        handleCreateOffer(pc) {
            pc.createOffer(SDPConstraints).then((offer) => {
                // Munging is where we modifying the sdp string to set parameters that are not exposed to the browser's WebRTC API
                this.mungeSDPOffer(offer);
                // Set our munged SDP on the local peer connection so it is "set" and will be send across
                pc.setLocalDescription(offer);
                CZMAP.tryCatchCallByThis(this, this.onWebRtcOffer, offer);
            }, () => console.warn("Couldn't create offer"));
        }
        mungeSDPOffer(offer) {
            let audioSDP = '';
            // set max bitrate to highest bitrate Opus supports
            audioSDP += 'maxaveragebitrate=510000;';
            if (this.useMic) {
                // set the max capture rate to 48khz (so we can send high quality audio from mic)
                audioSDP += 'sprop-maxcapturerate=48000;';
            }
            // Force mono or stereo based on whether ?forceMono was passed or not
            audioSDP += this.forceMonoAudio ? 'sprop-stereo=0;stereo=0;' : 'sprop-stereo=1;stereo=1;';
            // enable in-band forward error correction for opus audio
            audioSDP += 'useinbandfec=1';
            // We use the line 'useinbandfec=1' (which Opus uses) to set our Opus specific audio parameters.
            offer.sdp = offer.sdp.replace('useinbandfec=1', audioSDP);
        }
        setupPeerConnection(pc) {
            //Setup peerConnection events
            pc.onsignalingstatechange = e => this.onsignalingstatechange(e);
            pc.oniceconnectionstatechange = e => this.oniceconnectionstatechange(e);
            pc.onicegatheringstatechange = e => this.onicegatheringstatechange(e);
            pc.ontrack = e => this.handleOnTrack(e);
            pc.onicecandidate = e => this.onicecandidate(e);
            pc.ondatachannel = e => this.onDataChannel(e);
        }
        ;
        generateAggregatedStatsFunction() {
            if (!this.aggregatedStats)
                this.aggregatedStats = {};
            return (stats) => {
                //console.log('Printing Stats');
                let newStat = {};
                stats.forEach(stat => {
                    //                    console.log(JSON.stringify(stat, undefined, 4));
                    if (stat.type == 'inbound-rtp'
                        && !stat.isRemote
                        && (stat.mediaType == 'video' || stat.id.toLowerCase().includes('video'))) {
                        newStat.timestamp = stat.timestamp;
                        newStat.bytesReceived = stat.bytesReceived;
                        newStat.framesDecoded = stat.framesDecoded;
                        newStat.packetsLost = stat.packetsLost;
                        newStat.bytesReceivedStart = this.aggregatedStats && this.aggregatedStats.bytesReceivedStart ? this.aggregatedStats.bytesReceivedStart : stat.bytesReceived;
                        newStat.framesDecodedStart = this.aggregatedStats && this.aggregatedStats.framesDecodedStart ? this.aggregatedStats.framesDecodedStart : stat.framesDecoded;
                        newStat.timestampStart = this.aggregatedStats && this.aggregatedStats.timestampStart ? this.aggregatedStats.timestampStart : stat.timestamp;
                        if (this.aggregatedStats && this.aggregatedStats.timestamp) {
                            if (this.aggregatedStats.bytesReceived) {
                                // bitrate = bits received since last time / number of ms since last time
                                //This is automatically in kbits (where k=1000) since time is in ms and stat we want is in seconds (so a '* 1000' then a '/ 1000' would negate each other)
                                newStat.bitrate = 8 * (newStat.bytesReceived - this.aggregatedStats.bytesReceived) / (newStat.timestamp - this.aggregatedStats.timestamp);
                                newStat.bitrate = Math.floor(newStat.bitrate);
                                newStat.lowBitrate = this.aggregatedStats.lowBitrate && this.aggregatedStats.lowBitrate < newStat.bitrate ? this.aggregatedStats.lowBitrate : newStat.bitrate;
                                newStat.highBitrate = this.aggregatedStats.highBitrate && this.aggregatedStats.highBitrate > newStat.bitrate ? this.aggregatedStats.highBitrate : newStat.bitrate;
                            }
                            if (this.aggregatedStats.bytesReceivedStart) {
                                newStat.avgBitrate = 8 * (newStat.bytesReceived - this.aggregatedStats.bytesReceivedStart) / (newStat.timestamp - this.aggregatedStats.timestampStart);
                                newStat.avgBitrate = Math.floor(newStat.avgBitrate);
                            }
                            if (this.aggregatedStats.framesDecoded) {
                                // framerate = frames decoded since last time / number of seconds since last time
                                newStat.framerate = (newStat.framesDecoded - this.aggregatedStats.framesDecoded) / ((newStat.timestamp - this.aggregatedStats.timestamp) / 1000);
                                newStat.framerate = Math.floor(newStat.framerate);
                                newStat.lowFramerate = this.aggregatedStats.lowFramerate && this.aggregatedStats.lowFramerate < newStat.framerate ? this.aggregatedStats.lowFramerate : newStat.framerate;
                                newStat.highFramerate = this.aggregatedStats.highFramerate && this.aggregatedStats.highFramerate > newStat.framerate ? this.aggregatedStats.highFramerate : newStat.framerate;
                            }
                            if (this.aggregatedStats.framesDecodedStart) {
                                newStat.avgframerate = (newStat.framesDecoded - this.aggregatedStats.framesDecodedStart) / ((newStat.timestamp - this.aggregatedStats.timestampStart) / 1000);
                                newStat.avgframerate = Math.floor(newStat.avgframerate);
                            }
                        }
                    }
                    //Read video track stats
                    if (stat.type == 'track' && (stat.trackIdentifier == 'video_label' || stat.kind == 'video')) {
                        newStat.framesDropped = stat.framesDropped;
                        newStat.framesReceived = stat.framesReceived;
                        newStat.framesDroppedPercentage = stat.framesDropped / stat.framesReceived * 100;
                        newStat.frameHeight = stat.frameHeight;
                        newStat.frameWidth = stat.frameWidth;
                        newStat.frameHeightStart = this.aggregatedStats && this.aggregatedStats.frameHeightStart ? this.aggregatedStats.frameHeightStart : stat.frameHeight;
                        newStat.frameWidthStart = this.aggregatedStats && this.aggregatedStats.frameWidthStart ? this.aggregatedStats.frameWidthStart : stat.frameWidth;
                    }
                    if (stat.type == 'candidate-pair' && stat.hasOwnProperty('currentRoundTripTime') && stat.currentRoundTripTime != 0) {
                        newStat.currentRoundTripTime = stat.currentRoundTripTime;
                    }
                });
                if (this.aggregatedStats.receiveToCompositeMs) {
                    newStat.receiveToCompositeMs = this.aggregatedStats.receiveToCompositeMs;
                    this.latencyTestTimings.SetFrameDisplayDeltaTime(this.aggregatedStats.receiveToCompositeMs);
                }
                this.aggregatedStats = newStat;
                if (this.onAggregatedStats)
                    this.onAggregatedStats(newStat);
            };
        }
        ;
        async setupTransceiversAsync(pc) {
            let hasTransceivers = pc.getTransceivers().length > 0;
            // Setup a transceiver for getting UE video
            pc.addTransceiver("video", { direction: "recvonly" });
            // Setup a transceiver for sending mic audio to UE and receiving audio from UE
            if (!this.useMic) {
                pc.addTransceiver("audio", { direction: "recvonly" });
            }
            else {
                let audioSendOptions = this.useMic ?
                    {
                        autoGainControl: false,
                        channelCount: 1,
                        echoCancellation: false,
                        latency: 0,
                        noiseSuppression: false,
                        sampleRate: 48000,
                        volume: 1.0
                    } : false;
                // Note using mic on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
                const stream = await navigator.mediaDevices.getUserMedia({ video: false, audio: audioSendOptions });
                if (stream) {
                    if (hasTransceivers) {
                        for (let transceiver of pc.getTransceivers()) {
                            if (transceiver && transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === "audio") {
                                for (const track of stream.getTracks()) {
                                    if (track.kind && track.kind == "audio") {
                                        transceiver.sender.replaceTrack(track);
                                        transceiver.direction = "sendrecv";
                                    }
                                }
                            }
                        }
                    }
                    else {
                        for (const track of stream.getTracks()) {
                            if (track.kind && track.kind == "audio") {
                                pc.addTransceiver(track, { direction: "sendrecv" });
                            }
                        }
                    }
                }
                else {
                    pc.addTransceiver("audio", { direction: "recvonly" });
                }
            }
        }
        ;
        //**********************
        //Public functions
        //**********************
        setVideoEnabled(enabled) {
            this.video.srcObject.getTracks().forEach(track => track.enabled = enabled);
        }
        startLatencyTest(onTestStarted) {
            // Can't start latency test without a video element
            if (!this.video) {
                return;
            }
            this.latencyTestTimings.Reset();
            this.latencyTestTimings.TestStartTimeMs = Date.now();
            onTestStarted(this.latencyTestTimings.TestStartTimeMs);
        }
        //This is called when revceiving new ice candidates individually instead of part of the offer
        handleCandidateFromServer(iceCandidate) {
            let candidate = new RTCIceCandidate(iceCandidate);
            console.log("%c[Unreal ICE candidate]", "background: pink; color: black", "| Type=", candidate.type, "| Protocol=", candidate.protocol, "| Address=", candidate.address, "| Port=", candidate.port, "|");
            // if forcing TURN, reject any candidates not relay
            if (this.forceTURN) {
                // check if no relay address is found, if so, we are assuming it means no TURN server
                if (candidate.candidate.indexOf("relay") < 0) {
                    console.warn("Dropping candidate because it was not TURN relay.", "| Type=", candidate.type, "| Protocol=", candidate.protocol, "| Address=", candidate.address, "| Port=", candidate.port, "|");
                    return;
                }
            }
            this.pcClient.addIceCandidate(candidate).catch(function (e) {
                console.error("Failed to add ICE candidate", e);
            });
        }
        ;
        //Called externaly to create an offer for the server
        createOffer() {
            if (this.pcClient) {
                console.log("Closing existing PeerConnection");
                this.pcClient.close();
                this.pcClient = null;
            }
            this.pcClient = new RTCPeerConnection(this.cfg);
            this.setupPeerConnection(this.pcClient);
            this.setupTransceiversAsync(this.pcClient).finally(() => {
                this.dcClient = this.createDataChannel(this.pcClient, 'cirrus', this.dataChannelOptions);
                this.handleCreateOffer(this.pcClient);
            });
        }
        ;
        //Called externaly when an offer is received from the server
        receiveOffer(offer) {
            var offerDesc = new RTCSessionDescription(offer);
            if (!this.pcClient) {
                console.log("Creating a new PeerConnection in the browser.");
                this.pcClient = new RTCPeerConnection(this.cfg);
                this.setupPeerConnection(this.pcClient);
                // Put things here that happen post transceiver setup
                this.pcClient.setRemoteDescription(offerDesc)
                    .then(() => {
                    this.setupTransceiversAsync(this.pcClient).finally(() => {
                        this.pcClient.createAnswer()
                            .then(answer => {
                            this.mungeSDPOffer(answer);
                            return this.pcClient.setLocalDescription(answer);
                        })
                            .then(() => {
                            CZMAP.tryCatchCallByThis(this, this.onWebRtcAnswer, this.pcClient.currentLocalDescription);
                        })
                            .then(() => {
                            let receivers = this.pcClient.getReceivers();
                            for (let receiver of receivers) {
                                /** @ts-ignore */
                                receiver.playoutDelayHint = 0;
                            }
                        })
                            .catch((error) => console.error("createAnswer() failed:", error));
                    });
                });
            }
        }
        ;
        //Called externaly when an answer is received from the server
        receiveAnswer(answer) {
            var answerDesc = new RTCSessionDescription(answer);
            this.pcClient.setRemoteDescription(answerDesc);
            let receivers = this.pcClient.getReceivers();
            for (let receiver of receivers) {
                /** @ts-ignore */
                receiver.playoutDelayHint = 0;
            }
        }
        ;
        close() {
            if (this.pcClient) {
                console.log("Closing existing peerClient");
                this.pcClient.close();
                this.pcClient = null;
            }
            if (this.aggregateStatsIntervalId)
                clearInterval(this.aggregateStatsIntervalId);
        }
        //Sends data across the datachannel
        send(data) {
            if (this.dcClient && this.dcClient.readyState == 'open') {
                //console.log('Sending data on dataconnection', this.dcClient)
                this.dcClient.send(data);
            }
        }
        ;
        getStats(onStats) {
            if (this.pcClient && onStats) {
                this.pcClient.getStats(null).then((stats) => {
                    onStats(stats);
                });
            }
        }
        aggregateStats(checkInterval) {
            let calcAggregatedStats = this.generateAggregatedStatsFunction();
            let printAggregatedStats = () => { this.getStats(calcAggregatedStats); };
            this.aggregateStatsIntervalId = setInterval(printAggregatedStats, checkInterval);
        }
    }
    CZMAP.WebRtcPlayer = WebRtcPlayer;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 导弹轨迹 */
    class MissileTrack {
        constructor(map) {
            this._attackEntites = [];
            this._intercepEntites = [];
            this._map = map;
            this._view3d = map.view3d;
            this._czviewer = this._view3d.czviewer;
        }
        /**
         * 创建攻击轨迹和拦截轨迹
         * @param attack 攻击轨迹
         * @param intercept 拦截轨迹
         */
        create(attack, intercept) {
            if (attack)
                this.createAttack(attack);
            if (intercept)
                this.createIntercept(intercept);
        }
        /** 创建导弹轨迹 */
        createAttack(option) {
            this.clearAttack();
            const track = option.track.map(pt => Cesium.Cartesian3.fromDegrees(...pt));
            const start = track[0];
            const current = track.last();
            /// 
            const sampledPos = new SampledPosition();
            sampledPos.addPoints(track);
            /// 插值轨迹线
            const interpPoints = sampledPos.samples(100);
            /// 起点
            this._createAttackEntity({
                name: '起点',
                position: start,
                billboard: {
                    image: option.start.icon
                },
            });
            this._createTrackLine(interpPoints, option.start);
            /// 目标点
            if (option.target) {
                const target = Cesium.Cartesian3.fromDegrees(...option.target.position);
                const distance = Cesium.Cartesian3.distance(start, target);
                const targetRadius = distance * 0.05;
                this._createAttackEntity({
                    name: "目标",
                    position: target,
                    ellipse: {
                        semiMinorAxis: targetRadius,
                        semiMajorAxis: targetRadius,
                        material: new CZMAP.DynamicCircleMaterialProperty(option.target)
                    }
                });
                this._createTrackLine([current, target], option.target);
            }
            /// 预估点
            if (option.estimated) {
                const estimated = Cesium.Cartesian3.fromDegrees(...option.estimated.position);
                const distance = Cesium.Cartesian3.distance(start, estimated);
                const targetRadius = distance * 0.05;
                this._createAttackEntity({
                    name: "预估点",
                    position: estimated,
                    ellipse: {
                        semiMinorAxis: targetRadius / 2,
                        semiMajorAxis: targetRadius / 2,
                        material: new CZMAP.DynamicCircleMaterialProperty(option.estimated)
                    }
                });
                this._createTrackLine([current, estimated], option.estimated);
            }
            /// 
            if (option.model) {
                /// 获取最终点的方向
                const { position, orientation } = sampledPos.calcPositonAndOrientation(1, option.model.hpr);
                this._createAttackEntity({
                    name: "当前点",
                    position,
                    orientation: orientation,
                    model: option.model
                });
            }
        }
        /** 创建拦截轨迹 */
        createIntercept(option) {
            this.clearIntercept();
            const sampledPos = new SampledPosition();
            const allPoints = [];
            let currentEnd = 0, estimatedEnd = 0;
            if (option.current) {
                currentEnd = sampledPos.addPoints(option.current.positions.map(p => Cesium.Cartesian3.fromDegrees(...p)));
            }
            if (option.estimated) {
                estimatedEnd = sampledPos.addPoints(option.estimated.positions.map(p => Cesium.Cartesian3.fromDegrees(...p)));
            }
            ///
            const currentPercent = currentEnd / sampledPos.totalDistance;
            const estimatedPercent = estimatedEnd / sampledPos.totalDistance;
            this._createIntercept(sampledPos, 0, currentPercent, option.current, option.model);
            this._createIntercept(sampledPos, currentPercent, estimatedPercent, option.estimated, option.model);
        }
        clearAttack() {
            this._attackEntites.forEach(ent => this._czviewer.entities.remove(ent));
            this._attackEntites.length = 0;
        }
        clearIntercept() {
            this._intercepEntites.forEach(ent => this._czviewer.entities.remove(ent));
            this._intercepEntites.length = 0;
        }
        clear() {
            this.clearAttack();
            this.clearIntercept();
        }
        _createIntercept(sampledPos, p0, p1, option, model) {
            if (!option)
                return;
            /// 插值轨迹线
            const interpPoints = sampledPos.sampleByPercentRange(p0, p1, 50);
            this._createTrackLine(interpPoints, option);
            if (model) {
                /// 获取最终点的方向
                const pose = sampledPos.calcPositonAndOrientation(p1, model.hpr);
                this._createInterceptEntity({
                    name: "当前点",
                    position: pose.position,
                    orientation: pose.orientation,
                    model: model
                });
                /// 获取最终点的方向
                const pose2 = sampledPos.calcPositonAndOrientation(p1, [0, -90, 0]);
                this._createInterceptEntity({
                    name: "拦截区",
                    position: pose2.position,
                    orientation: pose2.orientation,
                    ellipsoid: {
                        radii: new Cesium.Cartesian3(option.radius, option.radius, option.radius),
                        maximumCone: Cesium.Math.PI_OVER_TWO,
                        material: new CZMAP.DynamicCircleMaterialProperty({
                            color: option.color,
                            speed: -40,
                            repeat: 10,
                            mode: CZMAP.DynamicCircleMode.OnAxisY
                        }),
                        outline: false,
                    },
                });
            }
        }
        _createAttackEntity(option) {
            const entity = this._czviewer.entities.add(option);
            this._attackEntites.push(entity);
            return entity;
        }
        _createInterceptEntity(option) {
            const entity = this._czviewer.entities.add(option);
            this._intercepEntites.push(entity);
            return entity;
        }
        _createTrackLine(points, style) {
            if (style.trackStyle) {
                const line1 = this._czviewer.entities.add({ polyline: createPolyline(points, style.trackStyle) });
                this._attackEntites.push(line1);
            }
            if (style.flowStyle) {
                const line2 = this._czviewer.entities.add({ polyline: {
                        positions: points,
                        width: style.flowStyle.width,
                        material: new CZMAP.LineFlowMaterialProperty({
                            color: CZMAP.CesiumAttrib.getColor(style.flowStyle.color),
                            speed: style.flowStyle.speed,
                            percent: style.flowStyle.percent,
                            gradient: style.flowStyle.gradient
                        })
                    } });
                this._attackEntites.push(line2);
            }
        }
    }
    CZMAP.MissileTrack = MissileTrack;
    function createPolyline(points, style) {
        let material;
        switch (style.type) {
            case CZMAP.StrokeDetailType.NORMAL:
                material = CZMAP.CesiumAttrib.getColor(style.color);
                break;
            case CZMAP.StrokeDetailType.DASH:
                material = new Cesium.PolylineDashMaterialProperty({
                    color: CZMAP.CesiumAttrib.getColor(style.color),
                    gapColor: CZMAP.CesiumAttrib.getColor(style.dashColor),
                    dashLength: CZMAP.Types.defaultValue(style.dashLength, 16),
                    dashPattern: CZMAP.Types.defaultValue(style.dashPattern, 255)
                });
                break;
            case CZMAP.StrokeDetailType.GLOW:
                material = new Cesium.PolylineGlowMaterialProperty({
                    color: CZMAP.CesiumAttrib.getColor(style.color, Cesium.Color.WHITE),
                    glowPower: CZMAP.Types.defaultValue(style.glowPower, 0.25),
                    taperPower: CZMAP.Types.defaultValue(style.taperPower, 1.0)
                });
                break;
            case CZMAP.StrokeDetailType.ARROW:
                material = new Cesium.PolylineArrowMaterialProperty(CZMAP.CesiumAttrib.getColor(style.color, Cesium.Color.WHITE));
                break;
            case CZMAP.StrokeDetailType.OUTLINE:
                material = new Cesium.PolylineOutlineMaterialProperty({
                    color: CZMAP.CesiumAttrib.getColor(style.color, Cesium.Color.WHITE),
                    outlineColor: CZMAP.CesiumAttrib.getColor(style.outlineColor, Cesium.Color.BLACK),
                    outlineWidth: CZMAP.Types.defaultValue(style.outlineWidth, 1.0)
                });
        }
        return {
            positions: points,
            width: style.width,
            material
        };
    }
    function buildTrack(start, target, current, estimated) {
    }
    class SampledPosition {
        constructor() {
            this._startTime = new Cesium.JulianDate(0, 0);
            this._stopTime = new Cesium.JulianDate(0, 0);
            this._sampled = new Cesium.SampledPositionProperty();
            this._totalDistance = 0;
            const sampled = new Cesium.SampledPositionProperty();
            sampled.forwardExtrapolationType = Cesium.ExtrapolationType.HOLD;
            sampled.backwardExtrapolationType = Cesium.ExtrapolationType.HOLD;
            sampled.setInterpolationOptions({
                interpolationDegree: 2,
                interpolationAlgorithm: Cesium.LagrangePolynomialApproximation,
            });
            this._sampled = sampled;
        }
        get totalDistance() { return this._totalDistance; }
        addPoint(pt) {
            let length = 0;
            if (this._lastPoint) {
                length = Cesium.Cartesian3.distance(pt, this._lastPoint);
                if (length === 0)
                    return;
            }
            ///
            this._totalDistance += length;
            ///
            const time = Cesium.JulianDate.addSeconds(this._startTime, this._totalDistance, new Cesium.JulianDate());
            this._sampled.addSample(time, pt);
            this._stopTime = time;
            this._lastPoint = pt.clone(this._lastPoint);
            ///
            return this._totalDistance;
        }
        addPoints(pts) {
            pts.forEach(pt => this.addPoint(pt));
            return this._totalDistance;
        }
        sampleByPercent(percent) {
            return this.sampleByDistance(percent * this._totalDistance);
        }
        /** 采样 */
        sampleByDistance(distance) {
            const time = Cesium.JulianDate.addSeconds(this._startTime, distance, new Cesium.JulianDate());
            return this._sampled.getValue(time);
        }
        /** 指定采样数采样 */
        samples(count) {
            const results = [];
            const temp = new Cesium.JulianDate();
            const step = this._totalDistance / (count - 1);
            for (let i = 0; i < count; ++i) {
                const time = Cesium.JulianDate.addSeconds(this._startTime, i * step, temp);
                results.push(this._sampled.getValue(time));
            }
            return results;
        }
        sampleByPercentRange(start, end, count) {
            return this.sampleByDistanceRange(start * this._totalDistance, end * this._totalDistance, count);
        }
        sampleByDistanceRange(start, end, count) {
            const results = [];
            const temp = new Cesium.JulianDate();
            const step = (end - start) / (count - 1);
            for (let i = 0; i < count; ++i) {
                const time = Cesium.JulianDate.addSeconds(this._startTime, i * step + start, temp);
                results.push(this._sampled.getValue(time));
            }
            return results;
        }
        /** 获取指定位置的前方向向量 */
        frontDirByPercent(p0, normalize) {
            let p1 = p0 + 0.01;
            if (p0 < 0) {
                p0 = 0;
                p1 = 0.01;
            }
            else if (p0 >= 1) {
                p0 = 1 - 0.01;
                p1 = 1;
            }
            const c0 = this.sampleByPercent(p0);
            const c1 = this.sampleByPercent(p1);
            const dir = Cesium.Cartesian3.subtract(c1, c0, new Cesium.Cartesian3());
            if (normalize)
                Cesium.Cartesian3.normalize(dir, dir);
            return dir;
        }
        calcPositonAndOrientation(t, hpr) {
            const dir = this.frontDirByPercent(t, true);
            const pos = this.sampleByPercent(t);
            const matrix = new Cesium.Matrix3();
            Cesium.Transforms.rotationMatrixFromPositionVelocity(pos, dir, undefined, matrix);
            const interp_ori = Cesium.Quaternion.fromRotationMatrix(matrix, new Cesium.Quaternion());
            if (hpr) {
                const [h, p, r] = hpr;
                const chpr = Cesium.HeadingPitchRoll.fromDegrees(h, p, r);
                const ori2 = Cesium.Quaternion.fromHeadingPitchRoll(chpr);
                Cesium.Quaternion.multiply(interp_ori, ori2, interp_ori);
            }
            ///
            return { position: pos, orientation: interp_ori };
        }
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const DestCSR = "+proj=longlat +a=6378140 +b=6356755.288157528 +no_defs";
    function getGsProj(x) {
        return `+proj=tmerc +lat_0=0 +lon_0=${x.toFixed(12)} +k=1 +x_0=500000 +y_0=0 +a=6378140 +b=6356755.288157528 +units=m +no_defs`;
    }
    class ProjectionForGlobe {
        constructor() {
            this._dst = DestCSR;
            this._centerX = 0;
            this._centerY = 0;
        }
        setCrs(crs) {
            this._centerX = 0;
            this._centerY = 0;
            this._src = crs;
            this._proj = proj4(this._src, this._dst);
        }
        setCenter(x, y) {
            /// 
            this._src = getGsProj(x);
            ///
            this._proj = proj4(this._src, this._dst);
            ///
            const [cx, cy] = this._proj.inverse([x, y]);
            ///
            this._centerX = cx;
            this._centerY = cy;
        }
        toLongLat(pt) {
            const [px, py] = this._proj.forward([pt[0] + this._centerX, pt[1] + this._centerY]);
            ///
            return [px, py, pt[2]];
        }
        toLocal(pt) {
            const [px, py, pz] = this._proj.inverse(pt);
            return [px - this._centerX, py - this._centerY, pz];
        }
    }
    CZMAP.ProjectionForGlobe = ProjectionForGlobe;
    ;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 坐标变换支持
     */
    class Transforms {
        static createProj4(src, dest) {
            try {
                return proj4(src, dest);
            }
            catch (ex) {
                console.error('create Proj4 exception:', ex);
            }
        }
        static transformBox(box, src, dest) {
            if (!src || !dest)
                return box;
            if (src === dest)
                return box;
            try {
                let proj = Transforms.createProj4(src, dest);
                if (!proj)
                    return box;
                const min = box.getMin();
                trans(proj, min);
                const max = box.getMax();
                trans(proj, max);
                const nbox = new CZMAP.BoundingBox();
                nbox.mergePoint(min);
                nbox.mergePoint(max);
                return nbox;
            }
            catch (error) {
                console.error('transformBox error.', error);
            }
            return box;
        }
        /**
         * 投影坐标数组
         * @param pts 坐标数组
         * @param src 源投影西
         * @param dest 目标投影系
         */
        static transformCoordinates(pts, src, dest) {
            if (!src || !dest)
                return pts;
            if (src === dest)
                return pts;
            if (!CZMAP.Types.isArray(pts))
                return pts;
            let rt = pts;
            try {
                const proj = Transforms.createProj4(src, dest);
                if (!proj)
                    return rt;
                trans(proj, rt);
            }
            catch (error) {
                console.error('transformCoordinates error.', error);
            }
            ///
            return rt;
        }
        /**
         * 投影要素
         * @param {FeatureLike|FeatureLike[]} features
         * @param {*} src
         * @param {*} dest
         */
        static transformFeatures(features, src, dest) {
            let fs = features;
            if (!CZMAP.Types.isArray(features))
                fs = [features];
            if (!src || !dest)
                return features;
            try {
                const proj = Transforms.createProj4(src, dest);
                if (!proj)
                    return features;
                for (let i = 0; i < fs.length; ++i) {
                    let f = fs[i];
                    let g = f.geometry;
                    if (g instanceof CZMAP.Geometry) {
                        g.applyTransform((src, dest) => {
                            const result = proj.forward(src);
                            CZMAP.copyPoint(result, dest);
                        });
                    }
                    else {
                        trans(proj, g.coordinates);
                    }
                }
            }
            catch (error) {
                console.error('transformFeatures error.', error);
            }
            ///
            return fs;
        }
    }
    CZMAP.Transforms = Transforms;
    function trans(proj, pts) {
        if (!CZMAP.Types.isArray(pts))
            return;
        if (CZMAP.Types.isArray(pts[0])) {
            pts.forEach((e) => trans(proj, e));
            return;
        }
        if (CZMAP.Types.isNumber(pts[0])) {
            let v = proj.forward(pts);
            for (let i = 0; i < v.length; ++i)
                pts[i] = v[i];
        }
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 创建基于url的要素加载器
     * @param url
     * @param format
     * @param success
     * @param failed
     */
    function createUrlFeatureLoader(url, format, success, failed) {
        return function (box, res, projection) {
            //fetch(url)
            CZMAP.HttpUtil.get(new CZMAP.HttpArgs(url))
                .then(o => {
                switch (format.getType()) {
                    case CZMAP.FeatureFormatType.JSON: return o.json();
                    case CZMAP.FeatureFormatType.TEXT: return o.text();
                    case CZMAP.FeatureFormatType.XML: return o.text();
                    case CZMAP.FeatureFormatType.ARRAY_BUFFER: return o.arrayBuffer();
                }
            }, e => { if (failed)
                failed.call(this); })
                .then(data => {
                if (!data)
                    return;
                ///
                success.call(this, format.readFeatures(data), format.readProjection(data));
            }, () => { if (failed)
                failed.call(this); });
        };
    }
    CZMAP.createUrlFeatureLoader = createUrlFeatureLoader;
    /**
     * 创建基于url的数据源加载器
     * @param url
     * @param format
     */
    function createUrlVectorFeatureLoader(url, format) {
        return createUrlFeatureLoader(url, format, function (features, projection) {
            if (CZMAP.Types.isFunction(this.addFeatures))
                this.addFeatures(features);
        });
    }
    CZMAP.createUrlVectorFeatureLoader = createUrlVectorFeatureLoader;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 数据源状态
     */
    let SourceState;
    (function (SourceState) {
        SourceState["UNDEFINED"] = "undefined";
        SourceState["LOADING"] = "loading";
        SourceState["READY"] = "ready";
        SourceState["ERROR"] = "error";
    })(SourceState = CZMAP.SourceState || (CZMAP.SourceState = {}));
})(CZMAP || (CZMAP = {}));
/// <reference path="../utils/Parse.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 水平原点
     */
    let HorizontalOrigin;
    (function (HorizontalOrigin) {
        /**
         * 左对齐
         */
        HorizontalOrigin[HorizontalOrigin["LEFT"] = 0] = "LEFT";
        /**
         * 中间对齐
         */
        HorizontalOrigin[HorizontalOrigin["CENTER"] = 1] = "CENTER";
        /**
         * 右对齐
         */
        HorizontalOrigin[HorizontalOrigin["RIGHT"] = 2] = "RIGHT";
    })(HorizontalOrigin = CZMAP.HorizontalOrigin || (CZMAP.HorizontalOrigin = {}));
    ;
    /**
     * 垂直原点
     */
    let VerticalOrigin;
    (function (VerticalOrigin) {
        /**
         * 下对齐
         */
        VerticalOrigin[VerticalOrigin["BOTTOM"] = 0] = "BOTTOM";
        /**
         * 中间对齐
         */
        VerticalOrigin[VerticalOrigin["CENTER"] = 1] = "CENTER";
        /**
         * 上对齐
         */
        VerticalOrigin[VerticalOrigin["TOP"] = 2] = "TOP";
        /**
         * 基线对齐
         */
        VerticalOrigin[VerticalOrigin["BASELINE"] = 3] = "BASELINE";
    })(VerticalOrigin = CZMAP.VerticalOrigin || (CZMAP.VerticalOrigin = {}));
    ;
    let StyleProperty;
    (function (StyleProperty) {
        StyleProperty["VISIBLE"] = "visible";
    })(StyleProperty = CZMAP.StyleProperty || (CZMAP.StyleProperty = {}));
    ;
    /**
     * 样式基类
     */
    class Style extends CZMAP.BaseObject {
        constructor(style) {
            super(style);
        }
        /**
         * 是否显示该样式
         */
        get visible() { return this.get(StyleProperty.VISIBLE); }
        set visible(v) { this.set(StyleProperty.VISIBLE, v); }
        /**
         * 获取样式定义对象
         * @returns 样式定义对象
         */
        toStyleOption() {
            return this.getProperties();
        }
        static fmtHorizontal(v) {
            v = CZMAP.Types.isString(v) ? v.toUpperCase() : v;
            switch (v) {
                case 'LEFT': return HorizontalOrigin.LEFT;
                case 'CENTER': return HorizontalOrigin.CENTER;
                case 'RIGHT': return HorizontalOrigin.RIGHT;
                case HorizontalOrigin.LEFT: return HorizontalOrigin.LEFT;
                case HorizontalOrigin.CENTER: return HorizontalOrigin.CENTER;
                case HorizontalOrigin.RIGHT: return HorizontalOrigin.RIGHT;
                default: return HorizontalOrigin.LEFT;
            }
        }
        static fmtVertital(v) {
            v = CZMAP.Types.isString(v) ? v.toUpperCase() : v;
            switch (v) {
                case 'BOTTOM': return VerticalOrigin.BOTTOM;
                case 'CENTER': return VerticalOrigin.CENTER;
                case 'TOP': return VerticalOrigin.TOP;
                case 'BASELINE': return VerticalOrigin.BASELINE;
                case VerticalOrigin.BOTTOM: return VerticalOrigin.BOTTOM;
                case VerticalOrigin.CENTER: return VerticalOrigin.CENTER;
                case VerticalOrigin.TOP: return VerticalOrigin.TOP;
                case VerticalOrigin.BASELINE: return VerticalOrigin.BASELINE;
                default: return VerticalOrigin.BOTTOM;
            }
        }
        _initDefines() {
            super._initDefines();
            this.def(StyleProperty.VISIBLE, true, CZMAP.Parse.parseBoolean);
        }
    }
    CZMAP.Style = Style;
})(CZMAP || (CZMAP = {}));
/// <reference path="Style.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 标注的属性集合
     */
    let BillStyleProperty;
    (function (BillStyleProperty) {
        BillStyleProperty["OFFSET"] = "offset";
        BillStyleProperty["HORIZONTAL_ORIGIN"] = "horizontalOrigin";
        BillStyleProperty["VERTICAL_ORIGIN"] = "verticalOrigin";
        BillStyleProperty["VISIBLE_RANGE"] = "visibleRange";
        BillStyleProperty["FADE_DISTANCE"] = "fadeDistance";
        BillStyleProperty["SCALE_DISTANCE"] = "scaleDistance";
        BillStyleProperty["DEPTH_DISTANCE"] = "depthDistance";
    })(BillStyleProperty = CZMAP.BillStyleProperty || (CZMAP.BillStyleProperty = {}));
    /**
     * 公告板样式
     */
    class BillStyle extends CZMAP.Style {
        constructor(option) {
            super(option);
        }
        _initDefines() {
            super._initDefines();
            /// 初始化默认值
            this.def(BillStyleProperty.OFFSET, [0, 0], CZMAP.Numbers.parseArray2, CZMAP.ArrayUtils.equals);
            this.def(BillStyleProperty.HORIZONTAL_ORIGIN, CZMAP.HorizontalOrigin.CENTER, CZMAP.Style.fmtHorizontal);
            this.def(BillStyleProperty.VERTICAL_ORIGIN, CZMAP.VerticalOrigin.CENTER, CZMAP.Style.fmtVertital);
            this.def(BillStyleProperty.VISIBLE_RANGE, [0, 100000000], CZMAP.Numbers.parseArray2, CZMAP.ArrayUtils.equals);
            this.def(BillStyleProperty.SCALE_DISTANCE, undefined, CZMAP.Numbers.parseArray4, CZMAP.ArrayUtils.equals);
            this.def(BillStyleProperty.FADE_DISTANCE, undefined, CZMAP.Numbers.parseArray4, CZMAP.ArrayUtils.equals);
            this.def(BillStyleProperty.DEPTH_DISTANCE, undefined, CZMAP.Numbers.parseNumber);
        }
        set offset(v) { this.set(BillStyleProperty.OFFSET, v, false); }
        get offset() { return this.get(BillStyleProperty.OFFSET); }
        set horizontalOrigin(v) { this.set(BillStyleProperty.HORIZONTAL_ORIGIN, v); }
        get horizontalOrigin() { return this.get(BillStyleProperty.HORIZONTAL_ORIGIN); }
        set vertitalOrigin(v) { this.set(BillStyleProperty.VERTICAL_ORIGIN, v); }
        get vertitalOrigin() { return this.get(BillStyleProperty.VERTICAL_ORIGIN); }
        set visibleRange(v) { this.set(BillStyleProperty.VISIBLE_RANGE, v); }
        get visibleRange() { return this.get(BillStyleProperty.VISIBLE_RANGE); }
        set scaleDistance(v) { this.set(BillStyleProperty.SCALE_DISTANCE, v); }
        get scaleDistance() { return this.get(BillStyleProperty.SCALE_DISTANCE); }
        set fadeDistance(v) { this.set(BillStyleProperty.FADE_DISTANCE, v); }
        get fadeDistance() { return this.get(BillStyleProperty.FADE_DISTANCE); }
        set depthDistance(v) { this.set(BillStyleProperty.DEPTH_DISTANCE, v); }
        get depthDistance() { return this.get(BillStyleProperty.DEPTH_DISTANCE); }
    }
    CZMAP.BillStyle = BillStyle;
})(CZMAP || (CZMAP = {}));
/// <reference path="Style.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 要素样式
     */
    class FeatureStyle extends CZMAP.Style {
        ///
        constructor(style) {
            super();
            /** 图标样式 */
            this._icon = null;
            /** 标注样式 */
            this._label = null;
            /** 模型样式 */
            this._model = null;
            /** 线样式 */
            this._stroke = null;
            /** 墙样式 */
            this._wall = null;
            /** 要素名称 */
            this._name = null;
            /** 提示信息 */
            this._tip = undefined;
            /** 菜单信息 */
            this._menu = undefined;
            /// 
            style = style || {};
            this._name = CZMAP.Types.defaultValue(style.name, '');
            this._icon = createStyle(CZMAP.IconStyle, style.icon);
            this._label = createStyle(CZMAP.LabelStyle, style.label);
            this._model = createStyle(CZMAP.ModelStyle, style.model);
            this._stroke = createStyle(CZMAP.StrokeStyle, style.stroke);
            this._wall = createStyle(CZMAP.WallStyle, style.wall);
            this._tip = undefined;
            this._menu = undefined;
        }
        get name() { return this._name; }
        /** 获取图标样式 */
        get icon() { return this._icon; }
        /** 获取标注样式 */
        get label() { return this._label; }
        /** 获取模型样式 */
        get model() { return this._model; }
        /** 获取线样式 */
        get stroke() { return this._stroke; }
        /** 获取墙样式 */
        get wall() { return this._wall; }
        /** 获取TIP信息 */
        get tip() { return this._tip; }
        /** 获取菜单信息 */
        get menu() { return this._menu; }
        /**
         * 更新样式
         * @param {Object} temp 样式模板
         * @param {Object} data 数据源
         * @param {Boolean} dynOnly 仅包含动态样式
         */
        update(temp, data, dynOnly) {
            /// 样式定义
            let style_def = JSON.parse(JSON.stringify(temp));
            if (data)
                parseVar(style_def, data, dynOnly);
            ///
            style_def = style_def || {};
            this._name = style_def.name;
            /// 创建样式
            const createStyle = (style, creator, def, name, sname) => {
                if (!CZMAP.Types.isDefined(def[name]))
                    return;
                /// 创建新对象
                if (!style)
                    style = new creator();
                /// 兼容性支持
                def = getStyleDef(def, name, sname);
                setStyleProperties(style, def);
                return style;
            };
            ///
            this._label = createStyle(this._label, CZMAP.LabelStyle, style_def, 'label', 'text');
            this._icon = createStyle(this._icon, CZMAP.IconStyle, style_def, 'icon', 'src');
            this._model = createStyle(this._model, CZMAP.ModelStyle, style_def, 'model', 'src');
            this._stroke = createStyle(this._stroke, CZMAP.StrokeStyle, style_def, 'stroke', 'src');
            this._wall = createStyle(this._wall, CZMAP.WallStyle, style_def, 'wall', 'src');
            // 
            if (CZMAP.Types.isDefined(style_def.tip)) {
                this._tip = style_def.tip;
            }
            if (CZMAP.Types.isDefined(style_def.menu)) {
                this._menu = style_def.menu;
            }
        }
    }
    /**
     * 默认样式
     */
    FeatureStyle.default = new FeatureStyle();
    CZMAP.FeatureStyle = FeatureStyle;
    function setStyleProperties(style, def) {
        for (const key in def) {
            style.set(key, def[key]);
            const key2 = CZMAP.toCamelCase(key);
            if (key2)
                style.set(key2, def[key]);
        }
    }
    function createStyle(type, data) {
        if (!CZMAP.Types.isDefined(data))
            return undefined;
        if (data instanceof type)
            return data;
        ///
        return new type(data);
    }
    /**
     * 解析样式模板
     *
     * @param {*} style 样式模板
     * @param {*} data 数据
     */
    function parseVar(style, data, dynOnly) {
        if (CZMAP.Types.isString(style)) {
            if (dynOnly)
                return CZMAP.StringTemp.parseVarMatch(style, data);
            else
                return CZMAP.StringTemp.parseVar(style, data);
        }
        if (CZMAP.Types.isArray(style)) {
            const pv = [];
            let hasValue = false;
            ///
            for (let i = 0; i < style.length; ++i) {
                pv[i] = parseVar(style[i], data, dynOnly);
                if (pv[i] !== null) {
                    hasValue = true;
                }
                else {
                    pv[i] = style[i];
                }
            }
            ///
            return dynOnly && !hasValue ? null : pv;
        }
        if (CZMAP.Types.isObject(style)) {
            for (let k in style) {
                style[k] = parseVar(style[k], data, dynOnly);
                if (dynOnly && style[k] === null) {
                    delete style[k];
                }
            }
            ///
            return style;
        }
        ///
        if (dynOnly)
            return null;
        ///
        return style;
    }
    function subProperties(base, prefix, sub) {
        const keys = Object.keys(base);
        keys.forEach(e => {
            if (e.startsWith(prefix))
                sub[e.substring(prefix.length)] = base[e];
        });
    }
    function getStyleDef(style, name, sname) {
        let def = style[name];
        if (CZMAP.Types.isDefined(def) && !CZMAP.Types.isObject(def)) {
            def = { [sname]: style[name] };
            subProperties(style, `${name}-`, def);
        }
        return def;
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="BillStyle.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 标注的属性集合
     */
    let IconStyleProperty;
    (function (IconStyleProperty) {
        IconStyleProperty["SOURCE"] = "src";
        IconStyleProperty["COLOR"] = "color";
        IconStyleProperty["WIDTH"] = "width";
        IconStyleProperty["HEIGHT"] = "height";
        IconStyleProperty["ROTATION"] = "rotate";
    })(IconStyleProperty = CZMAP.IconStyleProperty || (CZMAP.IconStyleProperty = {}));
    /**
     * 图标样式
     */
    class IconStyle extends CZMAP.BillStyle {
        constructor(option) {
            super(option);
        }
        _initDefines() {
            super._initDefines();
            this.def(IconStyleProperty.SOURCE, '');
            this.def(IconStyleProperty.COLOR, 'white');
            this.def(IconStyleProperty.WIDTH, undefined, CZMAP.Numbers.parseNumber);
            this.def(IconStyleProperty.HEIGHT, undefined, CZMAP.Numbers.parseNumber);
            this.def(IconStyleProperty.ROTATION, 0, CZMAP.Numbers.parseNumber);
        }
        /**
         * 图标的源
         */
        get src() { return this.get(IconStyleProperty.SOURCE); }
        set src(v) { this.set(IconStyleProperty.SOURCE, v); }
        /**
         * 图标的源
         */
        get color() { return this.get(IconStyleProperty.COLOR); }
        set color(v) { this.set(IconStyleProperty.COLOR, v); }
        /**
         * 宽度
         */
        get width() { return this.get(IconStyleProperty.WIDTH); }
        set width(v) { this.set(IconStyleProperty.WIDTH, v); }
        /**
         * 高度
         */
        get height() { return this.get(IconStyleProperty.HEIGHT); }
        set height(v) { this.set(IconStyleProperty.HEIGHT, v); }
        /**
         * 高度
         */
        get rotate() { return this.get(IconStyleProperty.ROTATION); }
        set rotate(v) { this.set(IconStyleProperty.ROTATION, v); }
    }
    CZMAP.IconStyle = IconStyle;
})(CZMAP || (CZMAP = {}));
/// <reference path="BillStyle.ts" />
var CZMAP;
(function (CZMAP) {
    /**
     * 标注的属性集合
     */
    let LabelStyleProperty;
    (function (LabelStyleProperty) {
        LabelStyleProperty["TEXT"] = "text";
        LabelStyleProperty["FONT"] = "font";
        LabelStyleProperty["COLOR"] = "color";
        LabelStyleProperty["PADDING"] = "padding";
        LabelStyleProperty["BORDER_COLOR"] = "borderColor";
        LabelStyleProperty["BORDER_WIDTH"] = "borderWidth";
        LabelStyleProperty["BACKGROUND"] = "background";
        LabelStyleProperty["BACKGROUND_COLOR"] = "backgroundColor";
        LabelStyleProperty["BACKGROUND_BORDER_COLOR"] = "backgroundBorderColor";
        LabelStyleProperty["BACKGROUND_BORDER_WIDTH"] = "backgroundBorderWidth";
        LabelStyleProperty["BACKGROUND_BORDER_RADIUS"] = "backgroundBorderRadius";
        LabelStyleProperty["LINE_OFFSET"] = "lineOffset";
        LabelStyleProperty["LINE_COLOR"] = "lineColor";
        LabelStyleProperty["LINE_WIDTH"] = "lineWidth";
    })(LabelStyleProperty = CZMAP.LabelStyleProperty || (CZMAP.LabelStyleProperty = {}));
    /**
     * 标注样式
     */
    class LabelStyle extends CZMAP.BillStyle {
        constructor(option) {
            super(option);
        }
        _initDefines() {
            super._initDefines();
            /// 初始化默认值
            this.def(LabelStyleProperty.TEXT);
            this.def(LabelStyleProperty.FONT, '32px 黑体');
            this.def(LabelStyleProperty.COLOR, 'black');
            this.def(LabelStyleProperty.PADDING, [2, 2], CZMAP.Numbers.parseArray2, CZMAP.ArrayUtils.equals);
            this.def(LabelStyleProperty.BORDER_COLOR, 'black');
            this.def(LabelStyleProperty.BORDER_WIDTH, 0, CZMAP.Numbers.parseNumber);
            this.def(LabelStyleProperty.BACKGROUND, true);
            this.def(LabelStyleProperty.BACKGROUND_COLOR, '#606060');
            this.def(LabelStyleProperty.BACKGROUND_BORDER_COLOR, '#000');
            this.def(LabelStyleProperty.BACKGROUND_BORDER_WIDTH, 0, CZMAP.Numbers.parseNumber);
            this.def(LabelStyleProperty.BACKGROUND_BORDER_RADIUS, 5, CZMAP.Numbers.parseNumber);
            this.def(LabelStyleProperty.LINE_OFFSET, undefined, CZMAP.Numbers.parseArray3, CZMAP.ArrayUtils.equals);
            this.def(LabelStyleProperty.LINE_WIDTH, 1, CZMAP.Numbers.parseNumber);
            this.def(LabelStyleProperty.LINE_COLOR, 'red');
        }
        set text(v) { this.set(LabelStyleProperty.TEXT, v); }
        get text() { return this.get(LabelStyleProperty.TEXT); }
        set font(v) { this.set(LabelStyleProperty.FONT, v); }
        get font() { return this.get(LabelStyleProperty.FONT); }
        set color(v) { this.set(LabelStyleProperty.COLOR, v); }
        get color() { return this.get(LabelStyleProperty.COLOR); }
        set padding(v) { this.set(LabelStyleProperty.PADDING, v); }
        get padding() { return this.get(LabelStyleProperty.PADDING); }
        set borderColor(v) { this.set(LabelStyleProperty.BORDER_COLOR, v); }
        get borderColor() { return this.get(LabelStyleProperty.BORDER_COLOR); }
        set borderWidth(v) { this.set(LabelStyleProperty.BORDER_WIDTH, v); }
        get borderWidth() { return this.get(LabelStyleProperty.BORDER_WIDTH); }
        set background(v) { this.set(LabelStyleProperty.BACKGROUND, v); }
        get background() { return this.get(LabelStyleProperty.BACKGROUND); }
        set backgroundColor(v) { this.set(LabelStyleProperty.BACKGROUND_COLOR, v); }
        get backgroundColor() { return this.get(LabelStyleProperty.BACKGROUND_COLOR); }
        set backgroundBorderColor(v) { this.set(LabelStyleProperty.BACKGROUND_BORDER_COLOR, v); }
        get backgroundBorderColor() { return this.get(LabelStyleProperty.BACKGROUND_BORDER_COLOR); }
        set backgroundBorderWidth(v) { this.set(LabelStyleProperty.BACKGROUND_BORDER_WIDTH, v); }
        get backgroundBorderWidth() { return this.get(LabelStyleProperty.BACKGROUND_BORDER_WIDTH); }
        set backgroundBorderRadius(v) { this.set(LabelStyleProperty.BACKGROUND_BORDER_RADIUS, v); }
        get backgroundBorderRadius() { return this.get(LabelStyleProperty.BACKGROUND_BORDER_RADIUS); }
        set lineOffset(v) { this.set(LabelStyleProperty.LINE_OFFSET, v); }
        get lineOffset() { return this.get(LabelStyleProperty.LINE_OFFSET); }
        set lineWidth(v) { this.set(LabelStyleProperty.LINE_WIDTH, v); }
        get lineWidth() { return this.get(LabelStyleProperty.LINE_WIDTH); }
        set lineColor(v) { this.set(LabelStyleProperty.LINE_COLOR, v); }
        get lineColor() { return this.get(LabelStyleProperty.LINE_COLOR); }
    }
    CZMAP.LabelStyle = LabelStyle;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let ModelStyleProperty;
    (function (ModelStyleProperty) {
        ModelStyleProperty["SOURCE"] = "src";
        ModelStyleProperty["POSE"] = "pose";
        ModelStyleProperty["SCALE"] = "scale";
    })(ModelStyleProperty = CZMAP.ModelStyleProperty || (CZMAP.ModelStyleProperty = {}));
    ;
    class ModelStyle extends CZMAP.Style {
        constructor(style) {
            super(style);
        }
        _initDefines() {
            super._initDefines();
            this.def(ModelStyleProperty.SOURCE, '');
            this.def(ModelStyleProperty.POSE, [0, 0, 0], CZMAP.Numbers.parseArray3, CZMAP.ArrayUtils.equals);
            this.def(ModelStyleProperty.SCALE, 1, CZMAP.Numbers.parseNumber);
        }
        /**
         * 模型数据源
         */
        get src() { return this.get(ModelStyleProperty.SOURCE); }
        set src(v) { this.set(ModelStyleProperty.SOURCE, v); }
        /**
         * 模型的姿态
         */
        get pose() { return this.get(ModelStyleProperty.POSE); }
        set pose(v) { this.set(ModelStyleProperty.POSE, v); }
        /**
         * 模型的缩放
         */
        get scale() { return this.get(ModelStyleProperty.SCALE); }
        set scale(v) { this.set(ModelStyleProperty.SCALE, v); }
    }
    CZMAP.ModelStyle = ModelStyle;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 线形 */
    let StrokeDetailType;
    (function (StrokeDetailType) {
        /**
         * 普通样式
         */
        StrokeDetailType["NORMAL"] = "normal";
        /**
         * 炽热样式
         */
        StrokeDetailType["GLOW"] = "glow";
        /**
         * 轮库线样式
         */
        StrokeDetailType["OUTLINE"] = "outline";
        /**
         * 点划线样式
         */
        StrokeDetailType["DASH"] = "dash";
        /**
         * 箭头样式
         */
        StrokeDetailType["ARROW"] = "arrow";
    })(StrokeDetailType = CZMAP.StrokeDetailType || (CZMAP.StrokeDetailType = {}));
    /** 弧线类型 */
    let StrokeArcType;
    (function (StrokeArcType) {
        /** 直线 */
        StrokeArcType["NONE"] = "none";
        /** 最短弧线 */
        StrokeArcType["GEODESIC"] = "geodesic";
        /** 罗盘方位线 */
        StrokeArcType["RHUMB"] = "rhumb";
    })(StrokeArcType = CZMAP.StrokeArcType || (CZMAP.StrokeArcType = {}));
    let StrokeStyleProperty;
    (function (StrokeStyleProperty) {
        StrokeStyleProperty["FOLLOW_SURFACE"] = "followSurface";
        StrokeStyleProperty["WIDTH"] = "width";
        StrokeStyleProperty["ARC_TYPE"] = "arcType";
        StrokeStyleProperty["DETAIL"] = "detail";
        StrokeStyleProperty["DEPTH_FAIL_DETAIL"] = "depthFailDetail";
        StrokeStyleProperty["DEPTH_CHECK"] = "depthCheck";
        StrokeStyleProperty["VISIBLE_RANGE"] = "visibleRange";
    })(StrokeStyleProperty = CZMAP.StrokeStyleProperty || (CZMAP.StrokeStyleProperty = {}));
    /** 折线样式 */
    class StrokeStyle extends CZMAP.Style {
        constructor(style) {
            super(style);
        }
        _initDefines() {
            super._initDefines();
            this.def(StrokeStyleProperty.FOLLOW_SURFACE, false);
            this.def(StrokeStyleProperty.WIDTH, 1, CZMAP.Numbers.parseInteger);
            this.def(StrokeStyleProperty.ARC_TYPE, 'none');
            this.def(StrokeStyleProperty.VISIBLE_RANGE, undefined, CZMAP.Numbers.parseArray2, CZMAP.ArrayUtils.equals);
            this.def(StrokeStyleProperty.DETAIL);
            this.def(StrokeStyleProperty.DEPTH_FAIL_DETAIL);
            this.def(StrokeStyleProperty.DEPTH_CHECK, false);
        }
        get followSurface() { return this.get(StrokeStyleProperty.FOLLOW_SURFACE); }
        set followSurface(v) { this.set(StrokeStyleProperty.FOLLOW_SURFACE, v); }
        get width() { return this.get(StrokeStyleProperty.WIDTH); }
        set width(v) { this.set(StrokeStyleProperty.WIDTH, v); }
        get arcType() { return this.get(StrokeStyleProperty.ARC_TYPE); }
        set arcType(v) { this.set(StrokeStyleProperty.ARC_TYPE, v); }
        get visibleRange() { return this.get(StrokeStyleProperty.VISIBLE_RANGE); }
        set visibleRange(v) { this.set(StrokeStyleProperty.VISIBLE_RANGE, v); }
        get detail() { return this.get(StrokeStyleProperty.DETAIL); }
        set detail(v) { this.set(StrokeStyleProperty.DETAIL, v); }
        get depthFailDetail() { return this.get(StrokeStyleProperty.DEPTH_FAIL_DETAIL); }
        set depthFailDetail(v) { this.set(StrokeStyleProperty.DEPTH_FAIL_DETAIL, v); }
        get depthCheck() { return this.get(StrokeStyleProperty.DEPTH_CHECK); }
        set depthCheck(v) { this.set(StrokeStyleProperty.DEPTH_CHECK, v); }
    }
    CZMAP.StrokeStyle = StrokeStyle;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let WallStyleProperty;
    (function (WallStyleProperty) {
        WallStyleProperty["COLOR"] = "color";
        WallStyleProperty["IMAGE"] = "image";
        WallStyleProperty["MODE"] = "mode";
        WallStyleProperty["IMAGE_REPEAT_Y"] = "imageRepeatY";
        WallStyleProperty["HEIGHT"] = "height";
        WallStyleProperty["THICKNESS"] = "thickness";
        WallStyleProperty["OUTLINE_WITDH"] = "outlineWidth";
        WallStyleProperty["OUTLINE_COLOR"] = "outlineColor";
        WallStyleProperty["VISIBLE_RANGE"] = "visibleRange";
    })(WallStyleProperty = CZMAP.WallStyleProperty || (CZMAP.WallStyleProperty = {}));
    /** 折线样式 */
    class WallStyle extends CZMAP.Style {
        constructor(style) {
            super(style);
        }
        _initDefines() {
            super._initDefines();
            this.def(WallStyleProperty.COLOR, 'white');
            this.def(WallStyleProperty.IMAGE);
            this.def(WallStyleProperty.MODE, 'wall');
            this.def(WallStyleProperty.IMAGE_REPEAT_Y, 1, CZMAP.Numbers.parseNumber);
            this.def(WallStyleProperty.HEIGHT);
            this.def(WallStyleProperty.THICKNESS, 0);
            this.def(WallStyleProperty.OUTLINE_COLOR);
            this.def(WallStyleProperty.OUTLINE_WITDH, undefined, CZMAP.Numbers.parseInteger);
            this.def(WallStyleProperty.VISIBLE_RANGE, undefined, CZMAP.Numbers.parseArray2, CZMAP.ArrayUtils.equals);
        }
        get color() { return this.get(WallStyleProperty.COLOR); }
        set color(v) { this.set(WallStyleProperty.COLOR, v); }
        get image() { return this.get(WallStyleProperty.IMAGE); }
        set image(v) { this.set(WallStyleProperty.IMAGE, v); }
        get mode() { return this.get(WallStyleProperty.MODE); }
        set mode(v) { this.set(WallStyleProperty.MODE, v); }
        get imageRepeatY() { return this.get(WallStyleProperty.IMAGE_REPEAT_Y); }
        set imageRepeatY(v) { this.set(WallStyleProperty.IMAGE_REPEAT_Y, v); }
        get height() { return this.get(WallStyleProperty.HEIGHT); }
        set height(v) { this.set(WallStyleProperty.HEIGHT, v); }
        get thickness() { return this.get(WallStyleProperty.THICKNESS); }
        set thickness(v) { this.set(WallStyleProperty.THICKNESS, v); }
        get outlineColor() { return this.get(WallStyleProperty.OUTLINE_COLOR); }
        set outlineColor(v) { this.set(WallStyleProperty.OUTLINE_COLOR, v); }
        get outlineWidth() { return this.get(WallStyleProperty.OUTLINE_WITDH); }
        set outlineWidth(v) { this.set(WallStyleProperty.OUTLINE_WITDH, v); }
        get visibleRange() { return this.get(WallStyleProperty.VISIBLE_RANGE); }
        set visibleRange(v) { this.set(WallStyleProperty.VISIBLE_RANGE, v); }
    }
    CZMAP.WallStyle = WallStyle;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 工具类的基类，抽象类，不要直接构造改对象
     */
    class BaseTool extends CZMAP.BaseObject {
        /**
         *
         * @param map 地图对象
         */
        constructor(view) {
            super();
            ///
            this.map = view.map;
            this.view = view;
        }
    }
    CZMAP.BaseTool = BaseTool;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let ClipPlaneProperty;
    (function (ClipPlaneProperty) {
        ClipPlaneProperty["COLOR"] = "color";
        ClipPlaneProperty["BORDER_COLOR"] = "border_color";
        ClipPlaneProperty["BORDER_WIDTH"] = "border_width";
    })(ClipPlaneProperty = CZMAP.ClipPlaneProperty || (CZMAP.ClipPlaneProperty = {}));
    let AxisClipPlaneProperty;
    (function (AxisClipPlaneProperty) {
        AxisClipPlaneProperty["AXIS"] = "axis";
        AxisClipPlaneProperty["DISTANCE"] = "distance";
    })(AxisClipPlaneProperty = CZMAP.AxisClipPlaneProperty || (CZMAP.AxisClipPlaneProperty = {}));
    let PathClipPlanesProperty;
    (function (PathClipPlanesProperty) {
        PathClipPlanesProperty["PATH"] = "path";
    })(PathClipPlanesProperty = CZMAP.PathClipPlanesProperty || (CZMAP.PathClipPlanesProperty = {}));
    let ClipPlaneType;
    (function (ClipPlaneType) {
        ClipPlaneType[ClipPlaneType["AXIS_PLANE"] = 0] = "AXIS_PLANE";
        ClipPlaneType[ClipPlaneType["PATH_PLANE"] = 1] = "PATH_PLANE";
    })(ClipPlaneType = CZMAP.ClipPlaneType || (CZMAP.ClipPlaneType = {}));
    class BoxBasedTool extends CZMAP.BaseTool {
        constructor(view, box) {
            super(view);
            this._box = box.clone();
            this._center = box.getCenter();
            this._size = box.getSize();
            const [s0, s1, s2] = this._size;
            this._gsize = [s0 * 111000, s1 * 111000, s2];
        }
        get box() { return this._box; }
        get center() { return this._center; }
        get size() { return this._size; }
        get gsize() { return this._gsize; }
    }
    CZMAP.BoxBasedTool = BoxBasedTool;
    class ClipPlaneBase extends BoxBasedTool {
        constructor(view, box) {
            super(view, box);
        }
        get color() { return this.get(ClipPlaneProperty.COLOR); }
        set color(color) { this.set(ClipPlaneProperty.COLOR, color); }
        get borderColor() { return this.get(ClipPlaneProperty.BORDER_COLOR); }
        set borderColor(color) { this.set(ClipPlaneProperty.BORDER_COLOR, color); }
        get borderWidth() { return this.get(ClipPlaneProperty.BORDER_WIDTH); }
        set borderWidth(width) { this.set(ClipPlaneProperty.BORDER_WIDTH, width); }
    }
    CZMAP.ClipPlaneBase = ClipPlaneBase;
    class AxisClipPlane extends ClipPlaneBase {
        constructor(view, box) {
            super(view, box);
        }
        get axis() { return this.get(AxisClipPlaneProperty.AXIS); }
        set axis(axis) { this.set(AxisClipPlaneProperty.AXIS, axis); }
        get distance() { return this.get(AxisClipPlaneProperty.DISTANCE); }
        set distance(dist) { this.set(AxisClipPlaneProperty.DISTANCE, dist); }
        get percent() {
            const size = this.gsize[this.axis];
            return ((this.distance + size / 2) / size);
        }
        set percent(val) {
            const size = this.gsize[this.axis];
            this.distance = val * size - (size / 2);
        }
    }
    CZMAP.AxisClipPlane = AxisClipPlane;
    class PathClipPlanes extends ClipPlaneBase {
        constructor(view, box) {
            super(view, box);
            this._path = [];
            this._path0 = [];
        }
        get path() { return this._path.slice(); }
        _clone() {
            const len = this._path0.length;
            this._path.length = len;
            for (let i = 0; i < len; ++i) {
                this._path[i] = this._path0[i].slice();
            }
        }
        /** 添加点 */
        addPoint(point) {
            const [x, y] = point;
            this._path0.push([x, y, 0]);
            this._clone();
            this._onPathChanged();
        }
        /** 清除 */
        clear() {
            this._path0.length = 0;
            this._path.length = 0;
            this._onPathChanged();
        }
        /**
         * 闭合
         */
        closePath() {
            if (this._path0.length < 3)
                return;
            this._clone();
            const p0 = this._path[0];
            const p1 = this._path[this._path.length - 1];
            if (!CZMAP.comparePoint(p0, p1)) {
                this._path.push(p0.slice());
            }
            ///
            this._onPathChanged();
        }
        /** 扩展 */
        extendPath() {
            if (this._path0.length < 2)
                return;
            ///
            this._clone();
            const p = this._path;
            const l = p.length;
            const hsize = CZMAP.GeoMath.mulScalar(this.size, 0.5);
            const [cx, cy] = this.center;
            const [sx, sy] = hsize;
            const box = [
                [cx - sx, cy - sy],
                [cx + sx, cy - sy],
                [cx + sx, cy + sy],
                [cx - sx, cy + sy],
                [cx - sx, cy - sy],
            ];
            ///
            p[0] = this._extendLineToBox(p[1], p[0], box);
            p[l - 1] = this._extendLineToBox(p[l - 2], p[l - 1], box);
            ///
            this._onPathChanged();
        }
        /** 计算线段到包围盒的交点 */
        _extendLineToBox(p0, p1, box) {
            const es = [];
            for (let i = 1; i < box.length; ++i) {
                const b0 = box[i - 1];
                const b1 = box[i];
                const e = [0, 0, 0];
                if (CZMAP.Math2D.Intersect2D(p0, p1, b0, b1, e, false)) {
                    const d1 = CZMAP.GeoMath.squareDistance(p1, e);
                    const d2 = CZMAP.GeoMath.squareDistance(p0, e);
                    if (d1 < d2)
                        es.push({ e, d: d1 });
                }
            }
            es.sort((a, b) => a.d - b.d);
            return es[0].e;
        }
        _onPathChanged() {
        }
    }
    CZMAP.PathClipPlanes = PathClipPlanes;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 坐标网格 */
    class CoordGrid extends CZMAP.BaseTool {
        constructor(view) {
            super(view);
        }
    }
    CZMAP.CoordGrid = CoordGrid;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 默认分组 */
    const DefaultGroup = '';
    /**
     * 绘制工具
     * @abstract
     */
    class DrawTool extends CZMAP.BaseTool {
        constructor(view) {
            super(view);
            this._next_id = 0;
            this._itemGroups = new Map();
            this._eventBind = new CZMAP.EventTargetHelper();
            this._maxPoints = Number.MAX_VALUE;
            this._autoAdd = true;
            this._showDrawing = true;
            this._points = [];
        }
        _getNextID() { return this._next_id++; }
        /**
         * 清除所有绘制对象
         * @param group 绘制组
         */
        clear(group) {
            group = group !== null && group !== void 0 ? group : DefaultGroup;
            const items = [...this._itemGroups.entries()];
            items.forEach(item => {
                if (item[1] === group)
                    this.remove(item[0]);
            });
        }
        /** 设置对象的组 */
        _setGroup(id, group) {
            this._itemGroups.set(id, group !== null && group !== void 0 ? group : DefaultGroup);
        }
        _delGroup(id) {
            this._itemGroups.delete(id);
        }
        /**
         * 画图形
         * @param type 图形类型
         * @param callback 绘制结束回调
         * @param style 绘制样式
         * @param opt_this 回调绑定的this
         * @see {@link DrawTool.startDraw}
         */
        draw(type, callback, style, opt_this, option) {
            this.startDraw({
                type, style,
                drawing: option.drawing,
                finished: (geo) => callback.call(opt_this, geo),
                canceled: option.canceled,
                maxPoints: option.maxPoints,
                group: option.group,
                autoAdd: option.autoAdd,
                showDrawing: option.showDrawing
            });
        }
        /**
         * 画点
         */
        drawPoint(callback, style, opt_this, option) { this.draw(CZMAP.GeometryType.POINT, callback, style, opt_this, option); }
        /**
         * 画线
         */
        drawLine(callback, style, opt_this, option) {
            option = option !== null && option !== void 0 ? option : {};
            option.maxPoints = 2;
            this.draw(CZMAP.GeometryType.POLYLINE, callback, style, opt_this, option);
        }
        /**
         * 画线
         */
        drawPolyline(callback, style, opt_this, option) { this.draw(CZMAP.GeometryType.POLYLINE, callback, style, opt_this, option); }
        /**
         * 画圆
         */
        drawCircle(callback, style, opt_this, option) { this.draw(CZMAP.GeometryType.CIRCLE, callback, style, opt_this, option); }
        /**
         * 画矩形
         */
        drawRect(callback, style, opt_this, option) { this.draw(CZMAP.GeometryType.RECTANGLE, callback, style, opt_this, option); }
        /**
         * 画多边形
         */
        drawPolygon(callback, style, opt_this, option) { this.draw(CZMAP.GeometryType.POLYGON, callback, style, opt_this, option); }
        /**
         * 开始绘制
         * @param option
         */
        startDraw(option) {
            var _a;
            this._finishDraw(false);
            this._drawType = option.type;
            this._drawGroup = option.group;
            this._drawStyle = option.style;
            this._darwing = option.drawing;
            this._canceled = option.canceled;
            this._finished = option.finished;
            this._maxPoints = (_a = option.maxPoints) !== null && _a !== void 0 ? _a : getGeometryPoints(option.type);
            this._autoAdd = CZMAP.defaultValue(option.autoAdd, true);
            this._showDrawing = CZMAP.defaultValue(option.showDrawing, true);
            this._points.length = 0;
            this._downPointer = undefined;
            this._pickPointer = undefined;
            this._eventBind.enable = true;
        }
        /**
         * 停止绘制
         */
        stopDraw() {
            this._finishDraw(false);
        }
        async _pick(x, y) {
            return;
        }
        /** 绑定事件 */
        _bindEvents(dom) {
            this.view.dom;
            this._eventBind.setTarget(dom);
            this._eventBind.enable = false;
            this._eventBind.on('pointerdown', e => this._pointer_down(e));
            this._eventBind.on('pointerup', e => this._pointer_up(e));
            this._eventBind.on('pointermove', e => this._pointer_move(e));
            this._eventBind.on('pointercancel', e => this._pointer_cancel(e));
        }
        _pointer_down(e) {
            if (!e.isPrimary)
                return;
            this._downPointer = e;
        }
        async _pointer_up(e) {
            if (!e.isPrimary)
                return;
            const d = this._downPointer;
            if (!CZMAP.isSamePoint(d, e, 2))
                return;
            /// 
            if (this._points.length === this._maxPoints || e.button === 2) {
                this._finishDraw(true);
                return;
            }
            await this._updatePick(e);
            const l = this._points.last();
            this._points.push([l.x, l.y, l.z]);
            /// 
            if (this._points.length > this._maxPoints) {
                this._finishDraw(true);
                return;
            }
        }
        _pointer_move(e) {
            if (!e.isPrimary)
                return;
            ///
            if (this._points.length === 0)
                return;
            ///
            this._updatePick(e);
        }
        _pointer_cancel(e) {
            this._finishDraw(false);
        }
        async _updatePick(e) {
            if (this._pickPointer && CZMAP.isSamePoint(e, this._pickPointer, 1))
                return;
            const resp = await this._pick(e.offsetX, e.offsetY);
            if (resp) {
                const p = resp;
                if (this._points.length === 0) {
                    this._points.push([p.x, p.y, p.z]);
                }
                else {
                    const d = this._points.last();
                    d[0] = p[0];
                    d[1] = p[1];
                    d[2] = p[2];
                }
                this._pickPointer = e;
                if (this._showDrawing)
                    this._updateDrawing(this._drawType, this._points);
                if (this._darwing) {
                    const geo = this._buildGeometry();
                    CZMAP.tryCatchCall(this._darwing, geo);
                }
            }
        }
        _buildGeometry() {
            const pts = this._points;
            if (pts.length === 0)
                return;
            switch (this._drawType) {
                case CZMAP.GeometryType.POINT: return new CZMAP.GeoPoint(pts[0]);
                case CZMAP.GeometryType.CIRCLE: return new CZMAP.GeoCircle(pts[0], CZMAP.MeasureUtils.computeDistance(pts[0], pts[1]).flatDistance);
                case CZMAP.GeometryType.RECTANGLE: return new CZMAP.GeoRectangle(pts[0], pts[1]);
                case CZMAP.GeometryType.POLYLINE: return new CZMAP.GeoPolyline(pts);
                case CZMAP.GeometryType.POLYGON: return new CZMAP.GeoPolygon([closePolyline(pts)]);
            }
        }
        _finishDraw(complete) {
            this._eventBind.enable = false;
            this._clearDrawing();
            if (complete) {
                const geo = this._buildGeometry();
                if (this._autoAdd)
                    this.add(geo, this._drawStyle, this._drawGroup);
                CZMAP.tryCatchCall(this._finished, geo);
            }
            else {
                CZMAP.tryCatchCall(this._canceled);
            }
        }
    }
    CZMAP.DrawTool = DrawTool;
    function closePolyline(pts) {
        pts = pts.slice();
        pts.push(pts[0]);
        return pts;
    }
    function getGeometryPoints(type) {
        switch (type) {
            case CZMAP.GeometryType.POINT: return 1;
            case CZMAP.GeometryType.CIRCLE:
            case CZMAP.GeometryType.RECTANGLE: return 2;
            default: return Number.MAX_VALUE;
        }
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 编辑小部件
     */
    class EditorWidget extends CZMAP.BaseTool {
        constructor(view) {
            super(view);
        }
        /** 销毁对象 */
        destroy() { }
    }
    CZMAP.EditorWidget = EditorWidget;
    /** 移动编辑部件 */
    class TranslateEditorWidget extends EditorWidget {
        constructor(view, option) {
            super(view);
            this._onTranslate = option.ontranslate;
        }
    }
    CZMAP.TranslateEditorWidget = TranslateEditorWidget;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class GridTool extends CZMAP.BaseTool {
        constructor(view) {
            super(view);
            this._rid = 0;
            this._grids = new Map();
        }
        create(option) {
            ///
            const name = option.name || `AutoNamedGrid-${this._rid++}`;
            //
            this.remove(name);
            ///
            const coordGrid = this._createCoordGrid(option);
            this._grids.set(name, coordGrid);
            ///
            return name;
        }
        remove(name) {
            const grid = this._grids.get(name);
            if (!grid)
                return;
            grid.close();
            this._grids.delete(name);
        }
        clear() {
            this._grids.forEach(val => {
                val.close();
            });
            this._grids.clear();
        }
    }
    CZMAP.GridTool = GridTool;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 信息窗口 */
    class InfoWindow extends CZMAP.BaseTool {
        constructor(view, option) {
            super(view);
            this._noDefaultFrame = false;
            this._pixelDirty = false;
            this._visible = true;
            this._hiddenOnMove = false;
            this._position = option.position;
            this._positioning = CZMAP.defaultValue(option.positioning, 'bottom-center');
            this._offset = [CZMAP.defaultValue(option.offsetX, 0), CZMAP.defaultValue(option.offsetY, 0)];
            this._noDefaultFrame = CZMAP.defaultValue(option.noDefaultFrame, false);
            this._createDom(CZMAP.defaultValue(option.domID, CZMAP.randomString({ prefix: 'Random-' })));
            this._onClosing = option.onClosing;
            this._onClosed = option.onClosed;
            this._showDOM(false);
            ///
            this.content = option.content;
        }
        /** 位置 */
        get position() { return this._position; }
        set position(value) { this._position = value; this._onPositionChange(); }
        /** 定位 */
        get positioning() { return this._positioning; }
        set positioning(value) {
            this._positioning = value;
            this._updateArrow();
            this._pixelX = -1;
        }
        /** 偏移 */
        get offset() { return this._offset; }
        set offset(value) { this._offset = value.slice(); this._pixelX = -1; }
        /** 内容 */
        get content() { return this._content; }
        set content(value) {
            this._content = value;
            if (value instanceof Element)
                this._contentDom.append(value);
            else
                this._contentDom.innerHTML = value;
            this._pixelX = -1;
        }
        /** 是否显示 */
        get visible() { return this._visible; }
        set visible(value) {
            this._visible = value;
            ///
            this._showDOM(value);
            ///
            if (this._pixelDirty) {
                requestAnimationFrame(() => this._updatePositionInner());
            }
        }
        /** 关闭 */
        close() {
            if (!this._dom)
                return true;
            ///
            if (this._onClosing && !CZMAP.tryCatchCall(this._onClosing, this))
                return false;
            ///
            this._dom.remove();
            this._dom = undefined;
            this._overlayDom = undefined;
            ///
            CZMAP.tryCatchCall(this._onClosed, this);
            ///
            return true;
        }
        _showDOM(show) {
            if (this._overlayDom) {
                this._overlayDom.style.opacity = show ? '1' : '0';
                this._overlayDom.style.pointerEvents = show ? 'auto' : 'none';
            }
        }
        _onPositionChange() {
        }
        _createDom(domID) {
            const div = document.createElement('div');
            div.id = domID;
            if (this._noDefaultFrame) {
                const infoDiv = `<!--html-->
                    <div id="${domID}Content" class="leaflet-popup" style="top:0;left:0;transition:opacity 0.2s ease-in-out;"></div>
                    <!--!html-->`;
                div.innerHTML = infoDiv;
                this._overlayDom = div.querySelector('div.leaflet-popup');
                this._arrowDom = undefined;
                this._contentDom = this._overlayDom;
            }
            else {
                const infoDiv = `<!--html-->
                    <div id="${domID}Content" class="leaflet-popup" style="top:0;left:0;transition:opacity 0.2s ease-in-out;">
                        <a class="leaflet-popup-close-button" href="#">×</a>
                        <div class="leaflet-popup-content-wrapper">
                            <div id="${domID}Link" class="leaflet-popup-content" style="max-width: 300px;"></div>
                        </div>
                        <div class="leaflet-popup-tip-container"><div class="leaflet-popup-tip"></div></div>
                    </div>
                    <!--!html-->`;
                div.innerHTML = infoDiv;
                this._overlayDom = div.querySelector('div.leaflet-popup');
                this._arrowDom = div.querySelector('div.leaflet-popup-tip-container');
                /// 填充内容
                this._contentDom = div.querySelector('div.leaflet-popup-content');
                /// 关闭按钮
                const button = div.querySelector('a.leaflet-popup-close-button');
                button.addEventListener('click', () => this.close());
                //
                this._updateArrow();
            }
            this.map.overlayRoot.append(div);
            this._dom = div;
        }
        _updateArrow() {
            if (this._arrowDom) {
                if (this._positioning == 'bottom-center')
                    this._arrowDom.style.display = 'block';
                else
                    this._arrowDom.style.display = 'none';
            }
        }
        _updatePosition(x, y) {
            if (x == this._pixelX && y == this._pixelY)
                return;
            this._pixelX = x;
            this._pixelY = y;
            if (!this._visible) {
                this._pixelDirty = true;
                return;
            }
            if (this._hiddenOnMove) {
                this._showDOM(false);
                clearTimeout(this._delayMoveHandle);
                this._delayMoveHandle = setTimeout(() => {
                    this._updatePositionInner();
                    if (this._visible)
                        this._showDOM(true);
                }, InfoWindow.moveDelay);
            }
            else {
                this._showDOM(true);
                this._updatePositionInner();
            }
        }
        _updatePositionInner() {
            let x = this._pixelX;
            let y = this._pixelY;
            const [ox, oy] = this._offset;
            const [py, px] = this._positioning.split('-');
            const width = this._overlayDom.offsetWidth;
            const height = this._overlayDom.offsetHeight;
            switch (px) {
                case 'left':
                    x += ox;
                    break;
                case 'center':
                    x -= width / 2 + ox;
                    break;
                case 'right':
                    x -= width + ox;
                    break;
            }
            switch (py) {
                case 'top':
                    y += oy;
                    break;
                case 'center':
                    y -= height / 2 + oy;
                    break;
                case 'bottom':
                    y -= height + oy;
                    break;
            }
            this._overlayDom.style.transform = `translate(${x}px, ${y}px)`;
            this._pixelDirty = false;
        }
    }
    InfoWindow.moveDelay = 500;
    CZMAP.InfoWindow = InfoWindow;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 测量回调参数
     */
    class MeasureCallbackParam {
        constructor(points, center, value) {
            this._points = points;
            this._center = center;
            this._value = value;
        }
        /** 测量的点位 */
        get points() { return this._points; }
        /** 中心点 */
        get center() { return this._center; }
        /** 测量结果 */
        get value() { return this._value; }
    }
    CZMAP.MeasureCallbackParam = MeasureCallbackParam;
    /** 距离测量回调 */
    class DistanceCallbackParam extends MeasureCallbackParam {
        /** 构造函数 */
        constructor(points, center, dr) {
            super(points, center, dr.distance);
            /** 水平距离 */
            this._flatDistance = 0;
            /** 最小高程 */
            this._minHeight = Number.MAX_VALUE;
            /** 最大高程 */
            this._maxHeight = -Number.MAX_VALUE;
            /** 垂直距离（高度） */
            this._height = 0;
            this._flatDistance = dr.flatDistance;
            this._minHeight = dr.minHeight;
            this._maxHeight = dr.maxHeight;
            this._height = dr.height;
        }
        /** @override */
        get type() { return 'distance'; }
        /** 测量距离 */
        get distance() { return this.value; }
        /** 水平距离 */
        get flatDistance() { return this._flatDistance; }
        /** 垂直距离（高度） */
        get height() { return this._height; }
        /** 最小高程 */
        get minHeight() { return this._minHeight; }
        /** 最大高程 */
        get maxHeight() { return this._maxHeight; }
    }
    CZMAP.DistanceCallbackParam = DistanceCallbackParam;
    /** 面积测量回调 */
    class AreaCallbackParam extends MeasureCallbackParam {
        constructor(points, center, ar) {
            super(points, center, ar.area);
        }
        /** @override */
        get type() { return 'area'; }
        /** 面积 */
        get area() { return this.value; }
    }
    CZMAP.AreaCallbackParam = AreaCallbackParam;
    /** 角度测量回调 */
    class AngleCallbackParam extends MeasureCallbackParam {
        constructor(p0, p1, center, heading, pitch) {
            super([p0, p1], center, heading);
            this._heading = heading;
            this._pitch = pitch;
        }
        get type() {
            return 'angle';
        }
        /** 方位角 */
        get heading() { return this._heading; }
        /** 俯仰角 */
        get pitch() { return this._pitch; }
    }
    CZMAP.AngleCallbackParam = AngleCallbackParam;
    /** 测量工具分组 */
    CZMAP.MeasureToolGroup = 'measure';
    /**
     * 测量工具
     */
    class MeasureTool extends CZMAP.BaseTool {
        /**
         */
        constructor(view) {
            super(view);
        }
        /**
         * 测量距离
         * @override
         */
        distance(option) {
            option = option !== null && option !== void 0 ? option : {};
            this.view.drawTool.startDraw({
                type: CZMAP.GeometryType.POLYLINE,
                maxPoints: option.multi ? undefined : 2,
                group: CZMAP.MeasureToolGroup,
                drawing: geo => this._onDistDrawing(geo.coordinates, option),
                finished: geo => {
                    const pts = geo.coordinates;
                    const dr = CZMAP.MeasureUtils.computeDistances(pts);
                    const center = CZMAP.MeasureUtils.computeCenter(pts);
                    const dcp = new DistanceCallbackParam(pts, center, dr);
                    this._onDistFinished(dcp, option);
                    CZMAP.tryCatchCallByThis(this, option.callback, dcp);
                }
            });
        }
        /**
         * 测量面积
         */
        arae(option) {
            option = option !== null && option !== void 0 ? option : {};
            this.view.drawTool.startDraw({
                type: CZMAP.GeometryType.POLYGON,
                group: CZMAP.MeasureToolGroup,
                drawing: geo => this._onAreaDrawing(geo.coordinates[0], option),
                finished: geo => {
                    const pts = geo.coordinates[0];
                    const center = CZMAP.MeasureUtils.computeCenter(pts);
                    const area = CZMAP.MeasureUtils.computeArea(pts);
                    const acp = new AreaCallbackParam(pts, center, area);
                    this._onAreaFinished(acp, option);
                    CZMAP.tryCatchCallByThis(this, option.callback, acp);
                }
            });
        }
        /** 测量角度 */
        angle(option) {
            option = option !== null && option !== void 0 ? option : {};
            this.view.drawTool.startDraw({
                type: CZMAP.GeometryType.POLYLINE,
                maxPoints: 2,
                group: CZMAP.MeasureToolGroup,
                drawing: geo => this._onAngleDrawing(geo.coordinates, option),
                finished: geo => {
                    const pts = geo.coordinates;
                    const ar = CZMAP.MeasureUtils.computeAngle(pts[0], pts[1]);
                    const center = CZMAP.MeasureUtils.computeCenter(pts);
                    const acp = new AngleCallbackParam(pts[0], pts[1], center, ar.heading, ar.pitch);
                    this._onAngleFinished(acp, option);
                    CZMAP.tryCatchCallByThis(this, option.callback, acp);
                }
            });
        }
        /** 停止测量 */
        stop() {
            this._onCancel();
            this.view.drawTool.stopDraw();
        }
        static formatDistanceText(dist, flat, height) {
            const fmt = CZMAP.MeasureUtils.formatDistances;
            return `距离：${fmt(dist)}\n水平距离：${fmt(flat)}\n垂直距离：${fmt(height)}`;
        }
        static formatAreaText(area) {
            let tip = "";
            if (area >= 10000) {
                tip = "总面积:" + (area / 1000000).toFixed(2) + "平方公里";
            }
            else {
                tip = "总面积:" + area.toFixed(2) + "平方米";
            }
            return tip;
        }
        static formatAngleText(heading, pitch) {
            return `方位角：${heading.toFixed(1)}，高度角：${pitch.toFixed(1)}`;
        }
    }
    CZMAP.MeasureTool = MeasureTool;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 路径漫游事件
     * @events
     */
    let PathRoamEvents;
    (function (PathRoamEvents) {
        PathRoamEvents["START"] = "start";
        PathRoamEvents["STOP"] = "stop";
        PathRoamEvents["MOVE"] = "move";
        PathRoamEvents["FORWARD"] = "forward";
        PathRoamEvents["BACKWARD"] = "backward";
        PathRoamEvents["CURRENT_TIME"] = "currentTime";
        PathRoamEvents["SPEED"] = "speed";
        PathRoamEvents["LOOP"] = "loop";
        PathRoamEvents["FOLLOW"] = "follow";
        PathRoamEvents["LOCK_VIEW"] = "lockview";
        PathRoamEvents["FIRST_VIEW"] = "firstview";
        PathRoamEvents["TRACK_TRAGET"] = "trackTarget";
        PathRoamEvents["SHOW_LINE"] = "showLine";
        PathRoamEvents["LINE_WIDTH"] = "lineWidth";
        PathRoamEvents["LINE_COLOR"] = "lineColor";
        PathRoamEvents["ENTER_HOT_POINT"] = "enter_hotpoint";
        PathRoamEvents["LEAVE_HOT_POINT"] = "leave_hotpoint";
    })(PathRoamEvents = CZMAP.PathRoamEvents || (CZMAP.PathRoamEvents = {}));
    ;
    let PathRoamLoopType;
    (function (PathRoamLoopType) {
        /** 不循环 */
        PathRoamLoopType[PathRoamLoopType["NONE"] = 0] = "NONE";
        /** 原路返回 */
        PathRoamLoopType[PathRoamLoopType["RETURN"] = 1] = "RETURN";
        /** 回到起点 */
        PathRoamLoopType[PathRoamLoopType["RETURN_TO_START"] = 2] = "RETURN_TO_START";
    })(PathRoamLoopType = CZMAP.PathRoamLoopType || (CZMAP.PathRoamLoopType = {}));
    /**
     * 路径点类
     */
    class PathNode {
        /** 构造一个路径点位 */
        constructor(data) {
            var _a;
            /** 当前点到上一个点的距离 */
            this.distance = 0;
            /** 当前到七点的距离 */
            this.distanceTotal = 0;
            if (Array.isArray(data)) {
                this.position = data.slice();
            }
            else {
                this.position = CZMAP.defaultValues(data.position, data.cameraPoint).slice();
                this.target = (_a = CZMAP.defaultValues(data.target, data.targetPoint)) === null || _a === void 0 ? void 0 : _a.slice();
                this.speed = data.speed;
                this.time = data.time;
            }
            this.position3D = Cesium.Cartesian3.fromDegrees(...this.position);
        }
    }
    CZMAP.PathNode = PathNode;
    /** 热点对象 */
    class HotPoint {
        constructor(data) {
            this.data = data;
            this.position = Cesium.Cartesian3.fromDegrees(...data.position);
        }
    }
    /**
     * 路径漫游对象
     */
    class PathRoam extends CZMAP.BaseTool {
        /**
         * 构造函数，构造漫游对象
         * @param view
         */
        // eslint-disable-next-line no-unused-vars
        constructor(view) {
            super(view);
            /**  */
            this._play = false;
            /** 视角锁定 */
            this._lock = false;
            /** 相机跟随 */
            this._follow = true;
            /** 第一人称 */
            this._first = false;
            /** 追踪 */
            this._trackTarget = false;
            /** 模型始终向前 */
            this._modelForward = false;
            /** 方向 */
            this._dir = 1;
            /** 速度 */
            this._speed = 1;
            /** 循环模式 */
            this._loop = PathRoamLoopType.NONE;
            /** 显示线条 */
            this._showLine = false;
            /** 线宽 */
            this._lineWidth = 1;
            /** 线颜色 */
            this._lineColor = 'white';
            this._hotPoints = [];
            /** 热点持续时间 */
            this._hotDuration = 2;
            /** 路径的开始时刻（秒） */
            this._begin_seconds = 0;
            /** 路径的接受时刻（秒） */
            this._end_seconds = 0;
            /** 路径时长（秒） */
            this._total_seconds = 0;
            /** 路径漫游的当前时刻（秒） */
            this._current_seconds = 0;
            /** 当前位置 */
            this._current_position = [0, 0, 0];
            this.on('move', () => this._on_pathroam_move());
        }
        /**
         * 创建漫游路径
         * @param path 漫游路径
         * @param options 漫游参数
         */
        open(path, options) {
            /// 
            options = options || {};
            ///
            this.close();
            ///
            this._nodes = this.buildRoamPath(path, options.speed);
            /// 
            this._eye_offset = options.offset;
            ///
            this._begin_seconds = Infinity;
            this._end_seconds = -Infinity;
            this._nodes.forEach(n => {
                this._begin_seconds = Math.min(this._begin_seconds, n.time);
                this._end_seconds = Math.max(this._end_seconds, n.time);
            });
            ///
            this._total_seconds = this._end_seconds - this._begin_seconds;
            ///
            this._play = false;
            this._dir = 1;
            this._speed = 1;
            this._current_seconds = 0;
            this._init(options);
            if (options.hotPoints)
                this.addHotPoints(options.hotPoints);
            if (CZMAP.defined(options.hotDuration))
                this._hotDuration = options.hotDuration;
        }
        /**
         * 关闭路径漫游
         */
        close() {
            this._release();
        }
        addHotPoint(hpd) {
            const hp = new HotPoint(hpd);
            const pts = this._nodes.map(n => n.position3D);
            const fnl = CZMAP.findNearestLine(pts, hp.position);
            const n0 = this._nodes[fnl.i0];
            const n1 = this._nodes[fnl.i1];
            const dist = Cesium.Cartesian3.distance(n0.position3D, hp.position);
            hp.time = n0.time + (n1.time - n0.time) * (dist / n1.distance);
            this._hotPoints.push(hp);
        }
        /**
         * 添加热点，当漫游至热点附近时将会触发热点'hotpoint'事件
         *
         * @example
         * var path = view.createPathRoam();
         * path.addHotPoints(...);
         * path.on('hotpot', (hp) => ...);
         *
         * @param pts 热点列表
         */
        addHotPoints(pts) {
            pts.forEach(hd => this.addHotPoint(hd));
        }
        /**
         * 移除所有热点
         */
        clearHotPoints() {
            this._hotPoints.length = 0;
        }
        calcHotRadius() {
        }
        /**
         * 开始漫游
         */
        start() { this._play = true; this.dispatchEvent(PathRoamEvents.START); }
        /**
         * 暂停漫游
         */
        pause() { this._play = false; this.dispatchEvent(PathRoamEvents.STOP); }
        /**
         * 恢复漫游
         */
        resume() { this._play = true; this.dispatchEvent(PathRoamEvents.START); }
        /**
         * 前进
         */
        forward() { this._dir = 1; this.dispatchEvent(PathRoamEvents.FORWARD); }
        /**
         * 后退
         */
        backward() { this._dir = -1; this.dispatchEvent(PathRoamEvents.BACKWARD); }
        /** 漫游时的偏移 */
        get offset() { return undefined; }
        set offset(v) { }
        /**是否正在漫游 */
        get playing() { return this._play; }
        /** 漫游速度 */
        set speed(v) { this._speed = v; this.dispatchEvent(PathRoamEvents.SPEED); }
        get speed() { return this._speed; }
        /** 漫游循环方式 */
        set loop(v) { this._loop = v; this.dispatchEvent(PathRoamEvents.LOOP); }
        get loop() { return this._loop; }
        /** 漫游时相机跟随 */
        set follow(v) { this._follow = v; this.dispatchEvent(PathRoamEvents.FOLLOW); }
        get follow() { return this._follow; }
        /** 相机跟随时锁定视图 */
        set lockview(v) { this._lock = v; this.dispatchEvent(PathRoamEvents.LOCK_VIEW); }
        get lockview() { return this._lock; }
        /** 相机跟随时使用第一人称视角 */
        set firstview(v) { this._first = v; this.dispatchEvent(PathRoamEvents.FIRST_VIEW); }
        get firstview() { return this._first; }
        set trackTarget(v) { this._trackTarget = v; this.dispatchEvent(PathRoamEvents.TRACK_TRAGET); }
        get trackTarget() { return this._trackTarget; }
        /** 模型始终向前 */
        set modelForward(v) { this._modelForward = v; }
        get modelForward() { return this._modelForward; }
        /** 显示漫游路径 */
        set showline(v) { this._showLine = v; this.dispatchEvent(PathRoamEvents.SHOW_LINE); }
        get showline() { return this._showLine; }
        /** 漫游路径线宽 */
        set lineWidth(v) { this._lineWidth = v; this.dispatchEvent(PathRoamEvents.LINE_WIDTH); }
        get lineWidth() { return this._lineWidth; }
        /** 漫游路径线颜色 */
        set lineColor(v) { this._lineColor = v; this.dispatchEvent(PathRoamEvents.LINE_COLOR); }
        get lineColor() { return this._lineColor; }
        /** 漫游总时间，秒数 */
        get totalTime() { return this._total_seconds; }
        /** 当前时间，秒数 */
        get currentTime() { return this._current_seconds; }
        set currentTime(v) { this._current_seconds = v; }
        /** 当前位置 */
        get currentPosition() { return this._current_position; }
        /** 当前为路径段 */
        get currentSegment() {
            const c = this._current_seconds;
            const ns = this._nodes;
            for (let i = 0; i < ns.length; ++i) {
                const n = ns[i];
                if (c < n.time)
                    return i - 1;
            }
            ///
            return ns.length;
        }
        /**
         * 释放资源
         */
        _disposeInternal() {
            super._disposeInternal();
            /// 
            this.close();
        }
        /**
         * 解析构建路径数据
         */
        buildRoamPath(data, speed) {
            /// 总时间，使用10s
            const totalTime = 10;
            /// 总距离
            let distanceTotal = 0;
            //
            let calcTime = false;
            let calcSpeed = false;
            // 上一个点
            let last;
            const nodes = [];
            data.forEach(pt => {
                const n = this._createPathNode(pt);
                if (CZMAP.defined(last)) {
                    /// 跳过时间相同的点
                    if (CZMAP.defined(n.time) && n.time === last.time)
                        return;
                    //
                    n.distance = this._calcDistance(n, last);
                    n.distanceTotal = distanceTotal += n.distance;
                }
                /// 是否需要计算时间
                if (!CZMAP.Types.isNumber(n.time))
                    calcTime = true;
                /// 是否需要计算速度
                if (!CZMAP.Types.isNumber(n.speed))
                    calcSpeed = true;
                ///
                nodes.push(n);
                last = n;
            });
            /// 自动计算速度，平均速度
            let avespeed = 0;
            if (calcSpeed) {
                if (CZMAP.Types.isDefined(speed))
                    avespeed = speed;
                else
                    avespeed = distanceTotal / (totalTime);
            }
            /// 自动计算每个节点的时间
            if (calcTime) {
                let timePassed = 0;
                nodes[0].time = 0;
                const nnum = nodes.length;
                for (let i = 1; i < nnum; ++i) {
                    const n = nodes[i];
                    if (calcSpeed)
                        n.time = timePassed + (n.distance / avespeed);
                    else
                        n.time = timePassed + (n.distance / n.speed);
                    ///
                    timePassed = n.time;
                }
            }
            return nodes;
        }
        _on_pathroam_move() {
            const current = this._current_seconds;
            let nearest = this._hotPoints.find(hp => {
                const time = CZMAP.defaultValue(hp.data.duration, this._hotDuration) / 2;
                if (Math.abs(current - hp.time) < time) {
                    return true;
                }
            });
            if (this._currentHotPoint && this._currentHotPoint !== nearest) {
                this.dispatchEvent(PathRoamEvents.LEAVE_HOT_POINT, this._currentHotPoint.data);
            }
            if (nearest && nearest !== this._currentHotPoint) {
                this.dispatchEvent(PathRoamEvents.ENTER_HOT_POINT, nearest.data);
            }
            this._currentHotPoint = nearest;
        }
    }
    CZMAP.PathRoam = PathRoam;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let TunnelProperty;
    (function (TunnelProperty) {
        TunnelProperty["VISIBLE"] = "visible";
        TunnelProperty["ANIMATION"] = "animation";
        TunnelProperty["SPEED"] = "speed";
    })(TunnelProperty = CZMAP.TunnelProperty || (CZMAP.TunnelProperty = {}));
    /**
     * 巷道方向
     */
    let TunnelDir;
    (function (TunnelDir) {
        /**
         * 无方向
         */
        TunnelDir[TunnelDir["NONE"] = 0] = "NONE";
        /**
         * 向前
         */
        TunnelDir[TunnelDir["FORWARD"] = 1] = "FORWARD";
        /**
         * 向后
         */
        TunnelDir[TunnelDir["BACKWARD"] = 2] = "BACKWARD";
    })(TunnelDir = CZMAP.TunnelDir || (CZMAP.TunnelDir = {}));
    class TunnelEffct extends CZMAP.BaseTool {
        /**
         */
        constructor(view) {
            super(view);
            /// 
            this.set(TunnelProperty.VISIBLE, true);
            this.set(TunnelProperty.ANIMATION, false);
            this.set(TunnelProperty.SPEED, 1);
            /// 
            this.on(CZMAP.BaseObject.getChangeEventType(TunnelProperty.VISIBLE), this._onVisibleChanged);
            this.on(CZMAP.BaseObject.getChangeEventType(TunnelProperty.ANIMATION), this._onAnimationChanged);
        }
        /**
         * 设置是否可见
         * @type {Boolean}
         */
        set visible(v) {
            this.set(TunnelProperty.VISIBLE, v);
        }
        get visible() { return this.get(TunnelProperty.VISIBLE); }
        /**
         * 设置是否运行动画
         * @type {Boolean}
         */
        set animation(v) { this.set(TunnelProperty.ANIMATION, v); }
        get animation() { return this.get(TunnelProperty.ANIMATION); }
        /**
         * 动画速度
         */
        set speed(v) { this.set(TunnelProperty.SPEED, v); }
        get speed() { return this.get(TunnelProperty.SPEED); }
        /**
         * @abstract
         * @protected
         */
        _onVisibleChanged() { }
        /**
         * @abstract
         * @protected
         */
        _onAnimationChanged() { }
        /**
         * @private
         */
        _disposeInternal() {
            super._disposeInternal();
            this.close();
        }
    }
    CZMAP.TunnelEffct = TunnelEffct;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 巷道模型（双层模型）透视（透明）处理类
     */
    class TunnelTransparent extends CZMAP.BaseTool {
        constructor(view) {
            super(view);
            this.set('enable', false);
            this.on(CZMAP.BaseTool.getChangeEventType('enable'), this._handleEnable);
        }
        /**
         * 初始化
         * @param {*} options
         */
        init(options) { CZMAP.abstract(options); }
        /**
         * 判断是否存在数据
         * @param options
         */
        checkExist(options) { }
        /**
         * 关闭
         */
        close() { }
        /**
         * 是否启用透明
         */
        set enable(v) { this.set('enable', v); }
        get enable() { return this.get('enable'); }
        ///
        _disposeInternal() {
            super._disposeInternal();
            this.close();
        }
    }
    CZMAP.TunnelTransparent = TunnelTransparent;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 平面切割
     * @internal
     */
    class AxisClipPlane3D extends CZMAP.AxisClipPlane {
        constructor(view, box) {
            super(view, box);
            this._dim = new Cesium.Cartesian2();
            /// 
            this.on(CZMAP.BaseObjectEvents.PROPERTYCHANGE, this._onPropertyChange, this);
            ///
            this._plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_Z, 0);
            this._updateAxis(CZMAP.Axis.AXIS_Z);
            ///
            const ct = Cesium.Cartesian3.fromDegrees(...this.center);
            this._entity = new Cesium.Entity({
                position: ct,
                plane: {
                    plane: new Cesium.CallbackProperty(() => this._plane, false),
                    dimensions: new Cesium.CallbackProperty(() => this._dim, false),
                    material: Cesium.Color.WHITE.withAlpha(0.1),
                    outline: true,
                    outlineColor: Cesium.Color.WHITE
                }
            });
            this._planeGraphics = this._entity.plane;
            view.czviewer.entities.add(this._entity);
        }
        _onPropertyChange(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            switch (event.key) {
                case CZMAP.AxisClipPlaneProperty.AXIS:
                    this._updateAxis(CZMAP.Axis.parser(value));
                    break;
                case CZMAP.AxisClipPlaneProperty.DISTANCE:
                    this._plane.distance = this.distance;
                    break;
                case CZMAP.ClipPlaneProperty.COLOR:
                    this._planeGraphics.material = CZMAP.CesiumAttrib.getColor(value);
                    break;
                case CZMAP.ClipPlaneProperty.BORDER_COLOR:
                    this._planeGraphics.outlineColor = CZMAP.CesiumAttrib.getColor(value);
                    break;
                case CZMAP.ClipPlaneProperty.BORDER_WIDTH:
                    this._planeGraphics.outlineWidth = value;
                    break;
            }
        }
        _updateAxis(axis) {
            const dm = this._dim;
            const sz = this.gsize;
            const nor = this._plane.normal;
            Cesium.Cartesian3.ZERO.clone(nor);
            switch (axis) {
                case CZMAP.Axis.AXIS_X:
                    dm.x = sz[1];
                    dm.y = sz[2];
                    nor.x = -1;
                    break;
                case CZMAP.Axis.AXIS_Y:
                    dm.x = sz[0];
                    dm.y = sz[2];
                    nor.y = -1;
                    break;
                case CZMAP.Axis.AXIS_Z:
                    dm.x = sz[0];
                    dm.y = sz[1];
                    nor.z = -1;
                    break;
            }
        }
        _disposeInternal() {
            this.map.view3d.czviewer.entities.remove(this._entity);
            this._entity = null;
            this.un(CZMAP.BaseObjectEvents.PROPERTYCHANGE, this._onPropertyChange, this);
            super._disposeInternal();
        }
    }
    CZMAP.AxisClipPlane3D = AxisClipPlane3D;
    /**
     * 路径切割
     * @internal
     */
    class PathClipPlane3D extends CZMAP.PathClipPlanes {
        constructor(view, box) {
            super(view, box);
            /// 
            this.on(CZMAP.BaseObjectEvents.PROPERTYCHANGE, this._onPropertyChange, this);
            ///
            this._entity = new Cesium.Entity({
                wall: {
                    positions: [],
                    minimumHeights: [],
                    maximumHeights: [],
                    material: Cesium.Color.WHITE.withAlpha(0.1),
                    outline: true,
                    outlineColor: Cesium.Color.WHITE
                },
            });
            this._wallGraphics = this._entity.wall;
            view.czviewer.entities.add(this._entity);
        }
        _onPropertyChange(event) {
            const value = event.target.get(event.key);
            if (!CZMAP.Types.isDefined(value))
                return;
            switch (event.key) {
                case CZMAP.ClipPlaneProperty.COLOR:
                    this._wallGraphics.material = CZMAP.CesiumAttrib.getColor(value);
                    break;
                case CZMAP.ClipPlaneProperty.BORDER_COLOR:
                    this._wallGraphics.outlineColor = CZMAP.CesiumAttrib.getColor(value);
                    break;
                case CZMAP.ClipPlaneProperty.BORDER_WIDTH:
                    this._wallGraphics.outlineWidth = value;
                    break;
            }
        }
        _updateWall() {
            const pts = this._path.map(pt => Cesium.Cartesian3.fromDegrees(...pt));
            const min = this._path.map(pt => this.box.minz);
            const max = this._path.map(pt => this.box.maxz);
            this._wallGraphics.positions = pts;
            this._wallGraphics.minimumHeights = min;
            this._wallGraphics.maximumHeights = max;
        }
        /** @override */
        _onPathChanged() {
            this._updateWall();
        }
        _disposeInternal() {
            this.map.view3d.czviewer.entities.remove(this._entity);
            this._entity = null;
            this.un(CZMAP.BaseObjectEvents.PROPERTYCHANGE, this._onPropertyChange, this);
            super._disposeInternal();
        }
    }
    CZMAP.PathClipPlane3D = PathClipPlane3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class CoordGrid3D extends CZMAP.CoordGrid {
        constructor(view) {
            super(view);
            this._visible = true;
            this._entities = [];
        }
        build(option) {
            this.close();
            const cgb = new CZMAP.CoordGridBuild();
            cgb.build(option);
            option = cgb.option;
            const entities = this._entities;
            cgb.lines.forEach(line => entities.push(this._addPloyline(line.positions, option)));
            cgb.points.forEach(pt => entities.push(this._addSinglePointWithText(pt.position, pt.text, pt.pixelOffset, option)));
        }
        close() {
            this._entities.forEach(e => this.view.czviewer.entities.remove(e));
            this._entities.length = 0;
        }
        getVisible() {
            return this._visible;
        }
        setVisible(value) {
            this._visible = value;
            this._entities.forEach(e => e.show = value);
        }
        _addPloyline(pos, option) {
            return this.view.czviewer.entities.add({
                polyline: {
                    positions: pos,
                    material: Cesium.Color.fromCssColorString(option.lineColor),
                    width: option.lineWidth,
                    clampToGround: false
                }
            });
        }
        /**
         * 添加单点和文字
         * @param pos Cartesian3
         * @param text 文本信息
         * @return Entity
         */
        _addSinglePointWithText(pos, text, offset, option) {
            return this.view.czviewer.entities.add({
                position: pos,
                point: {
                    pixelSize: option.pointSize,
                    color: Cesium.Color.fromCssColorString(option.pointColor)
                },
                label: {
                    text: text,
                    font: CZMAP.defaultValue(option.textFont, '16px sans-serif'),
                    pixelOffset: new Cesium.Cartesian2(offset[0], offset[1]),
                    fillColor: Cesium.Color.fromCssColorString(option.textColor)
                }
            });
        }
    }
    CZMAP.CoordGrid3D = CoordGrid3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const DEFAULT_FILL_COLOR = 'yellow';
    const DEFAULT_LINE_COLOR = 'rgb(128,128,0)';
    const DefualtStyle = {
        fillColor: DEFAULT_FILL_COLOR,
        lineColor: DEFAULT_LINE_COLOR,
        lineWidth: 3
    };
    const DefualtDrawingStyle = {
        fillColor: 'rgba(255,255,0,0.5)',
        lineColor: DEFAULT_LINE_COLOR,
        lineWidth: 3
    };
    /** @internal */
    class DrawTool3D extends CZMAP.DrawTool {
        /**
         *
         */
        constructor(view) {
            super(view);
            this._czsource = new Cesium.CustomDataSource("MapView3D-DrawTools");
            this._czsource.clustering.enabled = false;
            this._entities = this._czsource.entities;
            view.czviewer.dataSources.add(this._czsource);
            this._bindEvents(this.view.czscene.canvas);
        }
        /**
         * 添加几何
         * @param {*} geo
         * @param {*} style
         */
        add(geo, style, group) {
            switch (geo.type) {
                case CZMAP.GeometryType.POINT: return this.addPoint(geo, style, group);
                case CZMAP.GeometryType.POLYLINE: return this.addPolyline(geo, style, group);
                case CZMAP.GeometryType.POLYGON: return this.addPolygon(geo, style, group);
                case CZMAP.GeometryType.CIRCLE: return this.addCircle(geo, style, group);
                case CZMAP.GeometryType.RECTANGLE: return this.addRect(geo, style, group);
                default: throw `no type '${geo.type}'`;
            }
        }
        /**
         *
         */
        addPoint(geo, style, group) {
            style = style || DefualtStyle;
            const id = 'point-' + this._getNextID();
            this._entities.add(createPoint(id, Cesium.Cartesian3.fromDegrees(geo.x, geo.y, geo.z), style));
            this._setGroup(id, group);
            return id;
        }
        /**
         *
         */
        addPolyline(geo, style, group) {
            style = style || DefualtStyle;
            const id = 'polyline-' + this._getNextID();
            const pts = geo.coordinates.map(pt => Cesium.Cartesian3.fromDegrees(...pt));
            this._entities.add(createPolyline(id, pts, style));
            this._setGroup(id, group);
            return id;
        }
        /**
         *
         */
        addPolygon(geo, style, group) {
            style = style || DefualtStyle;
            const id = 'polygon-' + this._getNextID();
            this._addPolygon(id, geo.coordinates[0], style);
            this._setGroup(id, group);
            return id;
        }
        /**
         *
         */
        addRect(geo, style, group) {
            style = style || DefualtStyle;
            const id = 'rect-' + this._getNextID();
            const coords = rect2Polygon(geo);
            this._addPolygon(id, coords, style);
            this._setGroup(id, group);
            return id;
        }
        addCircle(geo, style, group) {
            style = style || DefualtStyle;
            const id = 'rect-' + this._getNextID();
            const pts = geo;
            const dsemiMajorAxis = pts.radius; //Cesium.Math.toRadians(pts.radius) * Cesium.Ellipsoid.WGS84.maximumRadius;
            const center = Cesium.Cartesian3.fromDegrees(...geo.center);
            this._entities.add(createCircle(id, center, dsemiMajorAxis, style));
            this._setGroup(id, group);
            return id;
        }
        addDynamicCircle(geo, dynStyle, group) {
            const id = 'dyn-circle-' + this._getNextID();
            this._entities.add({
                id, name: "扩散圆",
                position: Cesium.Cartesian3.fromDegrees(...geo.center),
                ellipse: {
                    semiMinorAxis: geo.radius,
                    semiMajorAxis: geo.radius,
                    material: new CZMAP.DynamicCircleMaterialProperty(dynStyle)
                }
            });
            this._setGroup(id, group);
            return id;
        }
        _addPolygon(id, points, style) {
            const hierarchy = new Cesium.PolygonHierarchy(points.map(pt => Cesium.Cartesian3.fromDegrees(...pt)));
            return this._entities.add(createPolygon(id, hierarchy, style));
        }
        /**
         * 移除
         */
        remove(id) {
            this._entities.removeById(id);
            this._delGroup(id);
        }
        async _pick(x, y) {
            const scene = this.view.czscene;
            let cartesian;
            const screen = new Cesium.Cartesian2(x, y);
            if (0) {
                const pickedObject = scene.pick(screen);
                if (CZMAP.defined(pickedObject)) {
                    cartesian = scene.pickPosition(screen, cartesian);
                    //强制返回高程大于0的数据，处理拾取不准
                    const geoc = Cesium.Cartographic.fromCartesian(cartesian);
                    if (geoc.height < 0) {
                        cartesian = scene.camera.pickEllipsoid(screen);
                    }
                }
                else {
                    cartesian = scene.camera.pickEllipsoid(screen);
                }
            }
            else {
                cartesian = pickGlobe(this.view.czviewer, screen);
            }
            if (cartesian) {
                const ca = Cesium.Cartographic.fromCartesian(cartesian);
                return [
                    Cesium.Math.toDegrees(ca.longitude),
                    Cesium.Math.toDegrees(ca.latitude),
                    ca.height
                ];
            }
        }
        _updateDrawing(type, pts) {
            if (!this._drawingEntity) {
                let entity;
                if (type === CZMAP.GeometryType.POINT) {
                    entity = createPoint('', Cesium.Cartesian3.fromDegrees(...pts[0]), DefualtDrawingStyle);
                }
                else if (type === CZMAP.GeometryType.POLYLINE) {
                    entity = createCallbackPolyline(pts);
                }
                else if (type === CZMAP.GeometryType.POLYGON) {
                    entity = createCallbackPolygon(pts);
                }
                else if (type === CZMAP.GeometryType.CIRCLE && pts.length == 2) {
                    entity = createCallbackCircle(pts);
                }
                else if (type === CZMAP.GeometryType.RECTANGLE && pts.length == 2) {
                    entity = createCallbackRect(pts);
                }
                if (entity)
                    this._drawingEntity = this._entities.add(entity);
            }
        }
        _clearDrawing() {
            if (this._drawingEntity) {
                this._entities.remove(this._drawingEntity);
                this._drawingEntity = undefined;
            }
        }
    }
    CZMAP.DrawTool3D = DrawTool3D;
    function asCartesian3Array(pts, result, closed = false) {
        let pre;
        let index = 0;
        pts.forEach(p => {
            const pos = Cesium.Cartesian3.fromDegrees(...p, undefined, result[index]);
            if (!CZMAP.GeoMath.isEquals(pre, p)) {
                result[index] = (pos);
                pre = p;
                index++;
            }
        });
        if (closed) {
            result[index] = Cesium.Cartesian3.clone(result[0], result[index]);
            index++;
        }
        result.length = index;
        return result;
    }
    function createPoint(id, position, style) {
        return new Cesium.Entity({
            id,
            position,
            point: {
                color: CZMAP.CesiumAttrib.getColor(style.fillColor, DEFAULT_FILL_COLOR),
                outlineColor: CZMAP.CesiumAttrib.getColor(style.lineColor, DEFAULT_LINE_COLOR),
                outlineWidth: CZMAP.CesiumAttrib.getNumber(style.lineWidth),
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
                pixelSize: 8
            }
        });
    }
    function createPolyline(id, positions, style) {
        return new Cesium.Entity({
            id,
            polyline: {
                positions,
                clampToGround: false,
                width: style.lineWidth ? style.lineWidth : 5,
                material: CZMAP.CesiumAttrib.getColor(style.fillColor, DEFAULT_FILL_COLOR),
                depthFailMaterial: CZMAP.CesiumAttrib.getColor(style.fillColor, DEFAULT_FILL_COLOR)
            }
        });
    }
    function createPolygon(id, hierarchy, style) {
        return new Cesium.Entity({
            id: id,
            polygon: {
                hierarchy,
                //perPositionHeight :true,
                material: CZMAP.CesiumAttrib.getColor(style.fillColor, DEFAULT_FILL_COLOR),
                outline: style.lineWidth > 0,
                outlineColor: CZMAP.CesiumAttrib.getColor(style.lineColor, DEFAULT_LINE_COLOR),
                outlineWidth: style.lineWidth,
            }
        });
    }
    function createCircle(id, center, radius, style) {
        return new Cesium.Entity({
            id, position: center,
            ellipse: {
                semiMajorAxis: radius,
                semiMinorAxis: radius,
                material: CZMAP.CesiumAttrib.getColor(style.fillColor, DEFAULT_FILL_COLOR),
                outline: style.lineWidth > 0,
                outlineColor: CZMAP.CesiumAttrib.getColor(style.lineColor, DEFAULT_LINE_COLOR),
                outlineWidth: style.lineWidth,
            }
        });
    }
    /** 创建的动态绘制线 */
    function createCallbackPolyline(pts) {
        const positions = new Cesium.CallbackProperty((time, result) => asCartesian3Array(pts, result), false);
        return createPolyline('', positions, DefualtDrawingStyle);
    }
    /** 创建动态绘制多边形 */
    function createCallbackPolygon(pts) {
        const hierarchy = new Cesium.PolygonHierarchy();
        const prop = new Cesium.CallbackProperty((time, result) => {
            asCartesian3Array(pts, hierarchy.positions, true);
            return hierarchy;
        }, false);
        return createPolygon('', prop, DefualtDrawingStyle);
    }
    /** 创建动态绘制圆 */
    function createCallbackCircle(pts) {
        const radius = createCallbackRadius(pts);
        const center = Cesium.Cartesian3.fromDegrees(...pts[0]);
        return createCircle('', center, radius, DefualtDrawingStyle);
    }
    /** 创建动态绘制矩形 */
    function createCallbackRect(pts) {
        const [p0, p1] = pts;
        const hierarchy = new Cesium.PolygonHierarchy();
        const prop = new Cesium.CallbackProperty((time, result) => {
            const coords = [
                [p0[0], p0[1], 0],
                [p1[0], p0[1], 0],
                [p1[0], p1[1], 0],
                [p0[0], p1[1], 0],
                [p0[0], p0[1], 0]
            ];
            asCartesian3Array(coords, hierarchy.positions, true);
            return hierarchy;
        }, false);
        return createPolygon('', prop, DefualtDrawingStyle);
    }
    const tempP0 = new Cesium.Cartesian3();
    const tempP1 = new Cesium.Cartesian3();
    function createCallbackRadius(pts) {
        return new Cesium.CallbackProperty(() => {
            Cesium.Cartesian3.fromDegrees(...pts[0], undefined, tempP0);
            Cesium.Cartesian3.fromDegrees(...pts[1], undefined, tempP1);
            return Cesium.Cartesian3.distance(tempP0, tempP1);
        }, false);
    }
    function rect2Polygon(geo) {
        const p0 = geo.min;
        const p1 = geo.max;
        const coords = [
            [p0[0], p0[1], 0],
            [p1[0], p0[1], 0],
            [p1[0], p1[1], 0],
            [p0[0], p1[1], 0],
            [p0[0], p0[1], 0]
        ];
        return coords;
    }
    const scratch_PickGlobe_Ray = new Cesium.Ray();
    const scratch_PickGlobe_DepthIntersection = new Cesium.Cartesian3();
    const scratch_PickGlobe_RayIntersection = new Cesium.Cartesian3();
    /**
     * 拾取函数 自动判断使用场景拾取还是椭球拾取
     * @param viewer 视图对象
     * @param mousePosition 鼠标坐标
     * @param result 拾取结果坐标
     * @returns 拾取结果坐标
     */
    function pickGlobe(viewer, mousePosition, result) {
        const scene = viewer.scene;
        const globe = viewer.scene.globe;
        const camera = scene.camera;
        ///
        if (!Cesium.defined(globe))
            return undefined;
        /// 
        let depthPick, rayPick;
        /// 拾取场景
        if (scene.pickPositionSupported) {
            depthPick = scene.pickPosition(mousePosition, scratch_PickGlobe_DepthIntersection);
        }
        /// 拾取地球
        let ray = camera.getPickRay(mousePosition, scratch_PickGlobe_Ray);
        rayPick = globe.pick(ray, scene, scratch_PickGlobe_RayIntersection);
        /// 排序
        let pickDistance = Cesium.defined(depthPick) ? Cesium.Cartesian3.distance(depthPick, camera.positionWC) : Number.POSITIVE_INFINITY;
        let rayDistance = Cesium.defined(rayPick) ? Cesium.Cartesian3.distance(rayPick, camera.positionWC) : Number.POSITIVE_INFINITY;
        if (pickDistance < rayDistance) {
            return Cesium.Cartesian3.clone(depthPick, result);
        }
        return Cesium.Cartesian3.clone(rayPick, result);
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 默认圆分段数 */
    const CircleSlice = 16;
    /** 默认定点格式 */
    const VertexFormat = Cesium.VertexFormat.DEFAULT;
    /** 三个坐标轴的旋转矩阵 */
    const AxisMatrixX = new Cesium.Matrix3(0, 0, 1, 0, -1, 0, 1, 0, 0);
    const AxisMatrixY = new Cesium.Matrix3(1, 0, 0, 0, 0, 1, 0, -1, 0);
    const AxisMatrixZ = new Cesium.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    /** 坐标轴 */
    let AxisType;
    (function (AxisType) {
        AxisType[AxisType["Axis_X"] = 0] = "Axis_X";
        AxisType[AxisType["Axis_Y"] = 1] = "Axis_Y";
        AxisType[AxisType["Axis_Z"] = 2] = "Axis_Z";
    })(AxisType || (AxisType = {}));
    /** 坐标轴掩码 */
    let AxisMask;
    (function (AxisMask) {
        AxisMask[AxisMask["Mask_None"] = 0] = "Mask_None";
        AxisMask[AxisMask["Mask_X"] = 1] = "Mask_X";
        AxisMask[AxisMask["Mask_Y"] = 2] = "Mask_Y";
        AxisMask[AxisMask["Mask_Z"] = 4] = "Mask_Z";
        AxisMask[AxisMask["Mask_XY"] = 3] = "Mask_XY";
        AxisMask[AxisMask["Mask_YZ"] = 6] = "Mask_YZ";
        AxisMask[AxisMask["Mask_ZX"] = 5] = "Mask_ZX";
    })(AxisMask || (AxisMask = {}));
    /** 每个坐标轴矩阵列表 */
    const AxisMatrixs = [AxisMatrixX, AxisMatrixY, AxisMatrixZ];
    /** 每个坐标轴对应的掩码 */
    const AxisTypeMash = [AxisMask.Mask_X, AxisMask.Mask_Y, AxisMask.Mask_Z];
    /** 每个坐标轴对应的平面 */
    const AxisTypePlane = [Cesium.Plane.ORIGIN_YZ_PLANE, Cesium.Plane.ORIGIN_ZX_PLANE, Cesium.Plane.ORIGIN_XY_PLANE];
    /** 默认颜色 */
    const AxisColorX = Cesium.Color.RED;
    const AxisColorY = Cesium.Color.GREEN;
    const AxisColorZ = Cesium.Color.BLUE;
    const AxisColorP = Cesium.Color.WHITE;
    const AxisColorS = Cesium.Color.YELLOW;
    /**
     * 创建圆柱或者圆锥
     * @param length 长度
     * @param r0 顶部半径
     * @param r1 底部半径
     * @returns 圆柱几何体
     */
    function createSylinder(length, r0, r1) {
        r1 = CZMAP.defaultValue(r1, r0);
        return Cesium.CylinderGeometry.createGeometry(new Cesium.CylinderGeometry({
            length, topRadius: r0, bottomRadius: r1, slices: CircleSlice, vertexFormat: VertexFormat
        }));
    }
    /**
     * 创建几何实例
     * @param id 对象ID
     * @param geometry 几何体
     * @param center 模型中心
     * @param rotation 旋转矩阵
     * @returns 几何实例
     */
    function createInstance(id, geometry, center, rotation) {
        const translation = Cesium.Cartesian3.fromElements(...center);
        const modelMatrix = Cesium.Matrix4.fromRotationTranslation(rotation, translation);
        return new Cesium.GeometryInstance({
            geometry, id, modelMatrix,
        });
    }
    /** 箭头柄长度 */
    const BaseLength = 25;
    /** 箭头柄半径 */
    const BaseRadius = 1;
    /** 箭头长度 */
    const ArrowLength = BaseLength * 0.4;
    /** 箭头半径 */
    const ArrowRadius = BaseRadius * 2.5;
    /** 小柄长度 */
    const SubLength = BaseLength * 0.3;
    /** 小柄半径 */
    const SubRadius = BaseRadius * 0.5;
    /** 小球半径 */
    const PointRadius = BaseRadius * 1.5;
    const BaseCenter = BaseLength / 2;
    const ArrowCenter = BaseLength + ArrowLength / 2;
    const SubCenter = SubLength / 2;
    let AxisHandle;
    let AxisArrow;
    let AxisSubHandle;
    let AxisPoint;
    /** 初始化几何体 */
    function initAxisGeometry() {
        if (!AxisHandle) {
            AxisHandle = createSylinder(BaseLength, BaseRadius);
            AxisArrow = createSylinder(ArrowLength, 0, ArrowRadius);
            AxisSubHandle = createSylinder(SubLength, SubRadius);
            AxisPoint = Cesium.SphereGeometry.createGeometry(new Cesium.SphereGeometry({
                radius: PointRadius, slicePartitions: CircleSlice, stackPartitions: CircleSlice, vertexFormat: VertexFormat
            }));
        }
    }
    function buildCenter(axis, values) {
        const result = [0, 0, 0];
        for (let i = 0; i < 3; ++i) {
            result[axis[i]] = values[i];
        }
        return result;
    }
    /**
     * 创建坐标轴
     * @param name 名称
     * @param a0 主轴
     * @param a1 副轴1
     * @param a2 副轴2
     * @returns 坐标轴几何体实例
     */
    function createAxis(name, a0, a1, a2) {
        const handleCenter = buildCenter([a0, a1, a2], [BaseCenter, 0, 0]);
        const arrowCenter = buildCenter([a0, a1, a2], [ArrowCenter, 0, 0]);
        const sub0Center = buildCenter([a0, a1, a2], [SubLength, SubCenter, 0]);
        const sub1Center = buildCenter([a0, a1, a2], [SubLength, 0, SubCenter]);
        const handle = createInstance('AxixHandle-' + name, AxisHandle, handleCenter, AxisMatrixs[a0]);
        const arrow = createInstance('AxisArrow-' + name, AxisArrow, arrowCenter, AxisMatrixs[a0]);
        const sub0 = createInstance('AxisSubHandle-0-' + name, AxisSubHandle, sub0Center, AxisMatrixs[a1]);
        const sub1 = createInstance('AxisSubHandle-1-' + name, AxisSubHandle, sub1Center, AxisMatrixs[a2]);
        return [handle, arrow, sub0, sub1];
    }
    /**
     * 创建Primitive
     * @param items 几何体实例
     * @param color 颜色
     * @returns
     */
    function createPrimitive(items, color) {
        const base = new Cesium.Primitive({
            geometryInstances: items,
            appearance: new Cesium.MaterialAppearance({
                translucent: false,
                closed: true,
                material: new Cesium.Material({
                    fabric: {
                        type: "Color",
                        uniforms: {
                            color
                        },
                    },
                }),
                renderState: {
                    depthTest: {
                        enabled: true,
                        func: Cesium.DepthFunction.LESS
                    }
                }
            }),
            // 禁用异步加载
            asynchronous: false,
            // 禁用拾取
            allowPicking: false,
        });
        const depthFail = new Cesium.Primitive({
            geometryInstances: items,
            appearance: new Cesium.MaterialAppearance({
                translucent: false,
                closed: true,
                material: new Cesium.Material({
                    fabric: {
                        type: "Color",
                        uniforms: {
                            color: color.darken(0.5, new Cesium.Color())
                        },
                    },
                }),
                renderState: {
                    depthTest: {
                        enabled: true,
                        func: Cesium.DepthFunction.GREATER_OR_EQUAL
                    }
                }
            }),
            // 禁用异步加载
            asynchronous: false,
            // 禁用拾取
            allowPicking: false,
        });
        return { depthFail, base };
    }
    /**
     * 对射线进行矩阵变换
     * @param matrix 矩阵
     * @param ray 射线
     * @param result 结果
     */
    function transformRay(matrix, ray, result) {
        Cesium.Matrix4.multiplyByPoint(matrix, ray.origin, result.origin);
        Cesium.Matrix4.multiplyByPointAsVector(matrix, ray.direction, result.direction);
    }
    const uv = new Cesium.Cartesian3();
    const uuv = new Cesium.Cartesian3();
    const qvec = new Cesium.Cartesian3();
    function rotateVectorByQuaternion(q, v, result) {
        qvec.x = q.x;
        qvec.y = q.y;
        qvec.z = q.z;
        Cesium.Cartesian3.cross(qvec, v, uv);
        Cesium.Cartesian3.cross(qvec, uv, uuv);
        Cesium.Cartesian3.multiplyByScalar(uv, q.w * 2.0, uv);
        Cesium.Cartesian3.multiplyByScalar(uuv, 2.0, uuv);
        Cesium.Cartesian3.add(v, uv, result);
        Cesium.Cartesian3.add(result, uuv, result);
        return result;
    }
    /**
     * 计算射线和平面的交点
     * @param ray 射线
     * @param plane 平面
     * @param result 交点
     * @returns 距离交点的距离或者undefined
     */
    function rayPlaneDistance(ray, plane, result) {
        var origin = ray.origin;
        var direction = ray.direction;
        var normal = plane.normal;
        var denominator = Cesium.Cartesian3.dot(normal, direction);
        if (Math.abs(denominator) < Cesium.Math.EPSILON15) {
            // Ray is parallel to plane.  The ray may be in the polygon's plane.
            return undefined;
        }
        var t = (-plane.distance - Cesium.Cartesian3.dot(normal, origin)) / denominator;
        if (t < 0) {
            return undefined;
        }
        //
        if (!result)
            result = new Cesium.Cartesian3();
        result = Cesium.Cartesian3.multiplyByScalar(direction, t, result);
        Cesium.Cartesian3.add(origin, result, result);
        return t;
    }
    /** 拾取结果 */
    class PickResult {
        constructor() {
            /** 拾取的坐标轴 */
            this.axis = AxisMask.Mask_None;
            /** 距离 */
            this.distance = 0;
            /** 拾取的交点，本地坐标 */
            this.position = new Cesium.Cartesian3();
        }
    }
    class MouseEventProxy {
        constructor() {
            this.isShift = false;
            this.isCtrl = false;
            this.isAlt = false;
        }
        set(data) {
            this.isShift = false;
            this.isCtrl = false;
            this.isAlt = false;
            this.data = data;
            this.pixel = data.position || data.endPosition;
            return this;
        }
        setShift(data) {
            this.set(data);
            this.isShift = true;
            return this;
        }
        setCtrl(data) {
            this.set(data);
            this.isCtrl = true;
            return this;
        }
        setAlt(data) {
            this.set(data);
            this.isAlt = true;
            return this;
        }
    }
    const PickNone = Object.freeze(new PickResult());
    /**
     * 平移编辑部件
     * @internal
     */
    class TranslateEditorWidget3D extends CZMAP.TranslateEditorWidget {
        /**
         * 构造平移部件
         * @param view 视图对象
         * @param option
         */
        constructor(view, option) {
            super(view, option);
            this._primitives = [];
            /** 坐标轴的实际位置 */
            this._realPosition = [0, 0, 0];
            /** 修正高程值 */
            this._enableRectifyHeight = true;
            /** 启用旋转 */
            this._enableRotation = true;
            /** 坐标轴显示缩放比例 */
            this._axisScale = 1;
            /** 笛卡尔坐标位置 */
            this._axisPosition = new Cesium.Cartesian3();
            /** 变换矩阵 */
            this._axisMatrix = new Cesium.Matrix4();
            /** 变化逆矩阵 */
            this._axisMatrixInv = new Cesium.Matrix4();
            /** 坐标轴矩阵，增加缩放 */
            this._axisMatrixScaled = new Cesium.Matrix4();
            /** 相机位置 */
            this._cameraPosition = new Cesium.Cartesian3();
            /** 用于计算像素大小的虚拟包围盒 */
            this._fakeBoundSphere = new Cesium.BoundingSphere(undefined, 0);
            /** 拾取射线 */
            this._pickRay = new Cesium.Ray();
            /** 是否拖拽中 */
            this._isDragging = false;
            /** 拖拽矩阵 */
            this._dragMatrix = new Cesium.Matrix4();
            /** 拖拽逆矩阵 */
            this._dragMatrixInv = new Cesium.Matrix4();
            /** 拖拽用地理坐标 */
            this._dragBegin = new Cesium.Cartographic();
            /** 拖拽用地理坐标 */
            this._dragCartographic = new Cesium.Cartographic();
            /** 拾取结果 */
            this._pickResult = PickNone;
            this._PickResultXY = new PickResult();
            this._PickResultYZ = new PickResult();
            this._PickResultZX = new PickResult();
            this._draggingTarget = new Cesium.Cartesian3();
            this._draggingTargetLocal = new Cesium.Cartesian3();
            this._hpr = new Cesium.HeadingPitchRoll();
            this._orientation = new Cesium.Quaternion();
            this._orientationLocal = new Cesium.Quaternion();
            this._position = CZMAP.GeoMath.clone(option.position);
            this._pose = option.pose ? CZMAP.GeoMath.clone(option.pose) : [0, 0, 0];
            this._offset = option.offset ? CZMAP.GeoMath.clone(option.offset) : [0, 0, 0];
            this._createAxis();
            this._bindEvents();
        }
        /** 显示/隐藏 */
        get visible() { return this._model.show; }
        set visible(v) { this._model.show = v; }
        /** 位置 */
        get position() { return CZMAP.GeoMath.clone(this._position); }
        set position(p) {
            CZMAP.GeoMath.clone(p, this._position);
            this._updatePosition();
        }
        get pose() { return CZMAP.GeoMath.clone(this._pose); }
        set pose(v) {
            CZMAP.GeoMath.clone(v, this._pose);
            this._updatePose();
        }
        get offset() { return CZMAP.GeoMath.clone(this._offset); }
        set offset(o) { CZMAP.GeoMath.clone(o, this._offset); this._updatePosition(); }
        get enableRectifyHeight() { return this._enableRectifyHeight; }
        set enableRectifyHeight(e) { this._enableRectifyHeight = e; }
        get enableRotation() { return this._enableRotation; }
        set enableRotation(e) { this._enableRotation = e; this._udpateMatrix(); }
        /** 销毁对象 */
        destroy() {
            this._releaseEvents();
            if (this._model) {
                this.view.czscene.primitives.remove(this._model);
                this._model = undefined;
            }
            super.destroy();
        }
        /** 创建坐标轴对象 */
        _createAxis() {
            /// 杆
            initAxisGeometry();
            const [xh, xa, xy, xz] = createAxis('x', AxisType.Axis_X, AxisType.Axis_Y, AxisType.Axis_Z);
            const [yh, ya, yz, yx] = createAxis('y', AxisType.Axis_Y, AxisType.Axis_Z, AxisType.Axis_X);
            const [zh, za, zx, zy] = createAxis('z', AxisType.Axis_Z, AxisType.Axis_X, AxisType.Axis_Y);
            const p = new Cesium.GeometryInstance({ geometry: AxisPoint, id: 'p' });
            this._model = new Cesium.PrimitiveCollection();
            this._axisX = createPrimitive([xh, xa], AxisColorX);
            this._axisY = createPrimitive([yh, ya], AxisColorY);
            this._axisZ = createPrimitive([zh, za], AxisColorZ);
            this._axisXY = createPrimitive(xy, AxisColorX);
            this._axisXZ = createPrimitive(xz, AxisColorX);
            this._axisYX = createPrimitive(yx, AxisColorY);
            this._axisYZ = createPrimitive(yz, AxisColorY);
            this._axisZX = createPrimitive(zx, AxisColorZ);
            this._axisZY = createPrimitive(zy, AxisColorZ);
            this._point = createPrimitive(p, AxisColorP);
            this._primitives = [
                this._axisX, this._axisY, this._axisZ,
                this._axisXY, this._axisYZ, this._axisZX,
                this._axisYX, this._axisZY, this._axisXZ,
                this._point
            ];
            this._primitives.forEach(p => {
                this._model.add(p.depthFail);
                this._model.add(p.base);
            });
            this._updatePosition(false);
            this._updatePose(false);
            this._udpateMatrix();
            this.view.czscene.primitives.add(this._model);
        }
        _bindEvent(listener, type) {
            if (!this._handler)
                return;
            const event = new MouseEventProxy();
            this._handler.setInputAction(e => listener(event.set(e)), type);
            this._handler.setInputAction(e => listener(event.setShift(e)), type, Cesium.KeyboardEventModifier.SHIFT);
            this._handler.setInputAction(e => listener(event.setAlt(e)), type, Cesium.KeyboardEventModifier.ALT);
            this._handler.setInputAction(e => listener(event.setCtrl(e)), type, Cesium.KeyboardEventModifier.CTRL);
        }
        /** 绑定鼠标事件和渲染事件 */
        _bindEvents() {
            this._handler = new Cesium.ScreenSpaceEventHandler(this.view.czviewer.scene.canvas);
            this._bindEvent(e => this._onMouseMoved(e), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this._bindEvent(e => this._onMouseDown(e), Cesium.ScreenSpaceEventType.LEFT_DOWN);
            this._bindEvent(e => this._onMouseUp(e), Cesium.ScreenSpaceEventType.LEFT_UP);
            this.view.czscene.preUpdate.addEventListener(this._preUpdate, this);
        }
        /** 释放事件绑定 */
        _releaseEvents() {
            if (this._handler) {
                this._handler.destroy();
                this._handler = undefined;
            }
            this.view.czscene.preUpdate.removeEventListener(this._preUpdate, this);
        }
        /** 启用/禁用交互 */
        _enableInputs(enable) {
            this.view.czscene.screenSpaceCameraController.enableInputs = enable;
        }
        /** 鼠标按下事件处理函数，处理开始拖拽动作 */
        _onMouseDown(e) {
            if (this._pickResult.axis !== AxisMask.Mask_None) {
                this._isDragging = true;
                Cesium.Cartographic.fromCartesian(this._axisPosition, undefined, this._dragBegin);
                Cesium.Matrix4.clone(this._axisMatrix, this._dragMatrix);
                Cesium.Matrix4.inverseTransformation(this._dragMatrix, this._dragMatrixInv);
                this._enableInputs(false);
            }
        }
        /** 鼠标弹起事件处理函数 */
        _onMouseUp(e) {
            this._isDragging = false;
            this._enableInputs(true);
        }
        /** 坐标移动事件处理函数 */
        _onMouseMoved(e) {
            const ray = this.view.czscene.camera.getPickRay(e.pixel, this._pickRay);
            if (!this._isDragging) {
                transformRay(this._axisMatrixInv, ray, ray);
                this._pickResult = this._getPicked(ray);
                this._udpateAxisColor(this._pickResult.axis);
            }
            else {
                transformRay(this._dragMatrixInv, ray, ray);
                const target = this._draggingTarget;
                const { axis, position, plane } = this._pickResult;
                const distnace = rayPlaneDistance(ray, plane, target);
                if (distnace === undefined)
                    return;
                /// 计算拖拽偏移量
                Cesium.Cartesian3.subtract(target, position, target);
                /// 根据拖拽坐标轴，禁用对应坐标轴修改
                if ((axis & AxisMask.Mask_X) === 0)
                    target.x = 0;
                if ((axis & AxisMask.Mask_Y) === 0)
                    target.y = 0;
                if ((axis & AxisMask.Mask_Z) === 0)
                    target.z = 0;
                // 保存
                const targetLocal = Cesium.Cartesian3.clone(target, this._draggingTargetLocal);
                /// 转世界坐标
                Cesium.Matrix4.multiplyByPoint(this._dragMatrix, target, target);
                const carto = Cesium.Cartographic.fromCartesian(target, undefined, this._dragCartographic);
                /// 应用地理坐标修正
                if (this._enableRectifyHeight) {
                    //计算本地坐标无旋转情况下坐标变化
                    if (this.enableRotation)
                        rotateVectorByQuaternion(this._orientationLocal, targetLocal, targetLocal);
                    //修正高程值
                    carto.height = this._dragBegin.height + targetLocal.z;
                    Cesium.Cartographic.toCartesian(carto, undefined, target);
                }
                this._realPosition[0] = Cesium.Math.toDegrees(carto.longitude);
                this._realPosition[1] = Cesium.Math.toDegrees(carto.latitude);
                this._realPosition[2] = carto.height;
                ///
                Cesium.Cartesian3.clone(target, this._axisPosition);
                this._udpateMatrix();
                if (e.isShift) {
                    this._offset = CZMAP.GeoMath.sub(this._realPosition, this._position, this._offset);
                }
                else {
                    ///
                    CZMAP.GeoMath.sub(this._realPosition, this._offset, this._position);
                    CZMAP.tryCatchCall(this._onTranslate, this._position);
                }
            }
        }
        /**
         * 更新坐标轴颜色
         * @param axis 选中的坐标轴
         */
        _udpateAxisColor(axis) {
            function setColor(pri, color) {
                color.darken(0.3, pri.depthFail.appearance.material.uniforms.color);
                pri.base.appearance.material.uniforms.color = color;
            }
            function setColor2(pri, mask, c1, c2) {
                setColor(pri, (axis & mask) === mask ? c1 : c2);
            }
            setColor2(this._axisX, AxisMask.Mask_X, AxisColorS, AxisColorX);
            setColor2(this._axisY, AxisMask.Mask_Y, AxisColorS, AxisColorY);
            setColor2(this._axisZ, AxisMask.Mask_Z, AxisColorS, AxisColorZ);
            setColor2(this._axisXY, AxisMask.Mask_XY, AxisColorS, AxisColorX);
            setColor2(this._axisYX, AxisMask.Mask_XY, AxisColorS, AxisColorY);
            setColor2(this._axisYZ, AxisMask.Mask_YZ, AxisColorS, AxisColorY);
            setColor2(this._axisZY, AxisMask.Mask_YZ, AxisColorS, AxisColorZ);
            setColor2(this._axisZX, AxisMask.Mask_ZX, AxisColorS, AxisColorZ);
            setColor2(this._axisXZ, AxisMask.Mask_ZX, AxisColorS, AxisColorX);
        }
        /**
         * 拾取当前鼠标位置的坐标轴
         * @param ray 鼠标摄像，本地坐标空间
         * @returns
         */
        _getPicked(ray) {
            const scale = this._axisScale;
            /**
             * 根据坐标点判断所选取的坐标轴
             * @param v0 坐标0
             * @param v1 坐标1
             * @param a0 坐标轴0
             * @param a1 坐标轴1
             * @returns
             */
            function selectAxis(v0, v1, a0, a1) {
                const lineWidth = ArrowRadius * scale;
                const lineLength = (BaseLength + ArrowLength) * scale;
                const boxSize = (SubLength + SubRadius) * scale;
                /// 在负轴上，这里忽略
                if (v0 < -lineWidth || v1 < -lineWidth)
                    return AxisMask.Mask_None;
                /// 在坐标轴1
                if (v0 <= lineWidth && v1 <= lineLength)
                    return a1;
                /// 在坐标轴0
                if (v1 <= lineWidth && v0 <= lineLength)
                    return a0;
                /// 同时选中两个坐标轴
                if (v0 <= boxSize && v1 <= boxSize)
                    return a0 | a1;
                return AxisMask.Mask_None;
            }
            /**
             * 计算射线在对应平面上的拾取结果
             * @param ray 射线，本地坐标
             * @param a0 主轴
             * @param a1 副轴1
             * @param a2 副轴2
             * @param result 拾取结果
             * @returns
             */
            function calcCrossOnPlane(ray, a0, a1, a2, result) {
                const plane = AxisTypePlane[a0];
                const distance = rayPlaneDistance(ray, AxisTypePlane[a0], result.position);
                if (!distance)
                    return PickNone;
                const pos = result.position;
                const point = [pos.x, pos.y, pos.z];
                const axis = selectAxis(point[a1], point[a2], AxisTypeMash[a1], AxisTypeMash[a2]);
                ///
                result.axis = axis;
                result.distance = distance;
                result.plane = plane;
                return result;
            }
            /// 分别在每个平面上进行拾取
            const dxy = calcCrossOnPlane(ray, AxisType.Axis_Z, AxisType.Axis_Y, AxisType.Axis_X, this._PickResultXY);
            const dyz = calcCrossOnPlane(ray, AxisType.Axis_X, AxisType.Axis_Y, AxisType.Axis_Z, this._PickResultYZ);
            const dzx = calcCrossOnPlane(ray, AxisType.Axis_Y, AxisType.Axis_Z, AxisType.Axis_X, this._PickResultZX);
            /// 过滤无效结果并按从近到远排序
            const sorted = [dxy, dyz, dzx].filter(d => d.axis !== AxisMask.Mask_None).sort((a, b) => a.distance - b.distance);
            if (sorted.length == 0)
                return PickNone;
            /// 返回最近的一个
            return sorted[0];
        }
        /**
         * 在每一帧计算模型缩放，包正屏幕大小一致
         * @returns
         */
        _preUpdate() {
            const camera = this.view.czscene.camera;
            const cameraPosition = camera.positionWC;
            if (Cesium.Cartesian3.equalsEpsilon(this._cameraPosition, cameraPosition, 0.00000001))
                return;
            this._updateScale();
            this._applyMatrix();
        }
        /** 更新坐标轴缩放比 */
        _updateScale() {
            const camera = this.view.czscene.camera;
            const cameraPosition = camera.positionWC;
            Cesium.Cartesian3.clone(cameraPosition, this._cameraPosition);
            const { clientWidth, clientHeight } = this.view.czviewer.canvas;
            /// 计算像素大小，缩放模型，保持像素大小不变
            const pixelSize = camera.getPixelSize(this._fakeBoundSphere, clientWidth, clientHeight);
            this._axisScale = pixelSize * 4;
        }
        /** 更新位置坐标 */
        _updatePosition(updateMatrix = true) {
            CZMAP.GeoMath.add(this._position, this._offset, this._realPosition);
            Cesium.Cartesian3.fromDegrees(...this._realPosition, undefined, this._axisPosition);
            this._updatePose(false);
            if (updateMatrix)
                this._udpateMatrix();
        }
        _updatePose(updateMatrix = true) {
            const pose = this._pose;
            const hpr = Cesium.HeadingPitchRoll.fromDegrees(pose[0], pose[1], pose[2], this._hpr);
            Cesium.Transforms.headingPitchRollQuaternion(this._axisPosition, hpr, undefined, undefined, this._orientation);
            Cesium.Quaternion.fromHeadingPitchRoll(hpr, this._orientationLocal);
            if (updateMatrix)
                this._udpateMatrix();
        }
        /** 更新坐标（笛卡尔坐标） */
        _udpateMatrix() {
            if (this._enableRotation)
                Cesium.Matrix4.fromTranslationQuaternionRotationScale(this._axisPosition, this._orientation, UNIT_SCALE, this._axisMatrix);
            else
                Cesium.Transforms.eastNorthUpToFixedFrame(this._axisPosition, undefined, this._axisMatrix);
            ///
            Cesium.Matrix4.inverseTransformation(this._axisMatrix, this._axisMatrixInv);
            this._axisPosition.clone(this._fakeBoundSphere.center);
            ///
            this._updateScale();
            this._applyMatrix();
        }
        /** 应用矩阵到模型上 */
        _applyMatrix() {
            const mo = Cesium.Matrix4.multiplyByUniformScale(this._axisMatrix, this._axisScale, this._axisMatrixScaled);
            this._primitives.forEach(p => {
                mo.clone(p.base.modelMatrix);
                mo.clone(p.depthFail.modelMatrix);
            });
        }
    }
    CZMAP.TranslateEditorWidget3D = TranslateEditorWidget3D;
    const UNIT_SCALE = new Cesium.Cartesian3(1, 1, 1);
})(CZMAP || (CZMAP = {}));
/// <reference path="../GridTool.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class GridTool3D extends CZMAP.GridTool {
        /**
         * 构造网格绘制工具
         * @param view
         */
        constructor(view) {
            super(view);
        }
        _createCoordGrid(option) {
            const cg = new CZMAP.CoordGrid3D(this.view);
            cg.build(option);
            return cg;
        }
    }
    CZMAP.GridTool3D = GridTool3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class InfoWindow3D extends CZMAP.InfoWindow {
        constructor(view, option) {
            super(view, option);
            const view3d = this.view;
            this._postRenderHandle = view3d.czscene.postRender.addEventListener(this._onPostRender, this);
        }
        close() {
            if (!super.close())
                return false;
            if (this._postRenderHandle) {
                this._postRenderHandle();
                this._postRenderHandle = undefined;
            }
            return true;
        }
        _onPostRender(scene) {
            try {
                const pos = Cesium.Cartesian3.fromDegrees(...this.position);
                const pixel = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, pos);
                if (pixel)
                    this._updatePosition(pixel.x, pixel.y);
                else
                    this._updatePosition(-10000, -10000);
            }
            catch (e) {
            }
        }
    }
    CZMAP.InfoWindow3D = InfoWindow3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 三维测量工具
     * @internal
     */
    class MeasureTool3D extends CZMAP.MeasureTool {
        /**
         */
        constructor(view) {
            super(view);
            //// 
            this._entities = [];
            this._text = '';
            this._center = new Cesium.Cartesian3();
        }
        distance(option) {
            this._createDrawingLabel(option);
            super.distance(option);
        }
        _onDistDrawing(pts, option) {
            const dr = CZMAP.MeasureUtils.computeDistances(pts);
            const center = CZMAP.MeasureUtils.computeCenter(pts);
            Cesium.Cartesian3.fromDegrees(...center, undefined, this._center);
            this._text = CZMAP.MeasureTool.formatDistanceText(dr.distance, dr.flatDistance, dr.height);
        }
        _onDistFinished(dcp, option) {
            const text = CZMAP.MeasureTool.formatDistanceText(dcp.distance, dcp.flatDistance, dcp.height);
            this._finishDrawingLabel(text, dcp.center);
            if (option.icons) {
                this._createIcon(dcp.points[0], option.icons.start);
                this._createIcon(dcp.points.last(), option.icons.end);
            }
        }
        arae(option) {
            this._createDrawingLabel(option);
            super.arae(option);
        }
        _onAreaDrawing(pts, option) {
            const ar = CZMAP.MeasureUtils.computeArea(pts);
            const center = CZMAP.MeasureUtils.computeCenter(pts);
            Cesium.Cartesian3.fromDegrees(...center, undefined, this._center);
            this._text = CZMAP.MeasureTool.formatAreaText(ar.area);
        }
        _onAreaFinished(acp, option) {
            const text = CZMAP.MeasureTool.formatAreaText(acp.area);
            this._finishDrawingLabel(text, acp.center);
        }
        angle(option) {
            this._createDrawingLabel(option);
            super.angle(option);
        }
        _onAngleDrawing(pts, option) {
            const ar = CZMAP.MeasureUtils.computeAngle(pts[0], pts[1]);
            const center = CZMAP.MeasureUtils.computeCenter(pts);
            Cesium.Cartesian3.fromDegrees(...center, undefined, this._center);
            this._text = CZMAP.MeasureTool.formatAngleText(ar.heading, ar.pitch);
        }
        _onAngleFinished(acp, option) {
            const text = CZMAP.MeasureTool.formatAngleText(acp.heading, acp.pitch);
            this._finishDrawingLabel(text, acp.center);
        }
        _onCancel() {
            this._removeDrawingLabel();
        }
        /**
         * 清除测量
         */
        clear() {
            const ec = this.view.czviewer.entities;
            this._entities.forEach(e => ec.remove(e));
            this._entities.length = 0;
            this.view.drawTool.clear(CZMAP.MeasureToolGroup);
        }
        _calcLabelPosition(pos, option) {
            if (!option.labelOffset)
                return pos;
            const [x, y, z] = pos;
            const [ox, oy, oz] = option.labelOffset;
            return [x + ox, y + oy, z + oz];
        }
        _createDrawingLabel(option) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            ///
            if (option.label === false)
                return;
            this._text = '';
            const labelStyle = {
                text: new Cesium.CallbackProperty(() => this._text, false),
                fillColor: CZMAP.CesiumAttrib.getColor((_a = option.labelStyle) === null || _a === void 0 ? void 0 : _a.fillColor, new Cesium.Color(0, 255, 0)),
                pixelOffset: CZMAP.CesiumAttrib.getCartesian2((_b = option.labelStyle) === null || _b === void 0 ? void 0 : _b.pixelOffset, new Cesium.Cartesian2(0, -20)),
                horizontalOrigin: CZMAP.CesiumAttrib.getHorizontal((_c = option.labelStyle) === null || _c === void 0 ? void 0 : _c.horizontalOrigin, Cesium.HorizontalOrigin.CENTER),
                verticalOrigin: CZMAP.CesiumAttrib.getVertical((_d = option.labelStyle) === null || _d === void 0 ? void 0 : _d.verticalOrigin, Cesium.VerticalOrigin.BOTTOM),
                font: CZMAP.defaultValue((_e = option.labelStyle) === null || _e === void 0 ? void 0 : _e.font, '1.2vw arial'),
                outlineWidth: CZMAP.defaultValue((_f = option.labelStyle) === null || _f === void 0 ? void 0 : _f.outlineWidth, 0),
                outlineColor: CZMAP.CesiumAttrib.getColor((_g = option.labelStyle) === null || _g === void 0 ? void 0 : _g.outlineColor, Cesium.Color.BLACK),
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
                showBackground: (_h = option.labelStyle) === null || _h === void 0 ? void 0 : _h.background,
                backgroundColor: CZMAP.CesiumAttrib.getColor((_j = option.labelStyle) === null || _j === void 0 ? void 0 : _j.backgroundBorderColor)
            };
            if (labelStyle.outlineWidth) {
                labelStyle.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
            }
            //const labelPos = new Cesium.CallbackProperty();// this._calcLabelPosition(pos, option);
            const label = this.view.czviewer.entities.add({
                position: new Cesium.CallbackProperty(() => this._center, false),
                label: labelStyle
            });
            ///
            this._entities.push(label);
            this._currentLabel = label;
        }
        _finishDrawingLabel(text, pos) {
            const entity = this._currentLabel;
            if (entity) {
                entity.label.text = text;
                entity.position = Cesium.Cartesian3.fromDegrees(...pos);
            }
            this._currentLabel = undefined;
        }
        _removeDrawingLabel() {
            const ent = this._currentLabel;
            if (ent) {
                CZMAP.ArrayUtils.removeItem(this._entities, ent);
                this.view.czviewer.entities.remove(ent);
                this._currentLabel = undefined;
            }
        }
        _createIcon(pt, icon) {
            if (!icon)
                return;
            if (!icon.img)
                return;
            const entIcon = this.view.czviewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(...pt),
                billboard: {
                    image: icon.img,
                    pixelOffset: icon.offset ? new Cesium.Cartesian2(...icon.offset) : undefined,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                }
            });
            this._entities.push(entIcon);
        }
    }
    CZMAP.MeasureTool3D = MeasureTool3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 遍历所有Primitive
     * @param {PrimitiveCollection} ps
     * @param {Model|Array<Model>} ms
     * @param {function} cb 回调函数
     */
    function forEachModelPrimitive(ps, ms, cb) {
        ms = Array.isArray(ms) ? ms : [ms];
        for (let i = 0; i < ps.length; ++i) {
            let p = ps.get(i);
            if (p instanceof Cesium.PrimitiveCollection) {
                forEachModelPrimitive(p, ms, cb);
            }
            else {
                if (ms.indexOf(p.id) != -1)
                    cb(p);
            }
        }
    }
    CZMAP.forEachModelPrimitive = forEachModelPrimitive;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const TEMP_MATRIX4 = new Cesium.Matrix4();
    const TEMP_HPR = new Cesium.HeadingPitchRoll();
    const UNIT_SCALE = Cesium.Cartesian3.fromElements(1, 1, 1);
    /** @internal */
    class PathRoam3D extends CZMAP.PathRoam {
        /**
         */
        constructor(view) {
            super(view);
            /** 上一帧时间 */
            this._last_time = 0;
            /// 
            this._temp_pos = new Cesium.Cartesian3();
            this._temp_dir = new Cesium.Cartesian3();
            this._temp_tar = new Cesium.Cartesian3();
            this._temp_vec = new Cesium.Cartesian3();
            this._temp_mat = new Cesium.Matrix3();
            this._temp_ori = new Cesium.Quaternion();
            this._temp_ori2 = new Cesium.Quaternion();
            this._temp_pos_c = new Cesium.Cartographic();
            this._temp_tar_c = new Cesium.Cartographic();
            this._temp_offset = new Cesium.Cartesian3();
            this._temp_matrix3 = new Cesium.Matrix3();
            this._temp_matrix4 = new Cesium.Matrix4();
            this._temp_inv_matrix4 = new Cesium.Matrix4();
            /**
             * 当前路径的包围球
             */
            this._sphere = new Cesium.BoundingSphere();
            this._line = undefined;
            this._isFirstFollow = true;
            this._lastFollowOffset = new Cesium.Cartesian3();
            this._lastMode = 0;
            /**
             */
            this.view3d = view;
        }
        /**
         * 创建漫游路径
         */
        _init(options) {
            ///
            this.buildSampled();
            /// 
            this.createModel(options);
            this.createLine();
            ///
            this._play = false;
            this._dir = 1;
            this._speed = 1;
            this._last_time = 0;
            this._current_seconds = this._begin_seconds;
            this._isFirstFollow = true;
            /// 
            this.view3d.czviewer.scene.postRender.addEventListener(this._tick, this);
            ///
            if (options.jumpToPath !== false)
                this.view3d.czviewer.camera.viewBoundingSphere(this._sphere);
        }
        /**
         * 关闭路径漫游
         */
        _release() {
            this.view3d.czviewer.scene.postRender.removeEventListener(this._tick, this);
            this.view3d.cegore.camera.clearLookAt();
            /// 删除漫游实体
            if (this._entity)
                this.view3d.czviewer.entities.remove(this._entity);
            /// 删除漫游线
            this.view3d.czviewer.entities.remove(this._line);
            /// 恢复相机
            this._czcamera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        }
        /** 当前时间 */
        set currentTime(v) {
            this._current_seconds = v;
            this._update();
        }
        get currentTime() {
            return super.currentTime;
        }
        /**
         *
         * @param {*} scene
         * @param {*} nowTime
         */
        _tick() {
            const now = new Date();
            const now_time = now.getTime();
            if (this._last_time == 0) {
                this._last_time = now_time;
                return;
            }
            /// 计算经过的时间
            const seconds = (now_time - this._last_time) / 1000;
            this._last_time = now_time;
            ///
            if (!this._play)
                return;
            // 计算当前漫游时刻
            this._current_seconds += (seconds * this._speed * this._dir);
            const bgsecond = this._dir > 0 ? this._begin_seconds : this._end_seconds;
            const edsecond = this._dir > 0 ? this._end_seconds : this._begin_seconds;
            /// 到达起点 或者 到达终点
            let pause = false;
            if (this._current_seconds < this._begin_seconds || this._current_seconds >= this._end_seconds) {
                this._current_seconds = edsecond;
                if (this._loop !== CZMAP.PathRoamLoopType.NONE) {
                    pause = false;
                    /// 原路返回
                    if (this._loop === CZMAP.PathRoamLoopType.RETURN)
                        this._dir = -this._dir;
                    /// 回到起点
                    else if (this._loop === CZMAP.PathRoamLoopType.RETURN_TO_START)
                        this._current_seconds = bgsecond;
                }
                else {
                    pause = true;
                }
            }
            ///
            this._update();
            ///
            if (pause)
                this.pause();
        }
        _update() {
            const time = new Cesium.JulianDate(0, this._current_seconds);
            /// 计算位置
            const interp_pos = this._sample_pos.getValue(time, this._temp_pos);
            /// 计算目标
            const interp_dir = this._sample_dir.getValue(time, this._temp_dir);
            /// 计算方向
            const interp_vec = this._sample_ori.getValue(time, this._temp_vec);
            /// 
            const c_pos = Cesium.Cartographic.fromCartesian(interp_pos, undefined, this._temp_pos_c);
            const current = this._current_position;
            current[0] = Cesium.Math.toDegrees(c_pos.longitude);
            current[1] = Cesium.Math.toDegrees(c_pos.latitude);
            current[2] = c_pos.height;
            let RoamMode;
            (function (RoamMode) {
                RoamMode[RoamMode["FIRST_PERSON"] = 0] = "FIRST_PERSON";
                RoamMode[RoamMode["THIRD_LOCK"] = 1] = "THIRD_LOCK";
                RoamMode[RoamMode["THIRD_FREE"] = 2] = "THIRD_FREE";
                RoamMode[RoamMode["PATH_TRACK"] = 3] = "PATH_TRACK";
            })(RoamMode || (RoamMode = {}));
            /// 
            const lastMode = this._lastMode;
            this._lastMode = this._follow ? (this._first ? RoamMode.FIRST_PERSON : (this._lock ? RoamMode.THIRD_LOCK : RoamMode.THIRD_FREE)) : RoamMode.PATH_TRACK;
            ///
            if (interp_dir && interp_vec) {
                if (this._modelForward && this._dir == -1)
                    Cesium.Cartesian3.negate(interp_vec, interp_vec);
                ///
                Cesium.Transforms.rotationMatrixFromPositionVelocity(interp_pos, interp_vec, undefined, this._temp_mat);
                const interp_ori = Cesium.Quaternion.fromRotationMatrix(this._temp_mat, this._temp_ori);
                //
                const tar = Cesium.Cartesian3.multiplyByScalar(interp_dir, 100, this._temp_tar);
                Cesium.Cartesian3.add(interp_pos, tar, tar);
                const c_tar = Cesium.Cartographic.fromCartesian(tar, undefined, this._temp_tar_c);
                const czcamera = this.view3d.czviewer.camera;
                const camera = this.view3d.cegore.camera;
                /// 跟随
                if (this._follow) {
                    /// 第一人称
                    if (this._first) {
                        camera.lookAtFromTo(c_pos, c_tar);
                    }
                    else {
                        const transform = Cesium.Transforms.eastNorthUpToFixedFrame(interp_pos, Cesium.Ellipsoid.WGS84, this._temp_matrix4);
                        /// 构建后方45度角跟随
                        if (CZMAP.Types.isDefined(this._eye_offset)) {
                            this._temp_offset.x = this._eye_offset[0];
                            this._temp_offset.y = this._eye_offset[1];
                            this._temp_offset.z = this._eye_offset[2];
                        }
                        else {
                            this._temp_offset.x = -this._sphere.radius;
                            this._temp_offset.y = 0;
                            this._temp_offset.z = this._sphere.radius;
                        }
                        let offset;
                        ////
                        if (this._lock) {
                            /// 计算旋转后的offset
                            const matrix3 = Cesium.Matrix3.fromQuaternion(interp_ori, this._temp_matrix3);
                            Cesium.Matrix3.multiplyByVector(matrix3, this._temp_offset, this._temp_offset);
                            /// 计算旋转后的世界坐标
                            Cesium.Cartesian3.add(this._temp_offset, interp_pos, this._temp_offset);
                            /// 通过逆变换获取offset
                            const invtransform = Cesium.Matrix4.inverse(transform, this._temp_inv_matrix4);
                            offset = Cesium.Matrix4.multiplyByPoint(invtransform, this._temp_offset, this._temp_offset);
                        }
                        else {
                            if (this._isFirstFollow) {
                                this._isFirstFollow = false;
                                Cesium.Cartesian3.clone(this._temp_offset, this._lastFollowOffset);
                                offset = this._lastFollowOffset;
                            }
                            else {
                                if (lastMode == RoamMode.THIRD_FREE)
                                    offset = Cesium.Cartesian3.clone(czcamera.position, this._lastFollowOffset);
                                else
                                    offset = this._lastFollowOffset;
                            }
                        }
                        czcamera.lookAtTransform(transform, offset);
                    }
                }
                else if (this._trackTarget) {
                    this.view3d.lookAt(current);
                }
                if (this._entity) {
                    if (this._entityRotate) {
                        const [h, p, r] = this._entityRotate;
                        const hpr = Cesium.HeadingPitchRoll.fromDegrees(h, p, r, TEMP_HPR);
                        const ori2 = Cesium.Quaternion.fromHeadingPitchRoll(hpr, this._temp_ori2);
                        Cesium.Quaternion.multiply(interp_ori, ori2, interp_ori);
                    }
                    this._entity.position = interp_pos;
                    this._entity.orientation = interp_ori;
                }
            }
            this.dispatchEvent(CZMAP.PathRoamEvents.MOVE);
        }
        get _czcamera() { return this.view3d.czviewer.camera; }
        /**
         * 跟随
         */
        set follow(v) {
            this._follow = v;
            if (v)
                this._czcamera.viewBoundingSphere(this._sphere);
            else
                this._czcamera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        }
        /**
         * 跟随
         */
        get follow() { return this._follow; }
        /**
         * 第一人称
         */
        set showline(v) { this._showLine = v; this._line.show = v; }
        /**
         * 第一人称
         */
        get showline() { return this._showLine; }
        /**
         * 线宽
         */
        set lineWidth(v) { this._lineWidth = v; this._line.polyline.width = v; }
        get lineWidth() { return this._lineWidth; }
        /**
         * 线颜色
         */
        set lineColor(v) { this._lineColor = v; this._line.polyline.material.color = CZMAP.CesiumAttrib.getColor(v); }
        get lineColor() { return this._lineColor; }
        /**
         * 获取漫游时的偏移
         */
        get offset() { return this._eye_offset; }
        /**
         * 设置漫游时的偏移
         */
        set offset(v) { this._eye_offset = v; }
        /**
         * 构建漫游路径
         */
        buildPath() {
            ///
            this._begin_seconds = Infinity;
            this._end_seconds = -Infinity;
            this._nodes.forEach(n => {
                this._begin_seconds = Math.min(this._begin_seconds, n.time);
                this._end_seconds = Math.max(this._end_seconds, n.time);
            });
            ///
            this._total_seconds = this._end_seconds - this._begin_seconds;
        }
        /**
         * 构建漫游插值对象
         */
        buildSampled() {
            function safeNormalize(vec, result) {
                const length = Cesium.Cartesian3.magnitude(vec);
                if (length > 0) {
                    if (!result)
                        result = new Cesium.Cartesian3();
                    return Cesium.Cartesian3.divideByScalar(vec, length, result);
                }
            }
            ///
            const nodes = this._nodes;
            const nnum = nodes.length;
            this._sample_pos = new Cesium.SampledPositionProperty();
            this._sample_dir = new Cesium.SampledPositionProperty();
            let last_direction = new Cesium.Cartesian3(1, 0, 0);
            const tempdir = new Cesium.Cartesian3();
            for (var i = 0; i < nnum; i++) {
                const n = nodes[i];
                const mtime = n.time; // - this._begin_seconds;
                let direction;
                /// 根据目标点计算方向
                if (CZMAP.Types.isDefined(n.target)) {
                    const target = Cesium.Cartesian3.fromDegrees(...n.target);
                    Cesium.Cartesian3.subtract(target, n.position3D, tempdir);
                    direction = safeNormalize(tempdir);
                }
                else /// 根据下一下点计算方向
                 {
                    if (i !== nnum - 1) {
                        const n = nodes[i], nr = nodes[i + 1];
                        Cesium.Cartesian3.subtract(nr.position3D, n.position3D, tempdir);
                        direction = safeNormalize(tempdir);
                    }
                    else /// 最后一个点使用前一个点的方向
                     {
                        direction = last_direction.clone();
                    }
                }
                if (!direction) {
                    direction = last_direction.clone();
                }
                const time = new Cesium.JulianDate(0, mtime);
                this._sample_pos.addSample(time, n.position3D);
                this._sample_dir.addSample(time, direction);
                last_direction = direction;
            }
            //模型姿态信息
            this._sample_ori = new Cesium.VelocityVectorProperty(this._sample_pos);
            this._sample_pos.setInterpolationOptions({
                interpolationDegree: 1,
                interpolationAlgorithm: Cesium.LinearApproximation
                //interpolationAlgorithm: Cesium.LagrangePolynomialApproximation
                //interpolationAlgorithm: Cesium.HermitePolynomialApproximation
            });
        }
        /**
         * 创建漫游模型
         */
        createModel(options) {
            if (!CZMAP.Types.isDefined(options.icon) && !CZMAP.Types.isDefined(options.model))
                return;
            this._entity = new Cesium.Entity();
            this.view3d.czviewer.entities.add(this._entity);
            if (CZMAP.Types.isDefined(options.icon)) {
                this._entity.billboard = new Cesium.BillboardGraphics({
                    image: options.icon.url,
                    pixelOffset: CZMAP.CesiumAttrib.getCartesian2(options.icon['offset']),
                    rotation: CZMAP.CesiumAttrib.getRadian(options.icon['rotation'], 0),
                    width: CZMAP.CesiumAttrib.getNumber(options.icon['width']),
                    height: CZMAP.CesiumAttrib.getNumber(options.icon['height']),
                });
            }
            if (CZMAP.Types.isDefined(options.model)) {
                this._entityRotate = options.model.rotate;
                this._entity.model = new Cesium.ModelGraphics({
                    uri: options.model.url || options.model.uri,
                    scale: CZMAP.CesiumAttrib.getNumber(options.model['scale'], 1)
                });
            }
            if (CZMAP.Types.isDefined(options.label)) {
                this._entity.label = new Cesium.LabelGraphics({
                    text: options.label.text,
                    scale: CZMAP.CesiumAttrib.getNumber(options.label['scale'], 0.5),
                    font: CZMAP.Types.defaultValue(options.label['font'], '32px 黑体'),
                    style: Cesium.LabelStyle.FILL,
                    pixelOffset: CZMAP.CesiumAttrib.getCartesian2(options.label['offset']),
                    fillColor: CZMAP.CesiumAttrib.getColor(options.label['color'], Cesium.Color.WHITE),
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 0,
                    showBackground: true,
                    backgroundColor: CZMAP.CesiumAttrib.getColor(options.label['backgroundColor'], Cesium.Color.DARKGREY),
                    // horizontalOrigin: CesiumAttrib.getHorizontal(labelstyle.horizontalOrigin),
                    // verticalOrigin: CesiumAttrib.getVertical(labelstyle.vertitalOrigin),
                    // distanceDisplayCondition: CesiumAttrib.getDisplayDistance(labelstyle.visibleRange),
                    // scaleByDistance: CesiumAttrib.getNearFarScalar(labelstyle.scaleDistance),
                    // translucencyByDistance: CesiumAttrib.getNearFarScalar(labelstyle.fadeDistance);
                });
            }
        }
        /**
         * 创建漫游线
         */
        createLine() {
            const pts = (this._nodes).map(n => n.position3D);
            /// 计算包围球
            this._sphere = Cesium.BoundingSphere.fromPoints(pts, this._sphere);
            /// 创建轨迹线
            this._line = this.view3d.czviewer.entities.add({
                show: this._showLine,
                polyline: {
                    positions: pts,
                    width: this._lineWidth,
                    material: new Cesium.PolylineOutlineMaterialProperty({
                        color: CZMAP.CesiumAttrib.getColor(this._lineColor),
                        outlineWidth: 1.0,
                        outlineColor: CZMAP.CesiumAttrib.getColor(this._lineColor)
                        //outlineColor : Cesium.Color.WHITE
                    })
                }
            });
        }
        /**
         * 创建路径点
         * @param pt 输入参数
         * @returns 路径点对象
         */
        _createPathNode(pt) {
            return new CZMAP.PathNode(pt);
        }
        /** 计算两点间距离 */
        _calcDistance(a, b) {
            return Cesium.Cartesian3.distance(a.position3D, b.position3D);
        }
    }
    CZMAP.PathRoam3D = PathRoam3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /// 
    const width = 512;
    const height = 512;
    class TextureInfo {
        constructor(dir, color, tex) {
            this.dir = dir;
            this.color = color;
            this.tex = tex;
        }
        get getTex() { return () => { return this.tex; }; }
    }
    /**
     * 基于巷道的纹理动画
     * @internal
     */
    class TunnelEffct3D extends CZMAP.TunnelEffct {
        /**
         */
        constructor(view) {
            super(view);
            /**
             * 模型的主键字段
             * @type {String}
             */
            this.model_key_field = undefined;
            /**
             * 属性数据的主键字段
             */
            this.data_key_field = undefined;
            /**
             * 定时器句柄
             */
            this.loopHandle = undefined;
            /**
             */
            this.view3d = view;
            ///
            this.scene = view.czviewer.scene;
            /// 
            this.image = new Image();
            this.image.onload = () => {
                drawStep(this, 0);
            };
            /// 
            this.uniforms = [];
            /**
             */
            this.texs = {};
            /**
             * 模型的主键字段
             * @type {String}
             */
            this.model_key_field = undefined;
            /**
             * 属性数据的主键字段
             */
            this.data_key_field = undefined;
        }
        /**
         *
         */
        init(options) {
            this.close();
            if (!CZMAP.Types.isDefined(options.data))
                throw "no params param!";
            if (!CZMAP.Types.isDefined(options.model))
                throw "no model param!";
            if (!CZMAP.Types.isDefined(options.datakeyfield))
                throw "no keyfield param!";
            if (!CZMAP.Types.isDefined(options.modelkeyfield))
                throw "no keyfield param!";
            this.model_key_field = options.modelkeyfield;
            this.data_key_field = options.datakeyfield;
            /// 贴图
            var url = CZMAP.Types.defaultValue(options.image, 'images/arrow.png');
            this.image.src = url;
            /// 
            this.canvas = createCanvas();
            this.ctx = this.canvas.getContext('2d');
            /// 
            if (options.model instanceof CZMAP.ModelLayer) {
                this.models = options.model.models.slice(0);
            }
            else if (Array.isArray(options.model)) {
                this.models = options.model;
            }
            else {
                this.models = [options.model];
            }
            this.texs = {};
            /**
             */
            this.params = {};
            /// 创建纹理
            for (let i = 0, ii = options.data.length; i < ii; ++i) {
                const item = options.data[i];
                const color = getColor(options, item);
                const dir = getDir(options, item);
                const key = item[options.datakeyfield];
                if ((dir != CZMAP.TunnelDir.FORWARD && dir != CZMAP.TunnelDir.BACKWARD) ||
                    !CZMAP.Types.isDefined(color))
                    continue;
                ///
                let tkey = dir + '-' + color;
                let texinfo = this.texs[tkey];
                if (!texinfo) {
                    let tex = createTexture(this.scene._context);
                    texinfo = new TextureInfo(dir, color, tex);
                    this.texs[tkey] = texinfo;
                }
                ///
                this.params[key] = texinfo;
            }
            if (this.visible)
                this.show();
            if (this.animation)
                this.start();
        }
        close() {
            this.stop();
            this.hide();
            for (let key in this.texs) {
                const ti = this.texs[key];
                ti.tex.destroy();
            }
            this.texs = undefined;
            this.params = undefined;
        }
        /**
         * 显示动态纹理
         */
        show() {
            if (this.uniforms.length > 0)
                return;
            this.models.forEach((p) => {
                if (!p.gltf)
                    return;
                let cmds = p._nodeCommands;
                let meshes = p.gltf.meshes;
                for (let i = 0; i < cmds.length; ++i) {
                    let c = cmds[i].command;
                    this.uniforms.push([c._uniformMap, c._uniformMap.u_baseColorTexture]);
                    let mesh = meshes[c.owner.mesh.id];
                    if (CZMAP.Types.isDefined(mesh.extras) && CZMAP.Types.isDefined(mesh.extras.attribute)) {
                        let key = mesh.extras.attribute[this.model_key_field];
                        if (!CZMAP.Types.isDefined(key))
                            continue;
                        //
                        let texinfo = this.params[key];
                        if (!CZMAP.Types.isDefined(texinfo))
                            continue;
                        cmds[i].command._uniformMap.u_baseColorTexture = texinfo.getTex;
                    }
                }
            });
        }
        /**
         * 隐藏动态纹理（还原）
         */
        hide() {
            if (this.uniforms.length == 0)
                return;
            var un = this.uniforms;
            for (var i = 0; i < un.length; ++i) {
                var u = un[i];
                u[0].u_baseColorTexture = u[1];
            }
            un.length = 0;
        }
        /**
         * 开始动画
         */
        start() {
            if (this.loopHandle)
                return;
            var that = this;
            this.loopHandle = setInterval(() => {
                drawStep(that, 100);
            }, 50);
        }
        /**
         * 停止动画
         */
        stop() {
            if (!this.loopHandle)
                return;
            clearInterval(this.loopHandle);
            this.loopHandle = 0;
        }
        /**
         * @abstract
         * @protected
         */
        _onVisibleChanged() {
            if (this.visible)
                this.show();
            else
                this.hide();
        }
        /**
         * @abstract
         * @protected
         */
        _onAnimationChanged() {
            if (this.animation)
                this.start();
            else
                this.stop();
        }
    }
    CZMAP.TunnelEffct3D = TunnelEffct3D;
    /**
     * 绘制一帧动画
     * @param {PipeTexFlow} ptf
     * @param {Number} step 步长
     */
    function drawStep(ptf, step) {
        var pos = ptf.pos = (ptf.pos + step) % width;
        for (let key in ptf.texs) {
            drawTex(ptf, pos, ptf.texs[key]);
        }
    }
    function drawTex(ptf, pos, texinfo) {
        var img = ptf.image;
        var ctx = ptf.ctx;
        if (texinfo.dir == 1) {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = texinfo.color;
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(img, pos - width, 0, width, height);
            ctx.drawImage(img, pos, 0, width, height);
            texinfo.tex.copyFrom(ptf.canvas);
        }
        else {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = texinfo.color;
            ctx.fillRect(0, 0, width, height);
            ctx.translate(width / 2, 0);
            ctx.scale(-1, 1);
            ctx.translate(-width / 2, 0);
            ctx.drawImage(img, pos + width, 0, -width, height);
            ctx.drawImage(img, pos, 0, -width, height);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            texinfo.tex.copyFrom(ptf.canvas);
        }
    }
    /**
     * 创建画布
     */
    function createCanvas() {
        const canvas = document.createElement('CANVAS');
        canvas.width = width;
        canvas.height = height;
        return canvas;
    }
    /**
     * 创建纹理对象
     */
    function createTexture(ctx) {
        return new Cesium.Texture({
            context: ctx,
            width: width,
            height: height,
            preMultiplyAlpha: false,
            flipY: false,
            sampler: new Cesium.Sampler({
                wrapS: Cesium.TextureWrap.REPEAT,
                wrapT: Cesium.TextureWrap.REPEAT,
            })
        });
    }
    /**
     *
     * @param {Object} options
     * @param {ModelLayer} options.model
     * @param {String} options.modelkeyfield 模型属性的主键
     * @param {String} options.image 贴图图片
     * @param {Array<Object>} options.data 方向属性数据
     * @param {String} options.datakeyfield 方向数据的主键
     * @param {String} options.dirfield 方向字段
     * @param {Object} options.dirmap 方向值映射
     * @param {String} options.colorfield 颜色字段
     * @param {Object} options.colormap 颜色值映射
     * @param {String} options.color 颜色
     */
    function getColor(options, data) {
        let color;
        if (CZMAP.Types.isString(options.colorfield)) {
            color = data[options.colorfield];
        }
        if (CZMAP.Types.isDefined(color) && CZMAP.Types.isObject(options.colormap)) {
            color = options.colormap[color];
        }
        if (CZMAP.Types.isDefined(color))
            return color;
        if (CZMAP.Types.isDefined(options.color))
            return options.color;
        return undefined;
    }
    /**
     *
     * @param {Object} options
     * @param {ModelLayer} options.model
     * @param {String} options.modelkeyfield 模型属性的主键
     * @param {String} options.image 贴图图片
     * @param {Array<Object>} options.data 方向属性数据
     * @param {String} options.datakeyfield 方向数据的主键
     * @param {String} options.dirfield 方向字段
     * @param {Object} options.dirmap 方向值映射
     * @param {String} options.colorfield 颜色字段
     * @param {Object} options.colormap 颜色值映射
     * @param {String} options.color 颜色
     */
    function getDir(options, data) {
        let dir;
        if (CZMAP.Types.isString(options.dirfield)) {
            dir = data[options.dirfield];
        }
        if (CZMAP.Types.isDefined(dir) && CZMAP.Types.isObject(options.dirmap)) {
            dir = options.dirmap[dir];
        }
        if (CZMAP.Types.isDefined(dir))
            return dir;
        return CZMAP.TunnelDir.NONE;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class TunnelTransparent3D extends CZMAP.TunnelTransparent {
        ///
        constructor(view) {
            super(view);
            /**
             */
            this.view3d = view;
            /**
             * 待处理的模型
             */
            this.models = undefined;
            ///
            this.scene = this.map.view3d.czviewer.scene;
        }
        /**
         * 初始化
         * @param {*} options
         */
        init(options) {
            if (!CZMAP.Types.isDefined(options.model))
                throw "no model param!";
            /// 
            if (options.model instanceof CZMAP.ModelLayer) {
                this.models = options.model.models.slice(0);
            }
            else if (Array.isArray(options.model)) {
                this.models = options.model;
            }
            else {
                this.models = [options.model];
            }
            this._commands = [];
            this.models.forEach(p => {
                if (!p.gltf)
                    return;
                const nodes = p._runtime.nodes;
                for (let id in nodes) {
                    const n = nodes[id];
                    const nid = n.publicNode.id;
                    const mid = p.gltf.nodes[nid].mesh;
                    const mesh = p.gltf.meshes[mid];
                    if (!CZMAP.Types.isDefined(mesh.extras))
                        continue;
                    const faces = mesh.extras['surface-side'];
                    if (!CZMAP.Types.isDefined(faces))
                        continue;
                    const cmds = n.commands;
                    for (let ci = 0; ci < cmds.length; ++ci) {
                        const f = faces[ci];
                        if (!CZMAP.Types.isDefined(f))
                            continue;
                        if (f == 1)
                            this._commands.push(cmds[ci]);
                    }
                }
            });
            ///
            this._handleEnable();
        }
        /**
         * 判断是否存在数据
         * @param options
         */
        checkExist(options) {
            if (!CZMAP.Types.isDefined(options.model))
                throw "no model param!";
            /// 
            if (options.model instanceof CZMAP.ModelLayer) {
                this.models = options.model.models.slice(0);
            }
            else if (Array.isArray(options.model)) {
                this.models = options.model;
            }
            else {
                this.models = [options.model];
            }
            let commands = [];
            this.models.forEach(p => {
                if (!p.gltf)
                    return;
                const nodes = p._runtime.nodes;
                for (let id in nodes) {
                    const n = nodes[id];
                    const nid = n.publicNode.id;
                    const mid = p.gltf.nodes[nid].mesh;
                    const mesh = p.gltf.meshes[mid];
                    if (!CZMAP.Types.isDefined(mesh.extras))
                        continue;
                    const faces = mesh.extras['surface-side'];
                    if (!CZMAP.Types.isDefined(faces))
                        continue;
                    const cmds = n.commands;
                    for (let ci = 0; ci < cmds.length; ++ci) {
                        const f = faces[ci];
                        if (!CZMAP.Types.isDefined(f))
                            continue;
                        if (f == 1)
                            commands.push(cmds[ci]);
                    }
                }
            });
            return commands.length > 0;
        }
        /**
         * 关闭
         */
        close() {
            this.enable = false;
            this._commands.length = 0;
        }
        _handleEnable() {
            const enable = this.enable;
            this._commands.forEach(c => {
                c.show = enable;
            });
        }
    }
    CZMAP.TunnelTransparent3D = TunnelTransparent3D;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class CoordGridUE extends CZMAP.CoordGrid {
        constructor(view) {
            super(view);
            this._visible = true;
        }
        getVisible() {
            return this._visible;
        }
        setVisible(value) {
            this._visible = value;
            if (this._grid)
                this._grid.setVisible(value);
        }
        build(option) {
            this.close();
            const cgb = new CZMAP.CoordGridBuild();
            cgb.build(option);
            option = cgb.option;
            const labelRender = CZMAP.LabelRender.instance();
            function buildTextImage(text) {
                return labelRender.render({
                    text,
                    font: option.textFont,
                    color: option.textColor
                }).toDataURL();
            }
            function toPoint(c) {
                const cp = new Cegore.Position(c);
                return [cp.x, cp.y, cp.z];
            }
            const gridDef = {
                visible: this._visible,
                grid: {
                    center: toPoint(cgb.center),
                    lines: cgb.lines.map(ln => ln.positions.map(pt => toPoint(pt))),
                    points: cgb.points.map(pt => toPoint(pt.position)),
                    texts: cgb.points.map(pt => buildTextImage(pt.text)),
                    offsets: cgb.points.map(pt => pt.pixelOffset),
                },
                lineColor: option.lineColor,
                lineWidth: option.lineWidth,
                pointColor: option.pointColor,
                pointSize: option.pointSize
            };
            this._grid = new CZMAP.UELayerProxy(this.view, 'coordGrid');
            this._grid.createLayer(gridDef);
        }
        close() {
            if (this._grid) {
                this._grid.removeLayer();
                this._grid = undefined;
            }
        }
    }
    CZMAP.CoordGridUE = CoordGridUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const DEFAULT_FILL_COLOR = 'yellow';
    const DEFAULT_LINE_COLOR = 'yellow';
    const DefaultStyle = {
        fillColor: DEFAULT_FILL_COLOR,
        lineColor: DEFAULT_LINE_COLOR,
        lineWidth: 3
    };
    const DefaultStyleDrawing = {
        fillColor: 'rgba(255,255,0,0.5)',
        lineColor: 'rgba(255,255,0,0.5)',
        lineWidth: 5
    };
    /** @internal */
    class DrawToolUE extends CZMAP.DrawTool {
        /**
         *
         */
        constructor(view) {
            super(view);
            this._items = new Map();
            this._syncBindEvents();
        }
        async _syncBindEvents() {
            await this.view.uview.ready;
            this._bindEvents(this.view.uview.sceneDOM);
        }
        /**
         * 添加几何
         * @param {*} geo
         * @param {*} style
         */
        add(geo, style, group) {
            switch (geo.type) {
                case CZMAP.GeometryType.POINT: return this.addPoint(geo, style, group);
                case CZMAP.GeometryType.POLYLINE: return this.addPolyline(geo, style, group);
                case CZMAP.GeometryType.POLYGON: return this.addPolygon(geo, style, group);
                case CZMAP.GeometryType.CIRCLE: return this.addCircle(geo, style, group);
                case CZMAP.GeometryType.RECTANGLE: return this.addRect(geo, style, group);
                default: throw `no type '${geo.type}'`;
            }
        }
        /**
         *
         */
        addPoint(geo, style, group) {
            style = CZMAP.deepAssign({}, style, DefaultStyle);
            const id = 'point-' + this._getNextID();
            const p = [geo.x, geo.y, geo.z];
            const polyline = new CZMAP.UELayerProxy(this.view, 'polyline');
            polyline.createLayer({
                positions: [p, p],
                style: {
                    stroke: toStrokStyle(style)
                }
            });
            this._items.set(id, polyline);
            this._setGroup(id, group);
            return id;
        }
        /**
         *
         */
        addPolyline(geo, style, group) {
            style = CZMAP.deepAssign({}, style, DefaultStyle);
            const id = 'polyline-' + this._getNextID();
            const polyline = new CZMAP.UELayerProxy(this.view, 'polyline');
            polyline.createLayer({
                positions: geo.coordinates,
                style: {
                    stroke: toStrokStyle(style)
                }
            });
            this._items.set(id, polyline);
            this._setGroup(id, group);
            return id;
        }
        /**
         *
         */
        addPolygon(geo, style, group) {
            style = style || DefaultStyle;
            const id = 'polygon-' + this._getNextID();
            this._addPolygon(id, geo.coordinates[0], style);
            this._setGroup(id, group);
            return id;
        }
        /**
         *
         */
        addRect(geo, style, group) {
            style = style || DefaultStyle;
            const id = 'rect-' + this._getNextID();
            const p0 = geo.min;
            const p1 = geo.max;
            const coords = [
                [p0[0], p0[1], 0],
                [p1[0], p0[1], 0],
                [p1[0], p1[1], 0],
                [p0[0], p1[1], 0],
                [p0[0], p0[1], 0]
            ];
            this._addPolygon(id, coords, style);
            this._setGroup(id, group);
            return id;
        }
        addCircle(geo, style, group) {
            throw new Error("not impl!");
        }
        addDynamicCircle(geo, dynStyle, group) {
            throw new Error("not impl!");
        }
        _addPolygon(id, points, style) {
            const polyline = new CZMAP.UELayerProxy(this.view, 'polyline');
            polyline.createLayer({
                positions: points,
                style: {
                    stroke: toStrokStyle(style)
                }
            });
            this._items.set(id, polyline);
        }
        /**
         * 移除
         */
        remove(id) {
            const item = this._items.get(id);
            if (item) {
                item.removeLayer();
                this._items.delete(id);
                this._delGroup(id);
            }
        }
        async _pick(x, y) {
            const resp = await this.view.uvapi.pickPosition(x, y);
            if (resp && resp.result) {
                return resp.result.position;
            }
        }
        _updateDrawing(type, pts) {
            if (pts.length === 0)
                return;
            if (!this._createGeometryUE())
                return;
            switch (type) {
                case CZMAP.GeometryType.POINT:
                    this._updatePoint(pts);
                    break;
                case CZMAP.GeometryType.POLYLINE:
                    this._updatePolyline(pts);
                    break;
                case CZMAP.GeometryType.POLYGON:
                    this._updatePolygon(pts);
                    break;
                case CZMAP.GeometryType.CIRCLE:
                    this._updateCircle(pts);
                    break;
                case CZMAP.GeometryType.RECTANGLE:
                    this._updateRectangle(pts);
                    break;
            }
        }
        _clearDrawing() {
            if (this._outline) {
                this._outline.removeLayer();
                this._outline = undefined;
            }
        }
        _createGeometryUE() {
            if (this._outline)
                return this._outline;
            const pl = new CZMAP.UELayerProxy(this.view, 'polyline');
            pl.createLayer({
                style: {
                    stroke: toStrokStyle(DefaultStyleDrawing)
                }
            });
            this._outline = pl;
            return pl;
        }
        _updatePoint(pts) {
            this._outline.updateLayer({
                positions: pts
            });
        }
        _updatePolyline(pts) {
            this._outline.updateLayer({
                positions: pts
            });
        }
        _updatePolygon(pts) {
            pts = pts.slice(0);
            pts.push(pts[0]);
            this._outline.updateLayer({
                positions: pts
            });
        }
        _updateCircle(pts) {
        }
        _updateRectangle(pts) {
            if (pts.length < 2)
                return;
            const [p0, p1] = pts;
            const [x0, y0, z0] = p0;
            const [x1, y1, z1] = p1;
            this._outline.updateLayer({
                positions: [[x0, y0, z0], [x0, y1, z0], [x1, y1, z1], [x1, y0, z1], [x0, y0, z0]]
            });
        }
    }
    CZMAP.DrawToolUE = DrawToolUE;
    function toStrokStyle(drawStyle) {
        return {
            width: drawStyle.lineWidth,
            depthCheck: false,
            detail: {
                type: CZMAP.StrokeDetailType.NORMAL,
                color: drawStyle.lineColor
            }
        };
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="../GridTool.ts" />
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class GridToolUE extends CZMAP.GridTool {
        /**
         * 构造网格绘制工具
         * @param view
         */
        constructor(view) {
            super(view);
        }
        _createCoordGrid(option) {
            const cg = new CZMAP.CoordGridUE(this.view);
            cg.build(option);
            return cg;
        }
    }
    CZMAP.GridToolUE = GridToolUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class InfoWindowUE extends CZMAP.InfoWindow {
        constructor(view, option) {
            super(view, option);
            this._id = -1;
            const viewue = view;
            this._uvapi = viewue.uvapi;
            this._id = this._uvapi.addOverlay(this.position, (x, y) => {
                this._updatePosition(x, y);
            });
            this._hiddenOnMove = InfoWindowUE.hiddenOnMove;
        }
        close() {
            if (!super.close())
                return false;
            if (!this._id)
                return true;
            ///
            this._uvapi.removeOverlay(this._id);
            this._id = undefined;
            ///
            return true;
        }
        _onPositionChange() {
            this._uvapi.updateOverlay(this._id, this.position);
        }
    }
    InfoWindowUE.hiddenOnMove = true;
    CZMAP.InfoWindowUE = InfoWindowUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 三维测量工具
     * @internal
     */
    class MeasureToolUE extends CZMAP.MeasureTool {
        /**
         */
        constructor(view) {
            super(view);
            this._items = [];
        }
        distance(option) {
            this._createDrawingLabel(option);
            super.distance(option);
        }
        _onDistDrawing(pts, option) {
            const dr = CZMAP.MeasureUtils.computeDistances(pts);
            const center = CZMAP.MeasureUtils.computeCenter(pts);
            const text = formatDistanceText(dr.distance, dr.flatDistance, dr.height);
            this._updateDrawingLabel(text, center, option);
        }
        _onDistFinished(dcp, option) {
            if (option.icons) {
                this._createIcon(dcp.points[0], option.icons.start);
                this._createIcon(dcp.points.last(), option.icons.end);
            }
            this._currentLabel = undefined;
        }
        arae(option) {
            this._createDrawingLabel(option);
            super.arae(option);
        }
        _onAreaDrawing(pts, option) {
            const ar = CZMAP.MeasureUtils.computeArea(pts);
            const center = CZMAP.MeasureUtils.computeCenter(pts);
            const text = CZMAP.MeasureTool.formatAreaText(ar.area);
            this._updateDrawingLabel(text, center, option);
        }
        _onAreaFinished(acp, option) {
            this._currentLabel = undefined;
        }
        angle(option) {
            this._createDrawingLabel(option);
            super.angle(option);
        }
        _onAngleDrawing(pts, option) {
            const ar = CZMAP.MeasureUtils.computeAngle(pts[0], pts[1]);
            const center = CZMAP.MeasureUtils.computeCenter(pts);
            const text = CZMAP.MeasureTool.formatAngleText(ar.heading, ar.pitch);
            this._updateDrawingLabel(text, center, option);
        }
        _onAngleFinished(acp, option) {
            this._currentLabel = undefined;
        }
        _onCancel() {
            this._removeDrawingLabel();
        }
        /**
         * 清除测量
         */
        clear() {
            this.view.drawTool.clear(CZMAP.MeasureToolGroup);
            this._items.forEach(item => item.removeLayer());
            this._items.length = 0;
        }
        _calcLabelPosition(pos, option) {
            if (!option.labelOffset)
                return pos;
            const [x, y, z] = pos;
            const [ox, oy, oz] = option.labelOffset;
            return [x + ox, y + oy, z + oz];
        }
        _createDrawingLabel(option) {
            const pt = new CZMAP.UELayerProxy(this.view, 'point');
            pt.createLayer({
                visible: true,
            });
            this._items.push(pt);
            this._currentLabel = pt;
        }
        _updateDrawingLabel(text, pos, option) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const label = this._currentLabel;
            if (!label)
                return;
            const labelRender = CZMAP.LabelRender.instance();
            labelRender.render({
                text,
                font: (_a = option.labelStyle) === null || _a === void 0 ? void 0 : _a.font,
                color: (_b = option.labelStyle) === null || _b === void 0 ? void 0 : _b.fillColor,
                borderWidth: (_c = option.labelStyle) === null || _c === void 0 ? void 0 : _c.outlineWidth,
                borderColor: (_d = option.labelStyle) === null || _d === void 0 ? void 0 : _d.outlineColor,
                background: (_e = option.labelStyle) === null || _e === void 0 ? void 0 : _e.background,
                backgroundColor: (_f = option.labelStyle) === null || _f === void 0 ? void 0 : _f.backgroundColor,
                backgroundBorderColor: (_g = option.labelStyle) === null || _g === void 0 ? void 0 : _g.backgroundBorderColor,
                backgroundBorderWidth: (_h = option.labelStyle) === null || _h === void 0 ? void 0 : _h.backgroundBorderWidth,
                backgroundBorderRadius: (_j = option.labelStyle) === null || _j === void 0 ? void 0 : _j.backgroundBorderRadius
                //offset: option.labelStyle.pixelOffset
            });
            label.updateLayer({
                position: pos,
                labelIcon: {
                    visible: true,
                    offset: [0, 0],
                    src: labelRender.toDataURL(),
                    width: labelRender.canvas.width,
                    height: labelRender.canvas.height,
                    horizontalOrigin: CZMAP.HorizontalOrigin.CENTER,
                    verticalOrigin: CZMAP.VerticalOrigin.CENTER,
                    depthDistance: 10000000000,
                }
            });
        }
        _removeDrawingLabel() {
            const label = this._currentLabel;
            if (!label)
                return;
            label.removeLayer();
            CZMAP.ArrayUtils.removeItem(this._items, label);
            this._currentLabel = undefined;
        }
        _createIcon(pt, icon) {
            if (!icon)
                return;
            if (!icon.img)
                return;
            const iconP = new CZMAP.UELayerProxy(this.view, 'point');
            iconP.createLayer({
                visible: true,
                position: pt,
                icon: {
                    visible: true,
                    src: CZMAP.absURL(icon.img),
                    offset: icon.offset,
                    verticalOrigin: CZMAP.VerticalOrigin.BOTTOM
                }
            });
            this._items.push(iconP);
        }
    }
    CZMAP.MeasureToolUE = MeasureToolUE;
    function formatDistanceText(dist, flat, height) {
        const fmt = CZMAP.MeasureUtils.formatDistances;
        return `距离：${fmt(dist)}`;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** @internal */
    class PathRoamUE extends CZMAP.PathRoam {
        constructor(view) {
            super(view);
            this.on(CZMAP.PathRoamEvents.SPEED, () => this._execute({ speed: this.speed }));
            this.on(CZMAP.PathRoamEvents.LOOP, () => this._execute({ loop: this.loop }));
            this.on(CZMAP.PathRoamEvents.FOLLOW, () => this._execute({ follow: this.follow }));
            this.on(CZMAP.PathRoamEvents.FIRST_VIEW, () => this._execute({ firstview: this.firstview }));
            this.on(CZMAP.PathRoamEvents.LOCK_VIEW, () => this._execute({ lockview: this.lockview }));
            this.on(CZMAP.PathRoamEvents.CURRENT_TIME, () => this._execute({ currentTime: this.currentTime }));
            this.on(CZMAP.PathRoamEvents.TRACK_TRAGET, () => this._execute({ trackTarget: this.trackTarget }));
            this.on(CZMAP.PathRoamEvents.SHOW_LINE, () => this._execute({ showLine: this.showline }));
            this.on(CZMAP.PathRoamEvents.LINE_WIDTH, () => this._execute({ lineWidth: this.lineWidth }));
            this.on(CZMAP.PathRoamEvents.LINE_COLOR, () => this._execute({ lineColor: this.lineColor }));
        }
        _init(option) {
            var _a;
            const opt = CZMAP.deepCopy(option);
            if ((_a = opt.icon) === null || _a === void 0 ? void 0 : _a.url) {
                opt.icon.url = CZMAP.absURL(opt.icon.url);
            }
            this._uvroam = new CZMAP.UELayerProxy(this.view, 'pathroam');
            this._uvroam.createLayer({
                path: this._nodes, option: opt
            }).then(() => {
                this._uvroam.uvapi.regPathRoam(this._uvroam.id, this);
            });
        }
        _release() {
            if (this._uvroam) {
                this._uvroam.uvapi.unregPathRoam(this._uvroam.id);
                this._uvroam.removeLayer();
                this._uvroam = undefined;
            }
        }
        /**
         * 开始漫游
         */
        start() { var _a; super.start(); (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer({ start: 1 }); }
        /**
         * 暂停漫游
         */
        pause() { var _a; super.pause(); (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer({ pause: 1 }); }
        /**
         * 恢复漫游
         */
        resume() { var _a; super.resume(); (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer({ resume: 1 }); }
        /**
         * 前进
         */
        forward() { var _a; super.forward(); (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer({ forward: 1 }); }
        /**
         * 后退
         */
        backward() { var _a; super.backward(); (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer({ backward: 1 }); }
        set currentTime(v) {
            var _a;
            this._current_seconds = v;
            (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer({ currentTime: v });
        }
        get currentTime() {
            return super.currentTime;
        }
        /**
         * 设置漫游时的偏移
         */
        set offset(v) { }
        _execute(data) {
            var _a;
            (_a = this._uvroam) === null || _a === void 0 ? void 0 : _a.executeLayer(data);
        }
        _createPathNode(pt) {
            return new CZMAP.PathNode(pt);
        }
        _calcDistance(a, b) {
            return Cesium.Cartesian3.distance(a.position3D, b.position3D);
        }
        notify_pathroam(info) {
            this._current_seconds = info.currentTime;
            this._current_position = info.currentPosition;
            this.dispatchEvent(CZMAP.PathRoamEvents.MOVE);
            if (info.action === 'stop') {
                this.dispatchEvent(CZMAP.PathRoamEvents.STOP);
            }
        }
    }
    CZMAP.PathRoamUE = PathRoamUE;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 数组工具
     */
    class ArrayUtils {
        /**
         * 比较两个数组
         * @param a1
         * @param a2
         */
        static equals(a1, a2) {
            if (Object.is(a1, a2))
                return true;
            ///
            if (!CZMAP.Types.isArray(a1))
                return false;
            if (!CZMAP.Types.isArray(a2))
                return false;
            const num = a1.length;
            if (num !== a2.length)
                return false;
            for (let i = 0; i < num; ++i) {
                if (!Object.is(a1[i], a2[i]))
                    return false;
            }
            ///
            return true;
        }
        /** 移除数组指定对象 */
        static removeItem(array, item) {
            const index = array.indexOf(item);
            if (index == -1)
                return;
            array.splice(index, 1);
        }
    }
    CZMAP.ArrayUtils = ArrayUtils;
})(CZMAP || (CZMAP = {}));
/// hack
if (Array.prototype['last'] === undefined) {
    Array.prototype['last'] = function () {
        const len = this.length;
        if (len == 0)
            return;
        return this[len - 1];
    };
}
if (Array.prototype['clear'] === undefined) {
    Array.prototype['clear'] = function () {
        this.length = 0;
    };
}
var CZMAP;
(function (CZMAP) {
    let Axis;
    (function (Axis) {
        Axis[Axis["AXIS_X"] = 0] = "AXIS_X";
        Axis[Axis["AXIS_Y"] = 1] = "AXIS_Y";
        Axis[Axis["AXIS_Z"] = 2] = "AXIS_Z";
    })(Axis = CZMAP.Axis || (CZMAP.Axis = {}));
    (function (Axis) {
        function parser(val) {
            switch (val) {
                case 0:
                case 'x':
                case 'X':
                    return Axis.AXIS_X;
                case 1:
                case 'y':
                case 'Y':
                    return Axis.AXIS_Y;
                case 2:
                case 'z':
                case 'Z':
                    return Axis.AXIS_Z;
            }
        }
        Axis.parser = parser;
    })(Axis = CZMAP.Axis || (CZMAP.Axis = {}));
})(CZMAP || (CZMAP = {}));
/// hack cesium bug
/// cesium注记在聚合后不会更新聚合状态
const EntityClusterUpdate = Cesium.EntityCluster.prototype.update;
Cesium.EntityCluster.prototype.update = function (frameState) {
    function checkNeedUpdateLabel(lc) {
        ///
        if (!Cesium.defined(lc))
            return false;
        ///
        const len = lc.length;
        for (let i = 0; i < len; ++i) {
            const lb = lc.get(i);
            if (lb.text.length > 0 && lb._glyphs.length === 0) {
                return true;
            }
        }
        return false;
    }
    /// Cesium 内部处理不完备，有些情况下结果不正确
    var commandList = [];
    if (checkNeedUpdateLabel(this._labelCollection)) {
        commandList = frameState.commandList;
        frameState.commandList = [];
        this._labelCollection.update(frameState);
        frameState.commandList = commandList;
    }
    const that = this;
    EntityClusterUpdate.call(that, frameState);
    const lc = that._labelCollection;
    if (!lc)
        return;
    ///
    const len = lc.length;
    for (let i = 0; i < len; ++i) {
        const label = lc.get(i);
        const show = label.clusterShow;
        label.clusterShow = !show;
        label.clusterShow = show;
    }
};
var CZMAP;
(function (CZMAP) {
    class Cluster3D {
        constructor(view3d, ds) {
            /** 最大爆炸数量 */
            this._maxStarBurst = 30;
            /** 聚合数字字体大小 */
            this._numFontSize = 15;
            /** 聚合数字颜色 */
            this._numColor = 'white';
            /** 聚合数字背景色 */
            this._numBkColor = 'red';
            this._sbs = new StarBurstState();
            this._view3d = view3d;
            this._datasource = ds;
            this._czviewer = view3d.czviewer;
            ///
            this._setupCluster3D(ds, view3d.czviewer);
        }
        set maxStarBurst(num) { this._maxStarBurst = num; }
        get maxStarBurst() { return this._maxStarBurst; }
        set numFontSize(size) { this._numFontSize = size; }
        get numFontSize() { return this._numFontSize; }
        set numColor(color) { this._numColor = color; }
        ;
        get numColor() { return this._numColor; }
        set numBkColor(color) { this._numBkColor = color; }
        get numBkColor() { return this._numBkColor; }
        _setupCluster3D(ds, viewer) {
            ds.clustering.clusterEvent.addEventListener((clusteredEntities, cluster) => {
                this._cesiumEntityClusterCustom(clusteredEntities, cluster, viewer);
            });
            //ds.entities.collectionChanged.addEventListener(() => {
            //    ds.clustering._clusterDirty = true;
            //});
            ///
            this._handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
            this._handler.setInputAction((e) => this._onLeftClick(e), Cesium.ScreenSpaceEventType.LEFT_CLICK);
            this._handler.setInputAction((e) => this._onMouseMove(e), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this._handler.setInputAction((e) => this._onMouseWheel(e), Cesium.ScreenSpaceEventType.WHEEL);
            const camera = viewer.camera;
            camera.moveStart.addEventListener(this._onMoveStart, this);
        }
        _onMoveStart() {
            undoStarBurst(this._czviewer, this._sbs);
        }
        _onMouseWheel(movement) {
            undoStarBurst(this._czviewer, this._sbs);
        }
        _onMouseMove(movement) {
            updateStarBurst(this._czviewer, this._sbs, movement.endPosition);
        }
        _onLeftClick(movement) {
            const picked = this._czviewer.scene.pick(movement.position);
            const ids = picked === null || picked === void 0 ? void 0 : picked.id;
            if (!Array.isArray(ids))
                return;
            if (!(picked.primitive instanceof Cesium.Billboard))
                return;
            const count = ids.length;
            if (count > this._maxStarBurst)
                return;
            ///
            starBurst(this._czviewer, picked.primitive, ids, this._sbs);
        }
        async _cesiumEntityClusterCustom(clustered, cluster, czviewer) {
            cluster.label.show = false;
            let billboard;
            const len = clustered.length;
            for (let i = 0; i < len; ++i) {
                const ent = clustered[i];
                if (!ent.billboard)
                    continue;
                const prop = ent.billboard.image;
                if (prop.isConstant) {
                    billboard = ent.billboard;
                    break;
                }
            }
            const time = czviewer.clock.currentTime;
            const image = billboard.image.getValue(undefined);
            const icon = await CZMAP.clusterIconCreater.requestIcon({
                url: image,
                num: clustered.length,
                numColor: this._numColor,
                numBkColro: this._numBkColor,
                numFontSize: this._numFontSize
            });
            ///
            cluster.billboard.show = true;
            /// 当billboard被销毁后会抛异常
            try {
                const cb = cluster.billboard;
                const sb = billboard;
                cb.id = cluster.label.id;
                cb.image = icon;
                //cb.scale = 0.5;
                copyProp(cb, sb, 'scale', time);
                copyProp(cb, sb, 'color', time);
                copyProp(cb, sb, 'rotation', time);
                copyProp(cb, sb, 'width', time);
                copyProp(cb, sb, 'height', time);
                copyProp(cb, sb, 'sizeInMeters', time);
                copyProp(cb, sb, 'horizontalOrigin', time);
                copyProp(cb, sb, 'verticalOrigin', time);
            }
            catch (ex) {
            }
        }
    }
    CZMAP.Cluster3D = Cluster3D;
    function findBillboard(entity, primitives) {
        const len = primitives.length;
        for (let i = 0; i < len; ++i) {
            const pri = primitives.get(i);
            if (pri instanceof Cesium.PrimitiveCollection) {
                const find = findBillboard(entity, pri);
                if (find)
                    return find;
                continue;
            }
            if (pri instanceof Cesium.EntityCluster) {
                const bc = pri._billboardCollection;
                if (!bc)
                    continue;
                ///
                const blen = bc.length;
                for (let b = 0; b < blen; ++b) {
                    const bb = bc.get(b);
                    if (bb.id === entity)
                        return bb;
                }
                continue;
            }
        }
    }
    class StarBurstState {
        constructor() {
            this.items = [];
            this.pixelPadding = 10;
        }
    }
    function getPixelDimensions(camera, width, height, distance, pixelRatio, result) {
        if (CZMAP.compVersion(Cesium.VERSION, '1.63') >= 0) {
            return camera.frustum.getPixelDimensions(width, height, distance, pixelRatio, result);
        }
        else {
            const frustum = camera.frustum;
            return frustum.getPixelDimensions(width, height, distance, result);
        }
    }
    function offsetBillboard(scene, sbi, position, angle, magnitude) {
        const camera = scene.camera;
        const entity = sbi.entity;
        const x = magnitude * Math.cos(angle);
        const y = magnitude * Math.sin(angle);
        const dbWidth = scene.drawingBufferWidth;
        const dbHeight = scene.drawingBufferHeight;
        const pixelRatio = scene.pixelRatio;
        const diff = Cesium.Cartesian3.subtract(position, camera.positionWC, new Cesium.Cartesian3());
        const distance = Cesium.Cartesian3.dot(camera.directionWC, diff);
        ///
        const offset = new Cesium.Cartesian2(x, y);
        const dimensions = getPixelDimensions(camera, dbWidth, dbHeight, distance, pixelRatio, new Cesium.Cartesian2());
        Cesium.Cartesian2.multiplyByScalar(offset, Cesium.Cartesian2.maximumComponent(dimensions), offset);
        const eyeOffset = new Cesium.Cartesian3(offset.x, offset.y, 0.0);
        entity.billboard.eyeOffset = eyeOffset;
        if (Cesium.defined(entity.label)) {
            entity.label.eyeOffset = new Cesium.Cartesian3(offset.x, offset.y, -10.0);
            entity.label.show = false;
        }
        ///
        const endPoint = Cesium.Matrix4.multiplyByPoint(camera.viewMatrix, position, new Cesium.Cartesian3());
        Cesium.Cartesian3.add(eyeOffset, endPoint, endPoint);
        Cesium.Matrix4.multiplyByPoint(camera.inverseViewMatrix, endPoint, endPoint);
        ///
        sbi.endPoint = endPoint;
    }
    function calcStarCircles(allCount, dimension) {
        /// 预计算分布
        let needAvc = false;
        let allMaxCount = 0;
        const circles = [];
        let radius = dimension + dimension * 0.25;
        const radiusInc = radius;
        let index = 0;
        while (index < allCount) {
            /// 计算角度
            let angleInc = dimension / radius;
            const maxCount = Math.floor(Math.PI / angleInc) + 1;
            /// 
            const remCount = (allCount - index);
            const count = Math.min(maxCount, remCount);
            ///
            circles.push({
                count,
                maxCount,
                angleInc,
                radius
            });
            ///
            allMaxCount += maxCount;
            if (count < maxCount / 2)
                needAvc = true;
            ///
            radius += radiusInc;
            index += count;
        }
        /// 将所有点平均分配到每圈
        if (needAvc && circles.length > 1) {
            let start = 0;
            circles.forEach(cc => {
                const end = (cc.maxCount / allMaxCount) * allCount + start;
                cc.count = Math.round(end) - Math.round(start);
                start = end + 1;
            });
        }
        ///
        return { circles, maxRadius: radius };
    }
    function starBurst(viewer, cluster, entites, sbs) {
        if (sbs.cluster !== cluster) {
            undoStarBurst(viewer, sbs);
        }
        /// 筛选对象
        const scene = viewer.scene;
        const billboards = [];
        entites.forEach(selEntity => {
            if (selEntity.billboard) {
                const billboard = findBillboard(selEntity, scene.primitives);
                if (billboard) {
                    const entity = new Cesium.Entity(selEntity);
                    entity.position = cluster.position;
                    entity._czmap_obj = selEntity._czmap_obj;
                    viewer.entities.add(entity);
                    billboards.push({ entity, billboard });
                }
            }
        });
        if (billboards.length === 0) {
            return;
        }
        const pickedItems = sbs.items;
        sbs.maxDimension = Number.NEGATIVE_INFINITY;
        sbs.cluster = cluster;
        cluster.show = false;
        ///
        const center = Cesium.Cartesian3.clone(cluster.position);
        ///  计算最大尺寸
        let maxDimension = Number.NEGATIVE_INFINITY;
        billboards.forEach(object => {
            const { width, height, scale } = object.billboard;
            const maxd = Math.max(width, height) * scale + sbs.pixelPadding;
            maxDimension = Math.max(maxDimension, maxd);
        });
        /// 计算布局
        const layout = calcStarCircles(billboards.length, maxDimension);
        ///
        let index = 0;
        layout.circles.forEach(cc => {
            const angles = (cc.count - 1) * cc.angleInc;
            let angle = (Math.PI - angles) / 2;
            for (let c = 0; c < cc.count; ++c) {
                const object = billboards[index + c];
                if (!object)
                    continue;
                ///
                const sbi = {
                    entity: object.entity,
                    billboard: object.billboard,
                    endPoint: new Cesium.Cartesian3()
                };
                ///
                offsetBillboard(scene, sbi, center, angle, cc.radius);
                pickedItems.push(sbi);
                /// 
                angle += cc.angleInc;
            }
            index += cc.count;
        });
        // Add lines from the pick center out to the translated billboard.
        const instances = [];
        pickedItems.forEach(pe => {
            instances.push(new Cesium.GeometryInstance({
                geometry: new Cesium.SimplePolylineGeometry({
                    positions: [center, pe.endPoint],
                    arcType: Cesium.ArcType.NONE,
                    granularity: Cesium.Math.PI_OVER_FOUR,
                }),
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE),
                },
            }));
        });
        ///
        sbs.maxDimension = maxDimension;
        ///
        sbs.lines = scene.primitives.add(new Cesium.Primitive({
            geometryInstances: instances,
            appearance: new Cesium.PerInstanceColorAppearance({
                flat: true,
                translucent: false,
            }),
            asynchronous: false,
        }));
        ///
        sbs.radius = layout.maxRadius;
    }
    function updateStarBurst(viewer, sbs, mousePosition) {
        if (!Cesium.defined(sbs.cluster)) {
            return;
        }
        // Remove the star burst if the mouse exits the screen space circle.
        // If the mouse is inside the circle, show the label of the billboard the mouse is hovering over.
        const screenPosition = Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, sbs.cluster.position);
        const fromCenter = Cesium.Cartesian2.subtract(mousePosition, screenPosition, new Cesium.Cartesian2());
        const radius = sbs.radius;
        if (Cesium.Cartesian2.magnitudeSquared(fromCenter) > radius * radius ||
            fromCenter.y > 3.0 * (sbs.maxDimension + sbs.pixelPadding)) {
            undoStarBurst(viewer, sbs);
        }
        else {
            showLabels(viewer, sbs, mousePosition);
        }
    }
    function undoStarBurst(viewer, sbs) {
        if (!sbs.cluster)
            return;
        ///
        sbs.items.forEach(sbi => {
            viewer.entities.remove(sbi.entity);
        });
        // Remove lines from the scene.
        // Free resources and reset state.
        viewer.scene.primitives.remove(sbs.lines);
        sbs.cluster.show = true;
        ///
        sbs.lines = undefined;
        sbs.items.length = 0;
        sbs.cluster = undefined;
    }
    let currentObject;
    function showLabels(viewer, sbs, mousePosition) {
        const pickedObject = viewer.scene.pick(mousePosition);
        if (!pickedObject)
            return;
        ///
        const item = sbs.items.find(it => it.entity === pickedObject.id);
        if (!item)
            return;
        ///
        if (pickedObject !== currentObject) {
            if (Cesium.defined(currentObject) &&
                Cesium.defined(currentObject.label)) {
                currentObject.label.show = false;
                currentObject = undefined;
            }
            if (Cesium.defined(pickedObject) &&
                Cesium.defined(pickedObject.id.label)) {
                currentObject = pickedObject.id;
                currentObject.label.show = true;
            }
        }
    }
    function copyProp(tar, src, prop, time) {
        const p = src[prop];
        if (!p)
            return;
        const val = p.getValue(time);
        if (!val)
            return;
        tar[prop] = val;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 聚合图标构建器，构建在右上角显示聚合数量的聚合图标 */
    class ClusterIconCreater {
        constructor() {
            this._maxCache = 200;
            this._lowWater = 150;
            this._cache = new Map();
        }
        /** 请求聚合图标 */
        async requestIcon(option) {
            option = Object.assign({ numColor: 'white', numBkColor: 'red', numFontSize: 15 }, option);
            const key = this.genkey(option);
            let canvas = this.get(key);
            if (canvas) {
                return canvas;
            }
            const img = await this.requestImage(option.url);
            canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const text = option.num.toFixed(0);
            const radius = 8;
            const fontSize = option.numFontSize;
            ctx.font = `${fontSize}px 黑体`;
            const mea = ctx.measureText(text);
            const w = Math.max(fontSize, mea.width); // + radius * 2;
            const h = fontSize; // + radius * 2;
            const hw = (w >> 1);
            const hh = (h >> 1);
            canvas.width = img.width + hw + 1;
            canvas.height = img.height + hh + 1;
            const x = img.width - hw;
            const y = 0;
            const cx = img.width;
            const cy = hh;
            ///
            ctx.drawImage(img, 0, hh);
            const path = buildCircleRect(x, y, hw << 1, hh << 1, radius);
            ctx.fillStyle = option.numBkColro;
            ctx.fill(path);
            ctx.fillStyle = option.numColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, cx, cy);
            ///
            this.put(key, canvas);
            ///
            return canvas;
        }
        genkey(option) {
            return `num:${option.num}-f:${option.numFontSize}-c:${option.numColor}-${option.numBkColro}@${option.url}`;
        }
        get(key) {
            let item = this._cache.get(key);
            if (item) {
                item.timestamp = new Date().getTime();
                return item.canvas;
            }
        }
        put(key, canvas) {
            if (this._cache.size >= this._maxCache) {
                const values = [];
                this._cache.forEach(v => values.push(v));
                values.sort((a, b) => a.timestamp - b.timestamp);
                const num = this._cache.size - this._lowWater;
                for (let i = 0; i < num; ++i) {
                    this._cache.delete(values[i].key);
                }
            }
            this._cache.set(key, {
                key,
                timestamp: new Date().getTime(),
                canvas
            });
        }
        requestImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.crossOrigin = 'anonymous';
                img.src = url;
            });
        }
    }
    CZMAP.ClusterIconCreater = ClusterIconCreater;
    /** 全局聚合图标构建器 */
    CZMAP.clusterIconCreater = new ClusterIconCreater();
    /** 构建圆角矩形 */
    function buildCircleRect(x, y, width, height, radius) {
        const path = new Path2D();
        const r90 = Math.PI / 2;
        ///
        const s = Math.min(width, height);
        const r = Math.min(radius, s / 2);
        path.moveTo(x + r, y + 0);
        path.lineTo(x + width - r, y + 0);
        path.arc(x + width - r, y + r, r, r90 * 3, r90 * 4, false);
        path.lineTo(x + width, y + height - r);
        path.arc(x + width - r, y + height - r, r, 0, r90, false);
        path.lineTo(x + r, y + height);
        path.arc(x + r, y + height - r, r, r90, r90 * 2, false);
        path.lineTo(x + 0, y + r);
        path.arc(x + r, y + r, r, r90 * 2, r90 * 3, false);
        return path;
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let ColorTableType;
    (function (ColorTableType) {
        /** 分段色表 */
        ColorTableType["PIECEWISE"] = "piecewise";
        /** 连续色表 */
        ColorTableType["CONTINUOUS"] = "continuous";
    })(ColorTableType = CZMAP.ColorTableType || (CZMAP.ColorTableType = {}));
    class ColorTable {
        constructor(option) {
            const defColor = option.defaultColor || 'rgba(0,0,0,0)';
            this._default = {
                color: defColor,
                rgba: cssColor2Bytes(defColor),
                min: -Infinity,
                max: Infinity
            };
        }
        /** 创建分段色表 */
        static createPiecewise(colors, defaultColor) {
            return new PiecewiseColorTable({ colors, defaultColor });
        }
        /** 创建连续色表 */
        static createContinuous(colors, min, max) {
            return new ContinuousColorTable({ colors, min, max });
        }
        /** 获取默认颜色 */
        get default() { return this._default; }
        /** 根据值获取css颜色字符串 */
        getCssColor(val) {
            return this._find(val).color;
        }
        /** 根据值获取颜色分量 */
        getColorByte(val) {
            return this._find(val).rgba;
        }
    }
    CZMAP.ColorTable = ColorTable;
    class PiecewiseColorTable extends ColorTable {
        constructor(option) {
            super(option);
            const colors = option.colors;
            const ctx = createColorCanvas(colors.length);
            ///
            colors.forEach((ci, index) => {
                ctx.fillStyle = ci.color;
                ctx.fillRect(index, 0, 1, 1);
            });
            const cdata = ctx.getImageData(0, 0, colors.length, 1).data;
            this._items = colors.map((ci, index) => {
                const of = index * 4;
                return {
                    min: ci.min,
                    max: ci.max,
                    color: ci.color,
                    rgba: [cdata[of], cdata[of + 1], cdata[of + 2], cdata[of + 3]]
                };
            });
        }
        get type() { return ColorTableType.PIECEWISE; }
        get colors() { return this._items; }
        /** 转为渐变色表 */
        toContinuous(vmin, vmax, colorNum, filter) {
            const ctx = createColorCanvas(colorNum);
            ctx.fillStyle = this.default.color;
            ctx.clearRect(0, 0, colorNum, 1);
            const vrange = vmax - vmin;
            const ssfs = CZMAP.defaultValue(filter, 0.5) * 0.5;
            const grad = ctx.createLinearGradient(0, 0, colorNum, 0);
            this._items.forEach((c, i) => {
                let s1 = (c.min - vmin) / vrange;
                let s2 = (c.max - vmin) / vrange;
                if (s1 < 0)
                    s1 = 0;
                else if (s1 > 1.0)
                    return;
                if (s2 < 0)
                    return;
                else if (s2 > 1.0)
                    s2 = 1.0;
                const ss = s2 - s1;
                grad.addColorStop(s1 + ssfs * ss, c.color);
                grad.addColorStop(s2 - ssfs * ss, c.color);
            });
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, colorNum, 1);
            return ctx.getImageData(0, 0, colorNum, 1).data;
        }
        _find(val) {
            const find = this._items.find(it => val >= it.min && val < it.max);
            if (find)
                return find;
            ///
            return this.default;
        }
    }
    CZMAP.PiecewiseColorTable = PiecewiseColorTable;
    class ContinuousColorTable extends ColorTable {
        constructor(option) {
            super(option);
            this._items = [];
            const items = 4096;
            const ctx = createColorCanvas(items);
            const { colors, min, max } = option;
            const range = max - min;
            const grad = ctx.createLinearGradient(0, 0, items, 0);
            colors.forEach((ci, index) => {
                grad.addColorStop(index / (colors.length - 1), ci);
            });
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, items, 1);
            const cdata = ctx.getImageData(0, 0, items, 1).data;
            this._items.length = items;
            for (let i = 0; i < items; ++i) {
                const of = i * 4;
                const rgba = [cdata[of], cdata[of + 1], cdata[of + 2], cdata[of + 3]];
                const vmin = (i / items) * range + min;
                const vmax = ((i + 1) / items) * range + min;
                this._items[i] = {
                    color: bytes2CssColor(rgba),
                    rgba,
                    min: vmin,
                    max: vmax
                };
            }
            this._min = min,
                this._max = max;
        }
        get type() { return ColorTableType.CONTINUOUS; }
        _find(val) {
            if (val < this._min || val > this._max)
                return this.default;
            ///
            const vrange = this._max - this._min;
            const cnum = this._items.length;
            let pv = ((val - this._min) / vrange * cnum) | 0;
            if (pv === cnum)
                pv = cnum - 1;
            ///
            return this._items[pv];
        }
    }
    CZMAP.ContinuousColorTable = ContinuousColorTable;
    function createColorCanvas(colorNum) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = colorNum;
        canvas.height = 1;
        return ctx;
    }
    function bytes2CssColor(rgba) {
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
    }
    function cssColor2Bytes(color) {
        const ctx = createColorCanvas(1);
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, 1, 1);
        ///
        const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
        ///
        return [r, g, b, a];
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const DefualtOption = {
        offset: [0, 0, 0],
        scale: [1, 1, 1],
        lineColor: 'white',
        lineWidth: 2,
        pointColor: 'white',
        pointSize: 10,
        textColor: 'red',
        textFont: '16px sans-serif'
    };
    class CoordGridBuild {
        constructor() {
            this._fixedNum = [];
            this.lines = [];
            this.points = [];
        }
        build(option) {
            this.lines.length = 0;
            this.points.length = 0;
            ///
            option = Object.assign({}, DefualtOption, option);
            ///
            this._dataBox = option.dataBox;
            if (!CZMAP.defined(this._dataBox)) {
                this._dataBox = new CZMAP.BoundingBox();
                this._dataBox.setMin(option.min);
                this._dataBox.setMax(option.max);
            }
            ///
            this._dispBox = option.displayBox || this._dataBox;
            ///
            this._dmin = this._dataBox.getMin();
            this._dsiz = this._dataBox.getSize();
            this._pmin = this._dispBox.getMin();
            this._psiz = this._dispBox.getSize();
            this.option = option;
            this.center = Cesium.Cartesian3.fromDegrees(...this._dispBox.getCenter());
            /// 
            const db = this._dataBox;
            ///
            const stepx = option.stepx ? _NormalStep(db.minx, db.maxx, option.stepx) : _GetStepNumb(db.minx, db.maxx);
            const stepy = option.stepy ? _NormalStep(db.miny, db.maxy, option.stepy) : _GetStepNumb(db.miny, db.maxy);
            const stepz = option.stepz ? _NormalStep(db.minz, db.maxz, option.stepz) : _GetStepNumb(db.minz, db.maxz);
            ///
            const xSteps = computeMiddleSpacing(db.minx, db.maxx, stepx);
            const ySteps = computeMiddleSpacing(db.miny, db.maxy, stepy);
            const zSteps = computeMiddleSpacing(db.minz, db.maxz, stepz);
            /// 
            function calcFixedNum(step, fixed) {
                if (CZMAP.defined(fixed))
                    return fixed;
                let num = 0;
                while (step < 1) {
                    step *= 10;
                    num++;
                }
                return num;
            }
            this._fixedNum[0] = calcFixedNum(stepx, option.fixedNumX);
            this._fixedNum[1] = calcFixedNum(stepy, option.fixedNumY);
            this._fixedNum[2] = calcFixedNum(stepz, option.fixedNumZ);
            ///
            this._lineAxis(xSteps, ySteps, zSteps, [0, 1, 2], [20, 20]);
            this._lineAxis(ySteps, xSteps, zSteps, [1, 0, 2], [-40, 20]);
            this._lineAxis(zSteps, xSteps, ySteps, [2, 0, 1], [-40, 0]);
            /// 
            return this;
        }
        _lineAxis(steps0, steps1, steps2, axis, offset) {
            const [axis0, axis1, axis2] = axis;
            const start0 = this._dataBox.getMin(), start1 = [0, 0, 0];
            steps0.forEach(step0 => {
                const line1 = steps1.map(step1 => {
                    start1[axis0] = start0[axis0] + step0;
                    start1[axis1] = start0[axis1] + step1;
                    start1[axis2] = start0[axis2];
                    this._getRealValue(start1, start1);
                    return Cesium.Cartesian3.fromDegrees(...start1);
                });
                const line2 = steps2.map(step2 => {
                    start1[axis0] = start0[axis0] + step0;
                    start1[axis1] = start0[axis1];
                    start1[axis2] = start0[axis2] + step2;
                    this._getRealValue(start1, start1);
                    return Cesium.Cartesian3.fromDegrees(...start1);
                });
                let lines;
                if (line1.length === 0) {
                    lines = line2;
                }
                else if (line2.length === 0) {
                    lines = line1;
                }
                else {
                    line2.reverse();
                    line2.length = line2.length - 1;
                    lines = line2.concat(line1);
                }
                this.lines.push({
                    value: step0,
                    positions: lines
                });
                start1[axis0] = start0[axis0] + step0;
                start1[axis1] = start0[axis1];
                start1[axis2] = start0[axis2];
                const ss = this._getRealValue(start1);
                const pos = Cesium.Cartesian3.fromDegrees(...ss);
                const labeltext = (start1[axis0]).toFixed(this._fixedNum[axis0]);
                this.points.push({
                    text: labeltext,
                    position: pos,
                    pixelOffset: offset
                });
            });
        }
        _getRealValue(v, r) {
            r = r || [0, 0, 0];
            for (let i = 0; i < 3; ++i) {
                r[i] = (v[i] - this._dmin[i]) / this._dsiz[i] * this._psiz[i] + this._pmin[i];
            }
            return r;
        }
    }
    CZMAP.CoordGridBuild = CoordGridBuild;
    function computeMiddleSpacing(min, max, step) {
        let arr = [], spacing = max - min;
        const count = Math.floor(spacing / step);
        for (let i = 0; i <= count; i++) {
            arr.push(step * i);
        }
        if (spacing % step !== 0) { //不是整除的时候 添加差值
            arr.push(spacing);
        }
        return arr;
    }
    function _NormalStep(min, max, step) {
        const diff = Math.abs(max - min);
        while (diff / step > 10) {
            step *= 10;
        }
        return step;
    }
    function _GetStepNumb(sfDat, efDat) {
        const length = efDat - sfDat;
        // fix by zz 解决 <=0 时的死循环问题 [12/2/2009 Monster]
        if (length <= 0)
            return 1;
        let step = length / 5;
        let scale = 1.0;
        let intPart = 0;
        if (step > 10.0) {
            while (step > 10.0) {
                scale *= 10;
                step /= 10;
            }
            ///
            intPart = Math.floor(step);
            return intPart * scale;
        }
        else if (step < 1.0) {
            while (step < 1.0) {
                scale *= 10;
                step *= 10;
            }
            ///
            intPart = Math.floor(step);
            return intPart / scale;
        }
        else {
            intPart = Math.floor(step);
            return intPart;
        }
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let DynamicDataType;
    (function (DynamicDataType) {
        DynamicDataType["ARRAY_BUFFER"] = "arraybuffer";
        DynamicDataType["JSON"] = "json";
        DynamicDataType["TEXT"] = "text";
        DynamicDataType["XML"] = "xml";
    })(DynamicDataType = CZMAP.DynamicDataType || (CZMAP.DynamicDataType = {}));
    class DynamicItem {
        ///
        constructor(url, type, interval) {
            ///
            this.handles = new Set();
            this.url = url;
            this.type = type;
            this.interval = interval;
        }
        /// 
        start() {
            const h1 = () => {
                this.loop(h2);
            };
            const h2 = () => {
                this.timer = setTimeout(h1, this.interval);
            };
            h2();
        }
        stop() {
            ///
            this.handles.clear();
            ///
            if (this.timer) {
                clearTimeout(this.timer);
                this.timer = undefined;
            }
        }
        /// 
        add(handle) {
            this.handles.add(handle);
        }
        /// 
        remove(handle) {
            this.handles.delete(handle);
        }
        isEmpty() { return this.handles.size === 0; }
        /// 
        loop(finish) {
            CZMAP.HttpUtil.get(new CZMAP.HttpArgs(this.url))
                .then(e => {
                switch (this.type) {
                    case DynamicDataType.ARRAY_BUFFER:
                        return e.arrayBuffer();
                    case DynamicDataType.JSON:
                        return e.json();
                    case DynamicDataType.TEXT:
                        return e.text();
                }
            }, () => {
                console.warn("load dyndata error");
            })
                .then(e => {
                if (e)
                    this.handles.forEach(h => h(e));
            }, (e) => {
                console.warn("update dynamic data error", e);
            })
                .then(finish, finish);
        }
    }
    class DynamicData {
        ///
        constructor() {
            /// 
            this._urls = new Map();
        }
        reg(url, handle, type = DynamicDataType.JSON, interval = 10000) {
            this.get(url, type, interval, true).add(handle);
        }
        unReg(url, handle, type = DynamicDataType.JSON, interval = 100000) {
            const item = this.get(url, type, interval, false);
            if (item) {
                item.remove(handle);
                if (item.isEmpty()) {
                    item.stop();
                    this._urls.delete(item.key);
                }
            }
        }
        unRegAll() {
            this._urls.forEach(item => item.stop());
            this._urls.clear();
        }
        /**
         *
         * @param {*} url
         * @param {*} create
         * @return {Array}
         */
        get(url, type, interval, create = false) {
            const key = `${url} + ${interval} + ${type}`;
            let prop;
            if (this._urls.has(key))
                prop = this._urls.get(key);
            else if (create) {
                prop = new DynamicItem(url, type, interval);
                prop.key = key;
                prop.start();
                this._urls.set(key, prop);
            }
            ///
            return prop;
        }
    }
    CZMAP.DynamicData = DynamicData;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class EventTargetHelper {
        get enable() { return this._enable; }
        set enable(enable) { this._enable = enable; }
        constructor(target) {
            this._enable = true;
            this._events = [];
            this.setTarget(target);
        }
        setTarget(target) {
            this._target = target;
        }
        on(type, listener, options) {
            if (!this._target) {
                console.warn('no target!');
                return;
            }
            ///
            const eventName = type;
            const callback = (e) => {
                if (!this._enable)
                    return;
                if (e.target !== this._target)
                    return;
                listener(e);
            };
            ///
            this._target.addEventListener(eventName, callback, options);
            this._events.push({
                type: eventName,
                unbind: () => this._target.removeEventListener(eventName, callback, options)
            });
        }
        un(type) {
            let change = false;
            this._events.forEach(e => {
                if (e.type === type) {
                    change = true;
                    e.unbind();
                }
            });
            if (change)
                this._events = this._events.filter(e => e.type !== type);
        }
        unAll() {
            this._events.forEach(e => e.unbind());
            this._events.length = 0;
        }
    }
    CZMAP.EventTargetHelper = EventTargetHelper;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class GeoMath {
        static checkPoint(pt) {
            while (pt.length < 3) {
                pt.push(0);
            }
        }
        /** 复制点 */
        static clone(p, r) {
            if (r) {
                r[0] = p[0];
                r[1] = p[1];
                r[2] = p[2];
                return r;
            }
            return p.slice();
        }
        /**
         * 两个点相加
         * @param a
         * @param b
         * @param r
         */
        static add(a, b, r) {
            if (!r)
                r = [0, 0, 0];
            r[0] = a.x + b.x;
            r[1] = a.y + b.y;
            r[2] = a.z + b.z;
            return r;
        }
        /**
         * 两个点相减
         * @param a
         * @param b
         * @param r
         */
        static sub(a, b, r) {
            if (!r)
                r = [0, 0, 0];
            r[0] = a.x - b.x;
            r[1] = a.y - b.y;
            r[2] = a.z - b.z;
            return r;
        }
        static mul(a, b, r) {
            if (!r)
                r = [0, 0, 0];
            r[0] = a.x * b.x;
            r[1] = a.y * b.y;
            r[2] = a.z * b.z;
            return r;
        }
        static mulScalar(a, b, r) {
            if (!r)
                r = [0, 0, 0];
            r[0] = a.x * b;
            r[1] = a.y * b;
            r[2] = a.z * b;
            return r;
        }
        static div(a, b, r) {
            if (!r)
                r = [0, 0, 0];
            r[0] = a.x / b.x;
            r[1] = a.y / b.y;
            r[2] = a.z / b.z;
            return r;
        }
        /** 计算两点的立方距离 */
        static squareDistance(a, b) {
            const x = a.x - b.x;
            const y = a.y - b.y;
            const z = a.z - b.z;
            return x * x + y * y + z * z;
        }
        /** 计算两点的距离 */
        static distance(a, b) {
            return Math.sqrt(GeoMath.squareDistance(a, b));
        }
        /** 计算向量的立方长度 */
        static squareLength(pt) {
            const x = pt.x;
            const y = pt.y;
            const z = pt.z;
            return x * x + y * y + z * z;
        }
        /** 计算向量的长度 */
        static calcLength(pt) {
            return Math.sqrt(GeoMath.squareLength(pt));
        }
        /**
         * 笛卡尔坐标转地理坐标
         * @param pt 笛卡尔坐标
         * @returns 地理坐标
         */
        static fromCartesian3(pt, result) {
            const ca = Cesium.Cartographic.fromCartesian(pt, undefined, this.tempCartographic);
            if (result) {
                result[0] = Cesium.Math.toDegrees(ca.longitude);
                result[1] = Cesium.Math.toDegrees(ca.latitude);
                result[2] = ca.height;
                return result;
            }
            else {
                return [
                    Cesium.Math.toDegrees(ca.longitude),
                    Cesium.Math.toDegrees(ca.latitude),
                    ca.height
                ];
            }
        }
        static isEquals(p0, p1) {
            if (!p0 || !p1)
                return p0 === p1;
            return p0 === p1 || (p0[0] === p1[0] && p0[1] == p1[1]);
        }
        ;
    }
    GeoMath.tempCartographic = new Cesium.Cartographic();
    CZMAP.GeoMath = GeoMath;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const MAXID = 9999999999999;
    const OUTID = MAXID + 1;
    const ss = { x: 0, y: 1, z: 22, ssf: 223 };
    function squareDistance(a, b) {
        const x = a.x - b.x;
        const y = a.y - b.y;
        const z = a.z - b.z;
        return x * x + y * y + z * z;
    }
    class Node {
        constructor(pt, id, next) {
            this.mPoint = pt;
            this.mID = id;
            this.mNext = next;
        }
    }
    ;
    class PointIterator {
        constructor(nodes, heads) {
            this.mNodes = (nodes);
            this.mHeads = (heads);
            this.mNextGrid = (0);
            this.mNextNode = (-1);
        }
        reset() {
            this.mNextGrid = 0;
            this.mNextNode = -1;
        }
        next() {
            if (this.mNextNode == -1 && this.mNextGrid < this.mHeads.length) {
                this.mNextNode = this.mHeads[this.mNextGrid++];
            }
            /// 
            let node;
            if (this.mNextNode != -1) {
                node = this.mNodes[this.mNextNode];
                this.mNextNode = node.mNext;
            }
            /// 
            return node;
        }
        find(pt, t) {
            const qt = t * t;
            this.reset();
            let node;
            let fnode;
            let qdist = Number.MAX_VALUE;
            while (node = this.next()) {
                const qd = squareDistance(pt, node.mPoint);
                if (qd < qdist) {
                    qdist = qd;
                    fnode = node;
                }
            }
            if (fnode && squareDistance(fnode.mPoint, pt) < qt) {
                return fnode;
            }
            ///
            return;
        }
    }
    ;
    class ExistAddResult {
        constructor(id, exist) {
            this.id = id;
            this.exist = exist;
        }
    }
    CZMAP.ExistAddResult = ExistAddResult;
    class GridPointMap {
        /// 
        constructor(tolerance = 1e-6) {
            ///
            this.mNodes = [];
            this.mGrids = new Map();
            this.setTolerance(tolerance);
        }
        /// 设置精度误差值，该操作会清除所有点
        setTolerance(tolerance = 1e-6) {
            this.mTolerance = tolerance;
            this.mCellSize = tolerance * 10;
            this.mNodes.length = 0;
            this.mGrids.clear();
        }
        /// 
        add(pt) {
            /// 
            let isExist = false;
            const grids = [];
            const key = this.calcIndex(pt.x, pt.y, grids);
            ///
            const it = new PointIterator(this.mNodes, grids);
            let fnode = it.find(pt, this.mTolerance);
            if (fnode) {
                return new ExistAddResult(fnode.mID, true);
            }
            ///
            const ifind = this.mGrids.get(key);
            if (CZMAP.defined(ifind))
                fnode = this.mNodes[ifind];
            const node = new Node(pt, this.mNodes.length, fnode ? fnode.mID : -1);
            /// 
            this.mNodes.push(node);
            this.mGrids.set(key, node.mID);
            ///
            return new ExistAddResult(node.mID, false);
        }
        add2(x, y, z) {
            return this.add({ x, y, z });
        }
        /// 获取点索引
        find(pt) {
            const grids = [];
            this.calcIndex(pt.x, pt.y, grids);
            ///
            const it = new PointIterator(this.mNodes, grids);
            const fnode = it.find(pt, this.mTolerance);
            if (fnode) {
                return fnode.mID;
            }
            return -1;
        }
        find2(x, y) {
            return this.find({ x, y, z: 0 });
        }
        /// 
        getPoints() {
            return this.mNodes.map(n => n.mPoint);
        }
        getPoint(index) {
            return this.mNodes[index].mPoint;
        }
        /// 
        clear() {
            this.mGrids.clear();
            this.mNodes.length = 0;
        }
        /// 
        calcKey(x, y) {
            const fx = (x - 0) / this.mCellSize;
            const fy = (y - 0) / this.mCellSize;
            let kx = Math.ceil(fx);
            let ky = Math.ceil(fy);
            if (fx > MAXID || fx < -MAXID)
                kx = OUTID;
            if (fy > MAXID || fy < -MAXID)
                ky = OUTID;
            ///
            return `${kx.toString(16)}-${ky.toString(16)}`;
        }
        calcIndex(x, y, heads) {
            const fx = (x - 0) / this.mCellSize;
            const fy = (y - 0) / this.mCellSize;
            let nx = Math.ceil(fx);
            let ny = Math.ceil(fy);
            if (fx > MAXID || fx < -MAXID)
                nx = OUTID;
            if (fy > MAXID || fy < -MAXID)
                ny = OUTID;
            /// 
            const key = `${nx.toString(16)}-${ny.toString(16)}`;
            ///
            if ((fx - nx) < 0.5)
                nx -= 1;
            if ((fy - ny) < 0.5)
                ny -= 1;
            /// 
            this.addGrid(nx, ny, heads);
            this.addGrid(nx + 1, ny, heads);
            this.addGrid(nx, ny + 1, heads);
            this.addGrid(nx + 1, ny + 1, heads);
            //size_t
            return key;
        }
        /// 
        addGrid(nx, ny, heads) {
            const key = `${(nx).toString(16)}-${(ny).toString(16)}`;
            const ifind = this.mGrids.get(key);
            if (!CZMAP.defined(ifind))
                return;
            /// 
            heads.push(ifind);
        }
    }
    CZMAP.GridPointMap = GridPointMap;
    ;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class HttpArgs {
        constructor(url, data = undefined) {
            this.url = url;
            this.data = data;
        }
    }
    CZMAP.HttpArgs = HttpArgs;
    class HttpUtil {
        static _getCookiesObj() {
            return document.cookie.split(';').reduce((f, sv) => {
                let _sv = sv.trim().split('=').map(v => {
                    return v.trim();
                });
                f[_sv[0]] = _sv[1];
                return f;
            }, {});
        }
        static _initOptions(options = undefined) {
            let _options = options;
            if (!CZMAP.Types.isDefined(_options)) {
                _options = {};
            }
            const _cookie = this._getCookiesObj();
            if (CZMAP.Types.isDefined(_cookie)) {
                _options.headers = {};
                if (CZMAP.Types.isDefined(_cookie.orgid)) {
                    _options.headers['orgid'] = _cookie.orgid;
                }
                if (CZMAP.Types.isDefined(_cookie.domain)) {
                    _options.headers['Domain'] = _cookie.domain;
                }
                if (CZMAP.Types.isDefined(_cookie.accept_domain)) {
                    _options.headers['AcceptDomain'] = _cookie.accept_domain;
                }
                if (CZMAP.Types.isDefined(_cookie.user_token)) {
                    _options.headers['UserId'] = _cookie.user_token;
                }
                if (CZMAP.Types.isDefined(_cookie.person_token)) {
                    _options.headers['person_token'] = _cookie.person_token;
                }
            }
            _options.mode = 'cors'; // 默认跨域请求
            return _options;
        }
        static get(args, options = undefined) {
            const _options = this._initOptions(options);
            return fetch(args.url, _options);
        }
        static post(args, options = undefined) {
            let _options = this._initOptions(options);
            _options.method = 'POST';
            _options.headers['Accept'] = 'application/json';
            _options.headers['Content-Type'] = 'application/json';
            if (args.data)
                _options.body = JSON.stringify(args.data);
            ///
            return fetch(args.url, _options);
        }
        static put(args, options = undefined) {
            let _options = this._initOptions(options);
            _options.method = 'PUT';
            _options.headers['Accept'] = 'application/json';
            _options.headers['Content-Type'] = 'application/json';
            if (args.data)
                _options.body = JSON.stringify(args.data);
            return fetch(args.url, _options);
        }
    }
    CZMAP.HttpUtil = HttpUtil;
    async function fetchJSON(input, init) {
        const resp = await fetch(input, init);
        return await resp.json();
    }
    CZMAP.fetchJSON = fetchJSON;
    async function fetchJSON5(input, init) {
        const resp = await fetch(input, init);
        const text = await resp.text();
        const func = new Function("const json5 = \n" + text + ";\n return json5;");
        return func();
    }
    CZMAP.fetchJSON5 = fetchJSON5;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    class SearchRange {
        constructor(left, right, axis) {
            this.axis = (axis);
            this.right = (right);
            this.left = (left);
        }
    }
    ;
    function distance(a, b) {
        const x = a[0] - b[0];
        const y = a[1] - b[1];
        return x * x + y * y;
    }
    class KDBush {
        constructor() {
            this.mNodeSize = 64;
            this.mIDs = [];
        }
        init(pts, nodeSize = 64) {
            this.mNodeSize = nodeSize;
            this.mIDs.length = pts.length;
            this.mCoords = pts.slice();
            const count = pts.length;
            for (let i = 0; i < count; ++i) {
                this.mIDs[i] = i;
            }
            // kd-sort both arrays for efficient search (see comments in sort.js)
            this.sort(0, count - 1, 0);
        }
        get points() { return this.mCoords; }
        nearest(x, y, to) {
            let result = -1;
            let minDistance = Number.MAX_VALUE;
            const ct = [x, y];
            this.search([x - to, y - to, x + to, y + to], (pt, id) => {
                const dist = distance(ct, pt);
                if (dist < minDistance) {
                    minDistance = dist;
                    result = id;
                }
            });
            return result;
        }
        range(extent) {
            const result = [];
            this.search(extent, (pt, id) => result.push(id));
            return result;
        }
        search(env, result) {
            const stack = [];
            stack.push(new SearchRange(0, this.mIDs.length - 1, 0));
            // recursively search for items in range in the kd-sorted arrays
            while (stack.length) {
                const st = stack.last();
                stack.pop();
                const axis = st.axis;
                const right = st.right;
                const left = st.left;
                // if we reached "tree node", search linearly
                if (right - left <= this.mNodeSize) {
                    for (let i = left; i <= right; i++) {
                        const pt = this.mCoords[i];
                        if (CZMAP.Extents.containsXY(env, pt[0], pt[1]))
                            result(pt, this.mIDs[i]);
                    }
                    continue;
                }
                // otherwise find the middle index
                const m = (left + right) >> 1;
                // include the middle item if it's in range
                const pt = this.mCoords[m];
                if (CZMAP.Extents.containsXY(env, pt[0], pt[1]))
                    result(pt, this.mIDs[m]);
                // queue search in halves that intersect the query
                if (axis == 0 ? env[0] <= pt[0] : env[1] <= pt[1]) {
                    stack.push(new SearchRange(left, m - 1, 1 - axis));
                }
                if (axis == 0 ? env[2] >= pt[0] : env[3] >= pt[1]) {
                    stack.push(new SearchRange(m + 1, right, 1 - axis));
                }
            }
        }
        sort(left, right, axis) {
            if (right - left <= this.mNodeSize)
                return;
            const m = (left + right) >> 1; // middle index
            // sort ids and coords around the middle index so that the halves lie
            // either left/right or top/bottom correspondingly (taking turns)
            this.select(m, left, right, axis);
            // recursively kd-sort first half and second half on the opposite axis
            this.sort(left, m - 1, 1 - axis);
            this.sort(m + 1, right, 1 - axis);
        }
        select(k, left, right, axis) {
            while (right > left) {
                if (right - left > 600) {
                    const n = right - left + 1;
                    const m = k - left + 1;
                    const z = Math.log(n);
                    const s = 0.5 * Math.exp(2 * z / 3);
                    const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                    const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                    const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                    this.select(k, newLeft, newRight, axis);
                }
                const t = this.mCoords[k][axis];
                let i = left;
                let j = right;
                this.swapItem(left, k);
                if (this.mCoords[right][axis] > t)
                    this.swapItem(left, right);
                while (i < j) {
                    this.swapItem(i, j);
                    i++;
                    j--;
                    while (this.mCoords[i][axis] < t)
                        i++;
                    while (this.mCoords[j][axis] > t)
                        j--;
                }
                if (this.mCoords[left][axis] == t)
                    this.swapItem(left, j);
                else {
                    j++;
                    this.swapItem(j, right);
                }
                if (j <= k)
                    left = j + 1;
                if (k <= j)
                    right = j - 1;
            }
        }
        swapItem(i, j) {
            swap(this.mIDs, i, j);
            swap(this.mCoords, i, j);
        }
    }
    CZMAP.KDBush = KDBush;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class MeasureDistanceResult {
        constructor() {
            /** 距离 */
            this.distance = 0;
            /** 水平距离 */
            this.flatDistance = 0;
            /** 最小高程 */
            this.minHeight = Number.MAX_VALUE;
            /** 最大高程 */
            this.maxHeight = -Number.MAX_VALUE;
            /** 垂直距离（高度） */
            this.height = 0;
        }
        updateHeight(value) {
            this.minHeight = Math.min(this.minHeight, value);
            this.maxHeight = Math.max(this.maxHeight, value);
            this.height = this.maxHeight - this.minHeight;
        }
        inc(added) {
            this.distance += added.distance;
            this.flatDistance += added.flatDistance;
            this.minHeight = Math.min(this.minHeight, added.minHeight);
            this.maxHeight = Math.max(this.maxHeight, added.maxHeight);
            this.height = this.maxHeight - this.minHeight;
            return this;
        }
    }
    CZMAP.MeasureDistanceResult = MeasureDistanceResult;
    ;
    class MeasureAreaResult {
        constructor(area) {
            /** 面积 */
            this.area = 0;
            this.area = area !== null && area !== void 0 ? area : 0;
        }
    }
    CZMAP.MeasureAreaResult = MeasureAreaResult;
    class MeasureAngleResult {
        constructor(heading, pitch) {
            this.heading = heading !== null && heading !== void 0 ? heading : 0;
            this.pitch = pitch !== null && pitch !== void 0 ? pitch : 0;
        }
    }
    CZMAP.MeasureAngleResult = MeasureAngleResult;
    class MeasureUtils {
        /**
         * 计算地球两点间的距离
         * @param p0 起点
         * @param p1 终点
         * @param ellipsold 椭球
         * @returns 距离信息
         */
        static computeDistance(p0, p1, ellipsold) {
            const c0 = Cesium.Cartographic.fromDegrees(...p0);
            const c1 = Cesium.Cartographic.fromDegrees(...p1);
            const eg = new Cesium.EllipsoidGeodesic(c0, c1, ellipsold);
            const step = eg.ellipsoid.maximumRadius * Cesium.Math.toRadians(1);
            let interpNum = Math.round(eg.surfaceDistance / step);
            if (interpNum == 0)
                interpNum = 1;
            const result = new MeasureDistanceResult();
            result.flatDistance = eg.surfaceDistance;
            let lastCart = Cesium.Cartographic.clone(c0);
            let lastC3 = Cesium.Cartographic.toCartesian(c0, eg.ellipsoid);
            result.updateHeight(lastCart.height);
            const intC3 = new Cesium.Cartesian3();
            const intCart = new Cesium.Cartographic();
            for (let i = 1; i <= interpNum; ++i) {
                const cen = i / interpNum;
                eg.interpolateUsingFraction(cen, intCart);
                intCart.height = Cesium.Math.lerp(c0.height, c1.height, cen);
                Cesium.Cartographic.toCartesian(intCart, eg.ellipsoid, intC3);
                ///
                result.updateHeight(intCart.height);
                result.distance += Cesium.Cartesian3.distance(intC3, lastC3);
                intCart.clone(lastCart);
                intC3.clone(lastC3);
            }
            return result;
        }
        /**
         * 计算线的总长度
         * @param pts 线
         * @returns 距离信息
         */
        static computeDistances(pts) {
            if (pts.length < 1)
                throw new Error('pts length must > 1');
            let last = pts[0];
            const result = new MeasureDistanceResult();
            for (let i = 1; i < pts.length; ++i) {
                result.inc(MeasureUtils.computeDistance(last, pts[i]));
                last = pts[i];
            }
            ///
            return result;
        }
        /**
         * 计算点的中心点坐标
         * @param pts 点列表
         * @returns 中心点
         */
        static computeCenter(pts) {
            if (!pts.length) {
                throw new Error('not array or array length == 0');
            }
            const last = pts[0];
            const mid = new Cesium.Cartesian3();
            const min = new Cesium.Cartesian3(...last);
            const max = new Cesium.Cartesian3(...last);
            for (let i = 1; i < pts.length; ++i) {
                const [x, y, z] = pts[i];
                Cesium.Cartesian3.fromElements(x, y, z, mid);
                Cesium.Cartesian3.minimumByComponent(min, mid, min);
                Cesium.Cartesian3.maximumByComponent(max, mid, max);
            }
            Cesium.Cartesian3.midpoint(min, max, mid);
            return [mid.x, mid.y, mid.z];
        }
        /**
         * 自动格式化距离信息
         * @param distance 距离
         * @returns
         */
        static formatDistances(distance) {
            if (distance > 1000) {
                return (distance / 1000).toFixed(2) + '千米';
            }
            else {
                return distance.toFixed(2) + '米';
            }
        }
        static computeArea(pts) {
            const area = Math.abs(CZMAP.Math2D.PolygonArea(pts)) * (111000 * 111000);
            return new MeasureAreaResult(area);
        }
        /**
         * 计算平面面积
         * @param pts
         */
        static computeFlatArea(pts) {
            return 0;
        }
        /**
         * 自动格式化面积信息
         * @param distance 距离
         * @returns
         */
        static formatAreas(area) {
            if (area > 1000000) {
                return (area / 1000000).toFixed(2) + '平方千米';
            }
            else {
                return area.toFixed(2) + '平方米';
            }
        }
        static computeAngle(p0, p1) {
            return computeAngle(p0, p1);
        }
    }
    CZMAP.MeasureUtils = MeasureUtils;
    const cp_p0 = new Cesium.Cartesian3();
    const cp_p1 = new Cesium.Cartesian3();
    const cp_matrix = new Cesium.Matrix4();
    function computeAngle(p0, p1) {
        const c0 = Cesium.Cartesian3.fromDegrees(...p0, undefined, cp_p0);
        const c1 = Cesium.Cartesian3.fromDegrees(...p1, undefined, cp_p1);
        const transform = Cesium.Transforms.eastNorthUpToFixedFrame(c0, Cesium.Ellipsoid.WGS84, cp_matrix);
        Cesium.Matrix4.inverseTransformation(transform, transform);
        Cesium.Matrix4.multiplyByPoint(transform, c1, c1);
        const rr = Math.sqrt(c1.x * c1.x + c1.y * c1.y);
        const heading = 90 - Cesium.Math.toDegrees(Math.atan2(c1.y, c1.x));
        const pitch = Cesium.Math.toDegrees(Math.atan2(c1.z, rr));
        return new MeasureAngleResult(heading, pitch);
    }
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function toPoint(c, isGeographical = true) {
        if (isGeographical) {
            const ca = Cesium.Cartographic.fromCartesian(c);
            return [
                Cesium.Math.toDegrees(ca.longitude),
                Cesium.Math.toDegrees(ca.latitude),
                ca.height
            ];
        }
        else {
            return [c.x, c.y, c.z];
        }
    }
    function toCartesian3(pt, isGeographical = true) {
        return isGeographical ? Cesium.Cartesian3.fromDegrees(...pt) : Cesium.Cartesian3.fromElements(...pt);
    }
    function hpd2Offset(dist, heading, pitch) {
        const rp = Cesium.Math.toRadians(pitch || 0);
        const rh = Cesium.Math.toRadians(90 - heading || 0);
        const offz = Math.sin(rp) * dist;
        const offr = Math.cos(rp) * dist;
        const offx = Math.cos(rh) * offr;
        const offy = Math.sin(rh) * offr;
        return [offx, offy, offz];
    }
    /**
     * 投影向量
     * @param v0
     * @param v1
     * @returns
     */
    function projectVector(v0, v1, result) {
        const dot = Cesium.Cartesian3.dot(v0, v1);
        const sl = Cesium.Cartesian3.magnitudeSquared(v0);
        return Cesium.Cartesian3.multiplyByScalar(v0, dot / sl, result);
    }
    /**
     * 投影点
     * @param a
     * @param b
     * @param p
     * @returns
     */
    function projectCartesian(a, b, p, result) {
        /// 计算向量
        const v0 = Cesium.Cartesian3.subtract(b, a, project_t1);
        const v1 = Cesium.Cartesian3.subtract(p, a, project_t2);
        /// 投影向量
        const pv = projectVector(v0, v1, result);
        /// 计算目标点
        return Cesium.Cartesian3.add(pv, a, pv);
    }
    CZMAP.projectCartesian = projectCartesian;
    const project_t1 = new Cesium.Cartesian3();
    const project_t2 = new Cesium.Cartesian3();
    /**
     * 计算点在线段（延长线）上的投影
     * @param p0 线段端点1
     * @param p1 线段端点2
     * @param t 要投影的点
     * @param isGeographical 是否经纬度数据
     * @returns 投影后的点
     */
    function projectPoint(p0, p1, t, isGeographical = true) {
        const a = toCartesian3(p0, isGeographical);
        const b = toCartesian3(p1, isGeographical);
        const p = toCartesian3(t, isGeographical);
        ///
        const pv = projectCartesian(a, b, p, new Cesium.Cartesian3());
        return toPoint(pv, isGeographical);
    }
    CZMAP.projectPoint = projectPoint;
    /**
     * 查找距离点最近的线段
     * @param pts
     * @param t
     * @returns
     */
    function findNearestLine(pts, t) {
        const mid = [];
        for (let i = 1; i < pts.length; ++i) {
            const p0 = pts[i - 1];
            const p1 = pts[i];
            let position = projectCartesian(p0, p1, t, new Cesium.Cartesian3());
            const d = Cesium.Cartesian3.distanceSquared(p0, p1);
            const d0 = Cesium.Cartesian3.distanceSquared(position, p0);
            const d1 = Cesium.Cartesian3.distanceSquared(position, p1);
            if (d0 > d || d1 > d) {
                if (d0 > d1) {
                    p1.clone(position);
                }
                else {
                    p0.clone(position);
                }
            }
            mid.push({ i0: i - 1, i1: i, position, distance: Cesium.Cartesian3.distanceSquared(t, position) });
        }
        mid.sort((v0, v1) => v0.distance - v1.distance);
        return mid[0];
    }
    CZMAP.findNearestLine = findNearestLine;
    /**
     * 使用两个点截断折线
     * @param pts 折线
     * @param p0 点1
     * @param p1 点2
     * @param isGeographical 是否经纬数据
     * @returns 截断后的线段
     */
    function cutLinesByTwoPoints(pts, p0, p1, isGeographical = true) {
        const cats = pts.map(p => toCartesian3(p, isGeographical));
        const c0 = toCartesian3(p0, isGeographical);
        const c1 = toCartesian3(p1, isGeographical);
        let t0 = findNearestLine(cats, c0);
        let t1 = findNearestLine(cats, c1);
        if (t0.i1 > t1.i1) {
            const t = t0;
            t0 = t1;
            t1 = t;
        }
        const results = [];
        results.push(toPoint(t0.position, isGeographical));
        for (let i = t0.i1; i < t1.i1; ++i) {
            results.push(toPoint(cats[i], isGeographical));
        }
        results.push(toPoint(t1.position, isGeographical));
        ///
        return results;
    }
    CZMAP.cutLinesByTwoPoints = cutLinesByTwoPoints;
    /**
     * 在线段上均匀布设
     * @param p0 起点
     * @param p1 终点
     * @param dist 布设距离
     * @param isGeographical 是否经纬度
     * @returns 布设点坐标列表
     */
    function putOnLine(p0, p1, dist, isGeographical = true) {
        const c0 = toCartesian3(p0, isGeographical);
        const c1 = toCartesian3(p1, isGeographical);
        const dir = Cesium.Cartesian3.subtract(c1, c0, new Cesium.Cartesian3());
        const magnitude = Cesium.Cartesian3.magnitude(dir);
        if (magnitude == 0) {
            throw new Error("输入点和输出点位置相同");
        }
        if (dist <= 0) {
            throw new Error("参数：dist值不能小于等于0");
        }
        dir.x = dir.x / magnitude;
        dir.y = dir.y / magnitude;
        dir.z = dir.z / magnitude;
        let offset = 0;
        const reuslt = [];
        while (offset < magnitude) {
            const t = new Cesium.Cartesian3();
            Cesium.Cartesian3.multiplyByScalar(dir, offset, t);
            Cesium.Cartesian3.add(c0, t, t);
            reuslt.push(toPoint(t, isGeographical));
            offset += dist;
        }
        return reuslt;
    }
    CZMAP.putOnLine = putOnLine;
    /**
     * 在这线上均匀布设点位
     * @param pts 输入折线坐标数组
     * @param dist 布设间距
     * @param isGeographical 是否经纬度数据
     * @returns 布设点坐标列表
     */
    function putOnLines(pts, dist, isGeographical = true) {
        if (dist <= 0) {
            throw new Error("参数：dist值不能小于等于0");
        }
        let current = 0;
        const reuslt = [];
        const cts = pts.map(p => toCartesian3(p, isGeographical));
        for (let i = 1; i < cts.length; ++i) {
            const p0 = cts[i - 1];
            const p1 = cts[i];
            const length = Cesium.Cartesian3.distance(p0, p1);
            while (current < length) {
                const t = new Cesium.Cartesian3();
                Cesium.Cartesian3.lerp(p0, p1, current / length, t);
                reuslt.push(toPoint(t, isGeographical));
                current += dist;
            }
            if (current > length) {
                current -= length;
            }
        }
        return reuslt;
    }
    CZMAP.putOnLines = putOnLines;
    /**
     * 在线段上均匀布设点位
     * @param pts 输入折线坐标数组
     * @param num 布设树木
     * @param isGeographical 是否经纬度数据
     * @returns 布设点坐标列表
     */
    function putOnLinesByNum(pts, num, isGeographical = true) {
        if (num <= 1) {
            throw new Error("参数：dist值不能小于等于1");
        }
        // 
        const cts = pts.map(p => toCartesian3(p, isGeographical));
        // 计算线段长度和总长度
        let wholeLength = 0;
        const lengths = CZMAP.mapEachSegment(cts, (p0, p1) => {
            const length = Cesium.Cartesian3.distance(p0, p1);
            wholeLength += length;
            return length;
        });
        /// 计算布放间距
        const dist = wholeLength / (num - 1);
        let current = 0;
        const result = [];
        CZMAP.forEachSegment(cts, (p0, p1, i0) => {
            const length = lengths[i0];
            while (current < length) {
                const t = new Cesium.Cartesian3();
                Cesium.Cartesian3.lerp(p0, p1, current / length, t);
                result.push(toPoint(t, isGeographical));
                current += dist;
            }
            if (current > length) {
                current -= length;
            }
        });
        if (result.length != num) {
            result.push(pts.last());
        }
        return {
            points: result,
            length: wholeLength
        };
        //return result;
    }
    CZMAP.putOnLinesByNum = putOnLinesByNum;
    /**
     * 计算指定坐标附近指定偏移坐标
     * @param pt 目标点
     * @param ox 东西方向偏移
     * @param oy 南北方向偏移
     * @param oz 上下方向偏移
     * @param isGeographical 是否经纬度
     * @returns 偏移后的点
     */
    function calcOffsetPoint(pt, ox, oy, oz, isGeographical = true) {
        const off = Cesium.Cartesian3.fromElements(ox, oy, oz);
        if (isGeographical) {
            const pos = Cesium.Cartesian3.fromDegrees(...pt);
            const mat = Cesium.Transforms.eastNorthUpToFixedFrame(pos, Cesium.Ellipsoid.WGS84, new Cesium.Matrix4());
            const tar = Cesium.Matrix4.multiplyByPoint(mat, off, off);
            return toPoint(tar, isGeographical);
        }
        else {
            const [x, y, z] = pt;
            return [x + off.x, y + off.y, z + off.z];
        }
    }
    CZMAP.calcOffsetPoint = calcOffsetPoint;
    /**
     * 计算指定坐标附近指定偏移坐标
     * @param position 目标点
     * @param dist 偏移距离
     * @param heading 方位角（正北方向）
     * @param pitch 俯仰角
     * @param isGeographical 是否经纬度
     * @returns
     */
    function calcOffsetPoint2(position, dist, heading, pitch, isGeographical = true) {
        const offset = hpd2Offset(dist, heading, pitch);
        return calcOffsetPoint(position, ...offset, isGeographical);
    }
    CZMAP.calcOffsetPoint2 = calcOffsetPoint2;
    /**
     * 延线段方向计算线段终点偏移后坐标
     * @param p0 线段起点坐标
     * @param p1 线段终点坐标
     * @param ox 左右偏移
     * @param oy 前后偏移
     * @param oz 上下偏移
     * @param isGeographical 是否经纬度
     * @returns
     */
    function calcLineOffsetPoint(p0, p1, ox, oy, oz, isGeographical = true) {
        const sub = Cesium.Cartesian3.subtract;
        const mul2 = Cesium.Cartesian3.multiplyByScalar;
        const div2 = Cesium.Cartesian3.divideByScalar;
        const cross = Cesium.Cartesian3.cross;
        const normalize = Cesium.Cartesian3.normalize;
        const c0 = toCartesian3(p0, isGeographical);
        const c1 = toCartesian3(p1, isGeographical);
        const dir = sub(c1, c0, new Cesium.Cartesian3());
        const magnitude = Cesium.Cartesian3.magnitude(dir);
        if (magnitude == 0) {
            throw new Error("起点和终点的位置相同");
        }
        div2(dir, magnitude, dir);
        let unit_z = new Cesium.Cartesian3(0, 0, 1);
        if (isGeographical) {
            const mat = Cesium.Transforms.eastNorthUpToFixedFrame(c1, Cesium.Ellipsoid.WGS84, new Cesium.Matrix4());
            Cesium.Matrix4.multiplyByPointAsVector(mat, unit_z, unit_z);
        }
        const right = cross(dir, unit_z, new Cesium.Cartesian3());
        const up = cross(right, dir, new Cesium.Cartesian3());
        normalize(right, right);
        normalize(up, up);
        mul2(right, ox, right);
        mul2(dir, oy, dir);
        mul2(up, oz, up);
        c1.x += right.x + dir.x + up.x;
        c1.y += right.y + dir.y + up.y;
        c1.z += right.z + dir.z + up.z;
        return toPoint(c1, isGeographical);
    }
    CZMAP.calcLineOffsetPoint = calcLineOffsetPoint;
    /**
     * 延线段方向计算线段终点偏移后坐标
     * @param p0 线段起点坐标
     * @param p1 线段终点坐标
     * @param dist 偏移距离
     * @param heading 方位角（线段方向）
     * @param pitch 俯仰角（线段方向）
     * @param isGeographical 是否经纬度坐标
     * @returns
     */
    function calcLineOffsetPoint2(p0, p1, dist, heading, pitch, isGeographical = true) {
        const offset = hpd2Offset(dist, heading, pitch);
        return calcLineOffsetPoint(p0, p1, ...offset, isGeographical);
    }
    CZMAP.calcLineOffsetPoint2 = calcLineOffsetPoint2;
    function movePoint(p, dir, dist, result) {
        if (!result) {
            result = new Cesium.Cartesian3();
        }
        Cesium.Cartesian3.multiplyByScalar(dir, dist, result);
        Cesium.Cartesian3.add(p, result, result);
        return result;
    }
    /**
     * 计算偏移后的线条
     * @param pts 线条坐标
     * @param ox 横向偏移
     * @param oy 纵向偏移
     * @param isGeographical 是否经纬度坐标
     * @returns 偏移后的坐标
     */
    function calcLineOffset(pts, ox, oy, isGeographical = true) {
        const add = Cesium.Cartesian3.add;
        const sub = Cesium.Cartesian3.subtract;
        const mul2 = Cesium.Cartesian3.multiplyByScalar;
        const dot = Cesium.Cartesian3.dot;
        const cross = Cesium.Cartesian3.cross;
        const normalize = Cesium.Cartesian3.normalize;
        if (ox === 0 && oy === 0)
            return pts;
        const w = ox;
        const cats = pts.map(p => toCartesian3(p, isGeographical));
        const normals = CZMAP.mapEachSegment(cats, (c0, c1) => {
            const d = sub(c1, c0, new Cesium.Cartesian3());
            return normalize(d, d);
        });
        const mat = new Cesium.Matrix4();
        const v0 = new Cesium.Cartesian3();
        const v1 = new Cesium.Cartesian3();
        const vp = new Cesium.Cartesian3();
        const mid = [];
        mid.push(cats[0]);
        CZMAP.forEachSegment(normals, (n0, n1, i0) => {
            const c = cats[i0 + 1];
            const angle = Cesium.Cartesian3.angleBetween(n0, n1);
            if (isGeographical) {
                Cesium.Transforms.eastNorthUpToFixedFrame(c, Cesium.Ellipsoid.WGS84, mat);
                Cesium.Matrix4.inverse(mat, mat);
                Cesium.Matrix4.multiplyByPointAsVector(mat, n0, v0);
                Cesium.Matrix4.multiplyByPointAsVector(mat, n1, v1);
            }
            else {
                Cesium.Cartesian3.clone(n0, v0);
                Cesium.Cartesian3.clone(n1, v1);
            }
            const s = cross(v0, v1, vp).z >= 0 ? 1 : -1;
            const d = Math.tan(angle / 2) * w * s;
            const p0 = movePoint(c, n0, d);
            const p1 = movePoint(c, n1, (-d));
            mid.push(p0, p1);
        });
        mid.push(cats.last());
        const right = new Cesium.Cartesian3();
        const up = new Cesium.Cartesian3();
        const offset = new Cesium.Cartesian3();
        for (let i = 1; i < mid.length; i += 2) {
            const p0 = mid[i - 1];
            const p1 = mid[i];
            const dir = normals[(i >> 1)];
            let unit_z = new Cesium.Cartesian3(0, 0, 1);
            if (isGeographical) {
                Cesium.Transforms.eastNorthUpToFixedFrame(p0, Cesium.Ellipsoid.WGS84, mat);
                Cesium.Matrix4.multiplyByPointAsVector(mat, unit_z, unit_z);
            }
            cross(dir, unit_z, right);
            cross(right, dir, up);
            normalize(right, right);
            normalize(up, up);
            mul2(right, ox, right);
            mul2(up, oy, up);
            add(right, up, offset);
            add(p0, offset, p0);
            add(p1, offset, p1);
        }
        ///
        return mid.map(c => toPoint(c, isGeographical));
    }
    CZMAP.calcLineOffset = calcLineOffset;
    /**
     * 将地质模型坐标系下的数据变换为经纬度
     * @param modelLayer 模型图层
     * @param pts 坐标列表
     * @param srcSrs 源坐标系（模型坐标系）
     * @param distSrs 目标坐标系（经纬度）
     * @returns
     */
    function transformModelCoordinates(modelLayer, pts, srcSrs, distSrs) {
        return transformModelCoordinates2(modelLayer.position, pts, srcSrs, distSrs);
    }
    CZMAP.transformModelCoordinates = transformModelCoordinates;
    /**
     * 将地质模型坐标系下的数据变换为经纬度
     * @param position 模型位置
     * @param pts 坐标列表
     * @param srcSrs 源坐标系（模型坐标系）
     * @param distSrs 目标坐标系（经纬度）
     * @returns
     */
    function transformModelCoordinates2(position, pts, srcSrs, distSrs) {
        const [x, y, z] = position;
        const cart3 = Cesium.Cartesian3.fromDegrees(x, y, z);
        const center = CZMAP.Transforms.transformCoordinates([x, y, 0], distSrs || 'EPSG:4326', srcSrs);
        center[2] = z;
        ///
        const mat = Cesium.Transforms.eastNorthUpToFixedFrame(cart3, Cesium.Ellipsoid.WGS84, new Cesium.Matrix4());
        ///
        return pts.map(p => {
            p = CZMAP.GeoMath.sub(p, center);
            const offset = new Cesium.Cartesian3(...p);
            Cesium.Matrix4.multiplyByPoint(mat, offset, offset);
            return toPoint(offset);
        });
    }
    CZMAP.transformModelCoordinates2 = transformModelCoordinates2;
    /**
     * 经纬度坐标转模型本地坐标
     * @param modelLayer 模型图层
     * @param pts 坐标列表
     * @param srcSrs 原始坐标系（模型的坐标系）
     * @param distSrs 目标坐标系（经纬度）
     */
    function transformToModelCoordinates(modelLayer, pts, srcSrs, distSrs) {
        return transformToModelCoordinates2(modelLayer.position, pts, srcSrs, distSrs);
    }
    CZMAP.transformToModelCoordinates = transformToModelCoordinates;
    /**
     * 经纬度坐标转模型本地坐标
     * @param position 模型中心点坐标
     * @param pts 坐标列表
     * @param srcSrs 原始坐标系（模型的坐标系）
     * @param distSrs 目标坐标系（经纬度）
     */
    function transformToModelCoordinates2(position, pts, srcSrs, distSrs) {
        const [x, y, z] = position;
        const cart3 = Cesium.Cartesian3.fromDegrees(x, y, z);
        const center = CZMAP.Transforms.transformCoordinates([x, y, 0], srcSrs || 'EPSG:4326', distSrs);
        center[2] = z;
        ///
        const matrix = new Cesium.Matrix4();
        const offset = new Cesium.Cartesian3();
        Cesium.Transforms.eastNorthUpToFixedFrame(cart3, Cesium.Ellipsoid.WGS84, matrix);
        Cesium.Matrix4.inverseTransformation(matrix, matrix);
        return pts.map(p => {
            Cesium.Cartesian3.fromDegrees(...p, undefined, offset);
            Cesium.Matrix4.multiplyByPoint(matrix, offset, offset);
            return [offset.x + center[0], offset.y + center[1], offset.z + center[2]];
        });
    }
    CZMAP.transformToModelCoordinates2 = transformToModelCoordinates2;
    const temp_matrix = new Cesium.Matrix4();
    const temp_cartesian1 = new Cesium.Cartesian3();
    const temp_cartesian2 = new Cesium.Cartesian3();
    function calcTargetHeadingPitch(vi, target) {
        //const vi = this.getViewInfo();
        const pos = Cesium.Cartesian3.fromDegrees(...vi.position, undefined, temp_cartesian1);
        const tar = Cesium.Cartesian3.fromDegrees(...target, undefined, temp_cartesian2);
        const transform = Cesium.Transforms.eastNorthUpToFixedFrame(pos, Cesium.Ellipsoid.WGS84, temp_matrix);
        const invtransform = Cesium.Matrix4.inverse(transform, transform);
        const offset = Cesium.Matrix4.multiplyByPoint(invtransform, tar, tar);
        Cesium.Cartesian3.normalize(offset, offset);
        const heading = 90 - Cesium.Math.toDegrees(Math.atan2(offset.y, offset.x));
        const pitch = Cesium.Math.toDegrees(Math.asin(-offset.z));
        vi.heading = heading;
        vi.pitch = pitch;
    }
    CZMAP.calcTargetHeadingPitch = calcTargetHeadingPitch;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 切割保留参数 */
    let CutRetain;
    (function (CutRetain) {
        /** 保留左侧 */
        CutRetain["LEFT"] = "left";
        /** 保留右侧 */
        CutRetain["RIGHT"] = "right";
        /** 保留切割面 */
        CutRetain["SECTION"] = "section";
    })(CutRetain = CZMAP.CutRetain || (CZMAP.CutRetain = {}));
    /** 模型切割辅助工具 */
    class ModelCutHelper {
        constructor(layer) {
            this._items = [];
            this._layer = layer;
            if (this._layer.format !== CZMAP.ModelDataFormat.ZFCLS) {
                throw new Error('不支持的图层，仅支持zfcls图层');
            }
        }
        /**
         * 添加平面切割
         * @param clip 切割面
         * @param retain 保留的模型信息
         */
        addAxisPlane(clip, retain) {
            const scale = this._layer.scale;
            this.addPlane(clip.axis, clip.distance / scale[clip.axis], retain);
        }
        /**
         * 添加平面切割
         * @param axis 切割轴向
         * @param distance 切割面距离
         * @param retain 保留的模型信息
         */
        addPlane(axis, distance, retain) {
            const item = {
                type: 'plane',
                retain,
                axis,
                dist: distance,
                absolute: false
            };
            this._items.push(item);
        }
        /**
         * 添加路径切割
         * @param path 切割路径
         * @param retain 保留的模型信息
         */
        addPath(path, retain) {
            const pfg = new CZMAP.ProjectionForGlobe();
            const pos = CZMAP.GeoMath.add(this._layer.position, this._layer.offset);
            pfg.setCenter(pos[0], pos[1]);
            const box = CZMAP.BoundingBox.formString(this._layer.zfclsInfo.box);
            const center = box.getCenter();
            const scale = this._layer.scale;
            const gpath = path.map(p => CZMAP.GeoMath.add(CZMAP.GeoMath.div(pfg.toLocal(p), scale), center));
            const item = {
                type: 'path',
                retain,
                path: gpath
            };
            this._items.push(item);
        }
        /**
         * 添加复杂切割
         * @param path 切割路径
         * @param clip 切割面
         * @param retain 保留的模型信息
         */
        addComplex(path, clip, retain) {
            const gpath = this._projPath(path);
            const scale = this._layer.scale;
            const height = clip.distance / scale[clip.axis];
            const item = {
                type: 'complex',
                retain,
                path: gpath,
                height,
                absolute: false
            };
            ///
            this._items.push(item);
        }
        /**
         * 执行切割
         * @param option 切割参数
         * @param option.onload 切割完成回调
         * @param option.onloadeddata 切割进度通报回调
         * @param option.onerror 切割失败回调
         * @returns Promise 切割完成
         */
        cut(option) {
            option = option || {};
            function call(callback, ...args) {
                try {
                    if (callback instanceof Function)
                        callback(...args);
                }
                catch (e) {
                    console.warn('call callback function error!', e);
                }
            }
            const url = this._layer.url2;
            const cuturl = url + '/cut/create';
            const promise = new Promise((resolve, reject) => {
                /// 检查进度
                const check = async (result) => {
                    if (!result.success) {
                        reject(result.msg);
                        return;
                    }
                    const checkurl = `${url}/cut/query?ssid=${result.ssid}`;
                    const resp = await CZMAP.HttpUtil.post(new CZMAP.HttpArgs(checkurl));
                    if (!resp.ok)
                        reject(resp.statusText);
                    const e = await resp.json();
                    if (e.success === false) {
                        reject(e.exception);
                        return;
                    }
                    if (e.status === 'error') {
                        reject(e.einfo);
                        return;
                    }
                    ///
                    call(option.onloadeddata, e);
                    ///
                    if (e.status === 'finished') {
                        ///
                        const cutlayer = this._createCutLayer(`${url}/cut/get?cid=${result.cid}&name=cut.glb`);
                        resolve(cutlayer);
                        return;
                    }
                    ///
                    setTimeout(() => check(result), 1000);
                };
                /// 创建切割
                CZMAP.HttpUtil.post({ url: cuturl, data: { cuts: this._items } })
                    .then(e => e.ok ? e.json() : Promise.reject(e.statusText))
                    .then(e => check(e))
                    .catch(e => reject(e));
            });
            ///
            promise.then(e => call(option.onload, e), e => call(option.onerror, e));
            ///
            return promise;
        }
        /** 投影路径点为到投影平面坐标 */
        _projPath(path) {
            const pfg = new CZMAP.ProjectionForGlobe();
            const pos = CZMAP.GeoMath.add(this._layer.position, this._layer.offset);
            pfg.setCenter(pos[0], pos[1]);
            const box = CZMAP.BoundingBox.formString(this._layer.zfclsInfo.box);
            const center = box.getCenter();
            const scale = this._layer.scale;
            ///
            return path.map(p => CZMAP.GeoMath.add(CZMAP.GeoMath.div(pfg.toLocal(p), scale), center));
        }
        /**
         * 创建切割图层
         * @param url 模型URL
         * @returns 创建的图层
         */
        _createCutLayer(url) {
            const layer = CZMAP.MapLoader.loadLayer(this._layer.parent, {
                "name": "切割结果",
                "visible": true,
                "type": "model",
                "url": url,
                "position": this._layer.position,
                "scale": this._layer.scale,
                "offset": this._layer.offset,
                "style": this._layer.define.style
            });
            //layer.zoomTo();
            return layer;
        }
    }
    CZMAP.ModelCutHelper = ModelCutHelper;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 模型图层辅助工具
     */
    class ModelLayerHelper {
        /**
         * 获取模型的包围盒
         * @param layer
         * @returns
         */
        static calcBox(layer) {
            const scale = layer.scale;
            const offset = layer.offset;
            const position = layer.position.slice();
            /// 获取模型中心点
            const box = CZMAP.BoundingBox.formString(layer.zfclsInfo.box);
            const size = box.getSize();
            //const center = cbox.getCenter();
            /// 应用缩放比例，并增大1.1倍
            CZMAP.GeoMath.mul(size, scale, size);
            CZMAP.GeoMath.mulScalar(size, 1.1, size);
            /// 应用偏移
            CZMAP.GeoMath.add(position, offset, position);
            size[0] = size[0] / 111000;
            size[1] = size[1] / 111000;
            ///
            return CZMAP.BoundingBox.formCenterSize(position, size, box);
        }
        /**
         * 基于模型创建切割面
         * @param layer
         * @param type
         * @returns
         */
        static createClipPlane(layer, type) {
            ///
            const box = ModelLayerHelper.calcBox(layer);
            ///
            return layer.view.createClipPlane({ type, box });
        }
        /**
         * 创建包围盒
         * @param layer
         * @returns
         */
        static createBoundBox(layer) {
            layer.showBoxEntity(true);
        }
        /** 移除包围盒 */
        static removeBoundBox(layer) {
            layer.showBoxEntity(false);
        }
        /** 创建坐标网格 */
        static createCoordGrid(layer) {
            layer.showCoordGrid(true);
        }
        /** 移除坐标网格 */
        static removeCoordGrid(layer) {
            layer.showCoordGrid(false);
        }
        /**
         * 获取模型的体积
         * @param layer
         * @returns
         */
        static async fetchModelVolume(layer) {
            const url = layer.url2 + '/measure/volume';
            const e = await fetch(url);
            return await (e.ok ? e.json() : { success: false, msg: 'error' });
        }
        /**
         * 拉取模型的外边界
         * @param layer 模型图层
         * @returns 模型边界线
         */
        static async fetchModelEdges(layer) {
            const simples = [];
            CZMAP.ZFclsModel.filterSimpleModel(layer.zfclsInfo, simples);
            if (simples.length === 0)
                return;
            const offset = layer.offset.join(',');
            const scale = layer.scale.join(',');
            const url = layer.url2 + `/measure/edges?fid=${simples[0].id}&offset=${offset}&scale=${scale}`;
            const e = await fetch(url);
            /// 
            const f = await (e.ok ? e.json() : { success: false, msg: 'error' });
            return f;
        }
        /**
         * 根据地址模型上 添加地形和影像
         * @param layer
         * @param option
         * @returns
         */
        static async createModelTerrain(layer, option) {
            ///
            ModelLayerHelper.removeModelTerrain(layer);
            ///
            const result = await ModelLayerHelper.fetchModelEdges(layer);
            if (!result)
                return Promise.reject(result.msg);
            ///
            if (!result.success)
                return Promise.reject(result.msg);
            const feas = result.edges2.features;
            if (!feas || feas.length == 0)
                return Promise.reject('result is empty');
            const area = feas[0].geometry.coordinates[0];
            const heightOffset = option.heightOffset || 0;
            const map = layer.map;
            const offset = layer.offset;
            const terrain = map.rootLayer.createLayer(CZMAP.TerrainLayer, {
                name: option.name || '地形',
                url: option.terrain,
                heightOffset: offset[2] + heightOffset,
                heightScale: layer.scale[2],
                heightScaleOffset: layer.position[2]
            });
            let images = undefined;
            const cbox = CZMAP.BoundingBox.formString(layer.zfclsInfo.cbox);
            const extent = [cbox.minx, cbox.miny, cbox.maxx, cbox.maxy];
            /// 影像
            if (option.images) {
                images = [];
                option.images.forEach(ii => {
                    ii.style.extent = extent;
                    images.push(CZMAP.MapLoader.loadTileLayer(map.rootLayer, ii));
                });
            }
            else {
                const il3d = map.rootLayer.createLayer(CZMAP.TileLayer3D, {
                    name: 'DEM',
                    visible: true,
                    extent,
                    //define : layerdef,
                    url: option.terrain,
                    scheme: 'GEOGRAPHIC',
                    mapType: 'dem'
                });
                const pr = il3d.layer.provider;
                pr._minVal = cbox.minz;
                pr._maxVal = cbox.maxz;
                ///
                images = [il3d];
            }
            ///
            terrain.setClip({
                clip: area,
                height: 0,
                inner: false,
                wall: false,
                floor: false,
            });
            const globe = map.view3d.cesium.globe;
            let mt = { terrain, images, globe: globe.show };
            /// 显示地形
            globe.show = true;
            /// 保存
            ModelLayerHelper.terrains.set(layer, mt);
            /// 设置缩放比例
            return mt;
        }
        /**
         * 移除模型图层上的地形图层
         * @param layer 模型图层
         */
        static removeModelTerrain(layer) {
            const mt = ModelLayerHelper.terrains.get(layer);
            if (!mt)
                return;
            ModelLayerHelper.terrains.delete(layer);
            if (mt.terrain)
                mt.terrain.parent.removeLayer(mt.terrain);
            if (mt.images) {
                mt.images.forEach(i => i.parent.removeLayer(i));
            }
            /// 还原地形设置
            const globe = layer.map.view3d.cesium.globe;
            if (!mt.globe)
                globe.show = false;
        }
    }
    /**
     * 地形图层列表
     */
    ModelLayerHelper.terrains = new Map();
    CZMAP.ModelLayerHelper = ModelLayerHelper;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    let CLICK_MODE;
    (function (CLICK_MODE) {
        CLICK_MODE[CLICK_MODE["NONE"] = 0] = "NONE";
        CLICK_MODE[CLICK_MODE["PICK_MODEL"] = 1] = "PICK_MODEL";
        CLICK_MODE[CLICK_MODE["PICK_POSITION"] = 2] = "PICK_POSITION";
    })(CLICK_MODE || (CLICK_MODE = {}));
    const toDegrees = (val, fix = 8) => Cesium.Math.toDegrees(val).toFixed(fix);
    class Movable {
        constructor(viewer) {
            this.viewer = viewer;
        }
    }
    const TEMP_MATRIX4 = new Cesium.Matrix4();
    const UNIT_SCALE = Cesium.Cartesian3.fromElements(1, 1, 1);
    function toCegoreHPR(hpr) {
        const chpr = new Cegore.HeadingPitchRoll();
        chpr.setFromRadius(hpr);
        return chpr;
    }
    class EntityMovable extends Movable {
        constructor(viewer, entity) {
            super(viewer);
            this.enitity = entity;
        }
        get position() {
            return this.enitity.position.getValue(this.viewer.clock.currentTime);
        }
        get pos() {
            return new Cegore.Position(this.position);
        }
        set pos(pos) {
            this.enitity.position = Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, pos.altitude);
        }
        get hpr() {
            const pos = this.position;
            const ent = this.enitity;
            let hpr;
            if (ent.orientation) {
                const ori = ent.orientation.getValue(this.viewer.clock.currentTime);
                Cesium.Matrix4.fromTranslationQuaternionRotationScale(pos, ori, UNIT_SCALE, TEMP_MATRIX4);
                hpr = Cesium.Transforms.fixedFrameToHeadingPitchRoll(TEMP_MATRIX4);
            }
            else {
                hpr = new Cesium.HeadingPitchRoll();
            }
            ///
            return toCegoreHPR(hpr);
        }
        set hpr(chpr) {
            const pos = this.position;
            const hpr = Cesium.HeadingPitchRoll.fromDegrees(chpr.heading, chpr.pitch, chpr.roll);
            this.enitity.orientation = Cesium.Transforms.headingPitchRollQuaternion(pos, hpr, undefined, undefined);
        }
    }
    class PrimitiveMovable extends Movable {
        constructor(viewer, primitive) {
            super(viewer);
            ///
            this._mat = Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY);
            this._pos = new Cesium.Cartesian3();
            this._hpr = new Cesium.HeadingPitchRoll();
            this._ori = new Cesium.Quaternion();
            this.primitive = primitive;
            ///
            if (primitive.modelMatrix)
                Cesium.Matrix4.clone(primitive.modelMatrix, this._mat);
            Cesium.Matrix4.getTranslation(this._mat, this._pos);
            const mat3 = Cesium.Matrix4.getMatrix3(this._mat, new Cesium.Matrix3());
            const ori = Cesium.Quaternion.fromRotationMatrix(mat3);
            Cesium.Matrix4.fromRotationTranslation(mat3, this._pos, TEMP_MATRIX4);
            Cesium.Matrix4.fromTranslationQuaternionRotationScale(this._pos, ori, UNIT_SCALE, TEMP_MATRIX4);
            Cesium.Transforms.fixedFrameToHeadingPitchRoll(TEMP_MATRIX4, undefined, undefined, this._hpr);
        }
        get pos() {
            return new Cegore.Position(this._pos);
        }
        set pos(pos) {
            this._pos = Cesium.Cartesian3.fromDegrees(pos.x, pos.y, pos.z, undefined, this._pos);
            this.update();
        }
        get hpr() {
            return toCegoreHPR(this._hpr);
        }
        set hpr(hpr) {
            this._hpr = Cesium.HeadingPitchRoll.fromDegrees(hpr.heading, hpr.pitch, hpr.roll, this._hpr);
            this.update();
        }
        update() {
            Cesium.Transforms.headingPitchRollQuaternion(this._pos, this._hpr, undefined, undefined, this._ori);
            this.primitive.modelMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(this._pos, this._ori, UNIT_SCALE, this._mat);
        }
    }
    class ModelLayerMovable extends Movable {
        constructor(viewer, entity) {
            super(viewer);
            this.enitity = entity;
        }
        get pos() {
            return new Cegore.Position(this.enitity.position);
        }
        set pos(pos) {
            this.enitity.position = [pos.x, pos.y, pos.z];
        }
        get hpr() {
            return new Cegore.HeadingPitchRoll(this.enitity.pose);
        }
        set hpr(hpr) {
            this.enitity.pose = [hpr.heading, hpr.pitch, hpr.roll];
        }
    }
    class ModelMover {
        constructor(czmap) {
            this._entities = [];
            this._entitiesReset = [];
            this._mode = CLICK_MODE.NONE;
            this._keys = {};
            this._czmap = czmap;
            this._viewer = czmap.view3d.czviewer;
            const scene = this._viewer.scene;
            this._handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
            this._handler.setInputAction((movement) => this._clickHandle(movement), Cesium.ScreenSpaceEventType.LEFT_CLICK);
            this._initUI();
        }
        pickModel() {
            this._mode = CLICK_MODE.PICK_MODEL;
        }
        pickPosition() {
            this._mode = CLICK_MODE.PICK_POSITION;
        }
        pickLine() {
            this._mode = CLICK_MODE.NONE;
            this._czmap.view3d.drawTool.drawPolyline((geo) => {
                const coord = JSON.stringify(geo.coordinates);
                //copyToClipboard(coord);
            });
        }
        pickPose() {
            const pos = this._viewer.camera.positionWC;
            const cat = Cesium.Cartographic.fromCartesian(pos);
            const { heading, pitch, roll } = this._viewer.camera;
            this._posInput.value = `pos:${toDegrees(cat.longitude)},${toDegrees(cat.latitude)},${cat.height.toFixed(2)}`;
            this._poseInput.value = `ori: ${toDegrees(heading, 2)}, ${toDegrees(pitch, 2)}, ${toDegrees(roll, 2)}`;
        }
        pickViewInfo() {
            const vinfo = this._czmap.view3d.getViewInfo();
            const [x, y, z] = vinfo.position;
            this._posInput.value = `${x.toFixed(8)},${y.toFixed(8)},${z.toFixed(2)}`;
            this._poseInput.value = `${vinfo.heading.toFixed(2)},${vinfo.pitch.toFixed(2)},${vinfo.roll.toFixed(2)}`;
        }
        clear() {
            this._entitiesReset.forEach(rs => rs());
            this._entitiesReset.length = 0;
            this._entities.length = 0;
            this._entitiesDom.innerHTML = "";
            this._mode = CLICK_MODE.NONE;
        }
        show() { this._content.style.display = 'block'; }
        hide() { this._content.style.display = 'none'; }
        _createDom(name) {
            const bt = document.createElement(name);
            this._content.append(bt);
            return bt;
        }
        _createLabel(name) {
            const label = document.createElement('label');
            label.innerText = name;
            return label;
        }
        _createInput(name, type) {
            this._createLabel(name);
            ///
            const input = document.createElement('input');
            /// 
            this._content.appendChild(input);
            ///
            this._createDom('br');
            //
            return input;
        }
        _createRange(name, callback) {
            let last = 50;
            const input = this._createInput(name, 'range');
            input.type = 'range';
            input.value = last;
            input.oninput = (e) => {
                console.info(e);
                const cval = input.valueAsNumber;
                callback(cval - last);
                last = cval;
            };
            input.onmouseup = () => last = input.valueAsNumber = 50;
            //
            return input;
        }
        _createButton(name, callback) {
            const bt = document.createElement('button');
            bt.innerText = name;
            bt.onclick = callback;
            this._content.appendChild(bt);
        }
        _initUI() {
            this._content = document.createElement('div');
            this._content.className = "zmap-model-mover";
            this._content.style.display = 'none';
            this._createButton("拾取模型", () => this.pickModel());
            this._createButton("拾取坐标", () => this.pickPosition());
            this._createButton("获取姿态", () => this.pickPose());
            this._createButton("视图信息", () => this.pickViewInfo());
            this._createButton("绘制线", () => this.pickLine());
            this._createButton("清除", () => this.clear());
            this._createDom('br');
            this._createDom('br');
            /// 
            this._createRange('X', (diff) => this._onPosition('x', diff));
            this._createRange('Y', (diff) => this._onPosition('y', diff));
            this._createRange('Z', (diff) => this._onPosition('z', diff));
            this._posInput = this._createInput('pos', 'input');
            this._createDom('br');
            ///
            this._createRange('X', (diff) => this._onPose('x', diff));
            this._createRange('Y', (diff) => this._onPose('y', diff));
            this._createRange('Z', (diff) => this._onPose('z', diff));
            this._poseInput = this._createInput('ori', 'input');
            this._createDom('br');
            /// 
            this._entitiesDom = this._createDom('div');
            document.body.appendChild(this._content);
            document.addEventListener('keydown', e => {
                this._keys[e.key] = true;
            });
            document.addEventListener('keyup', e => {
                this._keys[e.key] = false;
            });
        }
        _onPosition(axis, diff) {
            if (this._entities.length == 0)
                return;
            let distance;
            const scene = this._viewer.scene;
            const pickedObject = scene.pickPosition(new Cesium.Cartesian2(scene.canvas.width >> 1, scene.canvas.height >> 1));
            if (pickedObject) {
                distance = Cesium.Cartesian3.distance(pickedObject, this._viewer.camera.positionWC);
            }
            ///
            this._entities.forEach(ent => {
                const pos = ent.pos;
                const cat3 = Cesium.Cartesian3.fromDegrees(pos.x, pos.y, pos.z);
                if (distance === undefined)
                    distance = Cesium.Cartesian3.distance(cat3, this._viewer.camera.positionWC);
                ///
                const diffp = (diff / 100.0 * distance);
                switch (axis) {
                    case 'x':
                        pos.x += Cesium.Math.toRadians(diffp / 111000);
                        break;
                    case 'y':
                        pos.y += Cesium.Math.toRadians(diffp / 111000);
                        break;
                    case 'z': pos.z += diffp;
                }
                const toDegrees = (val) => Cesium.Math.toDegrees(val).toFixed(8);
                ///
                ent.pos = pos;
                this._posInput.value = `${pos.x.toFixed(8)}, ${pos.y.toFixed(8)}, ${pos.z.toFixed(2)}`;
            });
        }
        _onPose(axis, diff) {
            ///
            if (this._keys.Alt) {
                diff /= 10;
            }
            ///
            this._entities.forEach(ent => {
                //
                const hpr = ent.hpr;
                ///
                switch (axis) {
                    case 'x':
                        hpr.heading += Cesium.Math.toRadians(diff);
                        break;
                    case 'y':
                        hpr.pitch += Cesium.Math.toRadians(diff);
                        break;
                    case 'z':
                        hpr.roll += Cesium.Math.toRadians(diff);
                        break;
                }
                const toDegrees = (val) => Cesium.Math.toDegrees(val).toFixed(2);
                ent.hpr = hpr;
                this._poseInput.value = `${toDegrees(hpr.heading)}, ${toDegrees(hpr.pitch)}, ${hpr.roll}`;
            });
        }
        _addEntity(ent) {
            const find = this._entities.find(m => m instanceof EntityMovable && m.enitity === ent);
            if (find)
                return;
            if (ent.model) {
                const model = ent.model;
                model.silhouetteColor = Cesium.Color.YELLOW;
                model.silhouetteSize = 2;
                this._entitiesReset.push(() => model.silhouetteSize = 0);
            }
            ///
            this._entities.push(new EntityMovable(this._viewer, ent));
            this._entitiesDom.appendChild(this._createLabel('entity'));
            this._entitiesDom.appendChild(this._createDom('br'));
        }
        _add3dtiles(tiles) {
            const find = this._entities.find(m => m instanceof PrimitiveMovable && m.primitive === tiles);
            if (find)
                return;
            tiles.debugWireframe = true;
            this._entitiesReset.push(() => tiles.debugWireframe = false);
            ///
            this._entities.push(new PrimitiveMovable(this._viewer, tiles));
            this._entitiesDom.appendChild(this._createLabel('3dtiles'));
            this._entitiesDom.appendChild(this._createDom('br'));
        }
        _clickHandle(movement) {
            const scene = this._viewer.scene;
            if (this._mode == CLICK_MODE.PICK_MODEL) {
                var pickedObject = scene.pick(movement.position);
                if (Cesium.defined(pickedObject)) {
                    if (pickedObject.id instanceof Cesium.Entity)
                        this._addEntity(pickedObject.id);
                    if (pickedObject.primitive instanceof Cesium.Cesium3DTileset)
                        this._add3dtiles(pickedObject.primitive);
                }
            }
            if (this._mode == CLICK_MODE.PICK_POSITION) {
                const toDegrees = (val) => Cesium.Math.toDegrees(val).toFixed(8);
                const pos = scene.pickPosition(movement.position);
                if (pos) {
                    const cart = Cesium.Cartographic.fromCartesian(pos);
                    this._posInput.value = (`${toDegrees(cart.longitude)},${toDegrees(cart.latitude)},${cart.height}`);
                }
            }
        }
    }
    CZMAP.ModelMover = ModelMover;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    class ClusterShowItem extends CZMAP.Disposable {
        constructor(group, key, values) {
            super();
            this.items = [];
            this.group = group;
            this.key = key;
            this.values = values.slice();
            this.cluster = group.cluster;
        }
        add(item) {
            this.items.push(item);
            this.requestUpdate();
        }
        remove(item) {
            CZMAP.ArrayUtils.removeItem(this.items, item);
            this.requestUpdate();
        }
        requestUpdate() {
            if (this._updateHandle)
                return;
            this._updateHandle = requestAnimationFrame(() => {
                this._updateHandle = 0;
                this.update();
            });
        }
        update() {
            const range = new Cesium.Rectangle(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            this.items.forEach(i => Cesium.Rectangle.expand(range, Cesium.Cartographic.fromCartesian(i.position), range));
            const center = Cesium.Rectangle.center(range);
            this.range = [
                Cesium.Math.toDegrees(range.west),
                Cesium.Math.toDegrees(range.south),
                Cesium.Math.toDegrees(range.east),
                Cesium.Math.toDegrees(range.north),
            ];
            const position = Cesium.Cartographic.toCartesian(center);
            const data = {
                fields: this.group.fields.map(f => f.name),
                value: this.values.last(),
                values: this.values,
                count: this.items.length,
            };
            ///
            this.entity = this.cluster.createCluster(this.group, position, data, this.entity);
        }
        show(show) {
            if (this.entity)
                this.entity.show = show;
        }
        _disposeInternal() {
            this.cluster.removeCluster(this.entity);
            this.entity = undefined;
            this.cluster = undefined;
        }
    }
    /** 聚合分组 */
    class ClusterGroup extends CZMAP.Disposable {
        constructor(cluster, classes) {
            super();
            this.items = {};
            this.cluster = cluster;
            this.label = classes.label;
            this.fields = classes.fields.map(f => {
                return {
                    name: f.name,
                    regex: f.regex ? new RegExp(f.regex) : undefined
                };
            });
            ///
            this.minDistance = classes.minDistance;
            this.maxDistance = classes.maxDistance;
        }
        getValues(data) {
            return this.fields.map(f => this.getValue(data, f));
        }
        getValue(data, field) {
            if (!CZMAP.defined(data))
                return;
            let value = data[field.name];
            if (field.regex && field.regex.test(value)) {
                value = RegExp.$1;
            }
            ///
            return value;
        }
        add(key, values, item) {
            let it = this.items[key];
            if (!it) {
                this.items[key] = it = new ClusterShowItem(this, key, values);
            }
            it.add(item);
        }
        remove(key, item) {
            let it = this.items[key];
            if (!it)
                return;
            it.remove(item);
        }
        show(show) {
            for (let key in this.items) {
                const it = this.items[key];
                it.show(show);
            }
        }
        clear() {
            for (let key in this.items) {
                const it = this.items[key];
                it.dispose();
            }
            this.items = {};
        }
        update() {
            for (let key in this.items) {
                const it = this.items[key];
                it.requestUpdate();
            }
        }
        _disposeInternal() {
            this.clear();
        }
    }
    /**
     * 多级分组聚合
     */
    class MultiLevelCluster extends CZMAP.Disposable {
        constructor(viewer, option) {
            super();
            this._items = [];
            this._lastCameraPos = new Cesium.Cartesian3();
            this._visible = true;
            this._viewer = viewer;
            this._scene = viewer.scene;
            this._style = option.style;
            this._range = option.range ? Cesium.Rectangle.fromDegrees(...option.range) : undefined;
            this._groups = option.classes.map(f => new ClusterGroup(this, f));
            this._scene.postRender.addEventListener(this.onPostRender, this);
        }
        get show() { return this._visible; }
        set show(show) {
            this._visible = !!show;
            if (this._visible) {
                this.updateVisible(true);
            }
            else {
                this._groups.forEach(g => g.show(false));
            }
        }
        add(item) {
            this.doWithItem(item, true);
        }
        remove(item) {
            this.doWithItem(item, false);
        }
        update() {
            this._groups.forEach(g => g.update());
        }
        doWithItem(item, addOrRemove) {
            if (addOrRemove)
                this._items.push(item);
            else
                CZMAP.ArrayUtils.removeItem(this._items, item);
            ///    
            const values = [];
            if (this._range) {
                const cart = Cesium.Cartographic.fromCartesian(item.position);
                if (!Cesium.Rectangle.contains(this._range, cart))
                    return;
            }
            let basekey = "key";
            ///
            this._groups.forEach(g => {
                const value = g.getValues(item.properties);
                values.push(value.join('-'));
                ///
                basekey += '-' + value;
                if (addOrRemove)
                    g.add(basekey, values, item);
                else
                    g.remove(basekey, item);
            });
        }
        /** @internal */
        createCluster(group, position, data, entity) {
            const style = JSON.parse(JSON.stringify(this.getStyle(data)));
            if (!CZMAP.defined(style.icon.horizontalOrigin))
                style.icon.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
            if (!CZMAP.defined(style.label.horizontalOrigin))
                style.label.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
            if (!CZMAP.defined(group.label))
                style.label.text = `${data.fields.join('-')}:${data.value}(${data.count})`;
            else
                style.label.text = CZMAP.StringUtils.parseVar(group.label, data);
            if (!entity) {
                entity = this._viewer.entities.add({
                    position,
                    label: style.label,
                    billboard: style.icon
                });
            }
            entity.position = position;
            for (let key in style.label) {
                entity.label[key] = style.label[key];
            }
            for (let key in style.icon) {
                entity.billboard[key] = style.icon[key];
            }
            ///
            return entity;
        }
        removeCluster(ent) {
            this._viewer.entities.remove(ent);
        }
        _disposeInternal() {
            this._scene.postRender.removeEventListener(this.onPostRender, this);
            this._groups.forEach(g => g.dispose());
        }
        destroy() {
            this.dispose();
        }
        getStyle(data) {
            if (typeof this._style === 'function') {
                return this._style(data);
            }
            ///
            return this._style;
        }
        updateVisible(force) {
            if (!this._visible) {
                return;
            }
            ///
            const pos = this._scene.camera.position;
            if (!force && Cesium.Cartesian3.equals(pos, this._lastCameraPos))
                return;
            ///
            Cesium.Cartesian3.clone(pos, this._lastCameraPos);
            /// 
            const cart = Cesium.Cartographic.fromCartesian(pos);
            let find = false;
            this._groups.forEach(g => {
                const show = cart.height >= g.minDistance && cart.height < g.maxDistance;
                g.show(show);
                if (show) {
                    find = true;
                }
            });
            ///
            this._items.forEach(it => it.show(!find));
        }
        onPostRender(scene, time) {
            this.updateVisible();
        }
    }
    CZMAP.MultiLevelCluster = MultiLevelCluster;
})(CZMAP || (CZMAP = {}));
/// <reference path="EventTargetHelper.ts" />
var CZMAP;
(function (CZMAP) {
    let MouseEventButtons;
    (function (MouseEventButtons) {
        MouseEventButtons[MouseEventButtons["None"] = 0] = "None";
        MouseEventButtons[MouseEventButtons["LeftButton"] = 1] = "LeftButton";
        MouseEventButtons[MouseEventButtons["RightButton"] = 2] = "RightButton";
        MouseEventButtons[MouseEventButtons["MiddleButton"] = 4] = "MiddleButton";
        MouseEventButtons[MouseEventButtons["BackwardButton"] = 8] = "BackwardButton";
        MouseEventButtons[MouseEventButtons["ForwardButton"] = 16] = "ForwardButton";
    })(MouseEventButtons = CZMAP.MouseEventButtons || (CZMAP.MouseEventButtons = {}));
    let MouseEventModifyKey;
    (function (MouseEventModifyKey) {
        MouseEventModifyKey[MouseEventModifyKey["None"] = 0] = "None";
        MouseEventModifyKey[MouseEventModifyKey["ShiftKey"] = 1] = "ShiftKey";
        MouseEventModifyKey[MouseEventModifyKey["AltKey"] = 2] = "AltKey";
        MouseEventModifyKey[MouseEventModifyKey["CtrlKey"] = 3] = "CtrlKey";
    })(MouseEventModifyKey = CZMAP.MouseEventModifyKey || (CZMAP.MouseEventModifyKey = {}));
    /** 多点触控事件支持 */
    class MultiPointInput extends CZMAP.EventTargetHelper {
        constructor(option) {
            super();
            this._pointers = new Map();
            /** 拖动键 */
            this._dragButton = MouseEventButtons.LeftButton;
            /** 附拖动键 */
            this._rightDragButton = MouseEventButtons.RightButton;
            this.enableScale = true;
            this.enableRotate = false;
            this.option = option || {};
        }
        set dragButton(value) { if (CZMAP.defined(value))
            this._dragButton = value; }
        ;
        get dragButton() { return this._dragButton; }
        set rightDragButton(value) { if (CZMAP.defined(value))
            this._rightDragButton = value; }
        ;
        get rightDragButton() { return this._rightDragButton; }
        bind(dom) {
            this._dom = dom;
            this.setTarget(dom);
            this.on('pointerdown', e => this._pointer_down(e));
            this.on('pointerup', e => this._pointer_up(e));
            this.on('pointermove', e => this._pointer_move(e));
            this.on('pointercancel', e => this._pointer_cancel(e));
            this.on('wheel', e => this._mouse_wheel(e));
            this.on('contextmenu', e => this._context_menu(e));
            /// 取消拖动事件的默认效果
            this.on('dragstart', e => false);
            this._oldTouchAction = dom.style.touchAction;
            dom.style.touchAction = 'none';
        }
        release() {
            this.unAll();
            if (this._dom && this._oldTouchAction) {
                this._dom.style.touchAction = this._oldTouchAction;
            }
            this._pointers.clear();
        }
        _clear() {
            this._pointers.clear();
            this._firstPoint = undefined;
        }
        _pointer_down(e) {
            if (e.isPrimary) {
                this._clear();
                this._firstPoint = e;
            }
            this._pointers.set(e.pointerId, e);
            this._notifyBeginEnd(this._pointers.size, -1);
        }
        _pointer_up(e) {
            const pe = this._pointers.get(e.pointerId);
            if (!pe)
                return;
            ///
            this._pointers.delete(e.pointerId);
            this._notifyBeginEnd(this._pointers.size, 1);
            //
            if (this._pointers.size === 0 && e.isPrimary && this._firstPoint && isSamePoint(this._firstPoint, e)) {
                CZMAP.tryCatchCall(this.option.onClick, e);
            }
        }
        _notifyBeginEnd(size, dsize) {
            if (size === 1) {
                CZMAP.tryCatchCall(this.option.onBeginAction);
            }
            const psize = size + dsize;
            switch (psize) {
                case 1:
                    CZMAP.tryCatchCall(this.option.onEndDragging);
                    break;
                case 2:
                    CZMAP.tryCatchCall(this.option.onEndScaleRotate);
                    break;
                case 3:
                    CZMAP.tryCatchCall(this.option.onEndTilting);
                    break;
            }
            switch (size) {
                case 1:
                    CZMAP.tryCatchCall(this.option.onBeginDragging);
                    break;
                case 2:
                    CZMAP.tryCatchCall(this.option.onBeginScaleRotate);
                    break;
                case 3:
                    CZMAP.tryCatchCall(this.option.onBeginTilting);
                    break;
            }
            if (size === 0) {
                CZMAP.tryCatchCall(this.option.onEndAction);
            }
        }
        _pointer_move(e) {
            ///
            if (this._pointers.size === 0) {
                CZMAP.tryCatchCall(this.option.onMouseMove, e);
                return;
            }
            const pe = this._pointers.get(e.pointerId);
            if (!pe)
                return;
            /// 单点
            if (this._pointers.size === 1) {
                if (matchEventBind(e, this._dragButton)) {
                    CZMAP.tryCatchCall(this.option.onDragging, {
                        x: e.offsetX, y: e.offsetY,
                        dx: e.movementX, dy: e.movementY
                    });
                }
                else if (matchEventBind(e, this._rightDragButton)) {
                    CZMAP.tryCatchCall(this.option.onRightDragging, {
                        x: e.offsetX, y: e.offsetY,
                        dx: e.movementX, dy: e.movementY
                    });
                }
            }
            /// 双点
            else if (this._pointers.size === 2) {
                const o = this._getOtherPointer(e.pointerId);
                const d0 = calcDistance(o, pe);
                const d1 = calcDistance(o, e);
                const r0 = calcRadius(o, pe);
                const r1 = calcRadius(o, e);
                const ct = calcCenter(o, e);
                CZMAP.tryCatchCall(this.option.onRotateScale, { d0, d1, r0, r1, ct });
            }
            /// 三点
            else if (this._pointers.size === 3) {
                CZMAP.tryCatchCall(this.option.onTilting, {
                    x: e.offsetX, y: e.offsetY,
                    dx: e.movementX, dy: e.movementY
                });
            }
            ///
            this._pointers.set(e.pointerId, e);
        }
        _pointer_cancel(e) {
            this._clear();
        }
        _mouse_wheel(e) {
            const x = e.offsetX, y = e.offsetY;
            const d1 = e.deltaY > 0 ? -20 : 20;
            CZMAP.tryCatchCall(this.option.onRotateScale, { d0: 0, d1, r0: 0, r1: 0, ct: { x, y } });
            e.stopPropagation();
            e.preventDefault();
        }
        _context_menu(e) {
            e.stopPropagation();
            e.preventDefault();
        }
        _getOtherPointer(id) {
            for (let e of this._pointers) {
                if (e[0] !== id)
                    return e[1];
            }
        }
    }
    CZMAP.MultiPointInput = MultiPointInput;
    function isEqual(v0, v1, t = 0.00001) {
        let df = v0 - v1;
        if (df < 0)
            df = -df;
        return df <= t;
    }
    function isSamePoint(p0, p1, t = 0.00001) {
        return isEqual(p0.offsetX, p1.offsetX, t) && isEqual(p0.offsetY, p1.offsetY, t);
    }
    CZMAP.isSamePoint = isSamePoint;
    function calcDiff(p0, p1) {
        const x = p0.offsetX - p1.offsetX;
        const y = p0.offsetY - p1.offsetY;
        return { x, y };
    }
    CZMAP.calcDiff = calcDiff;
    function calcCenter(p0, p1) {
        const x = (p0.offsetX + p1.offsetX) / 2;
        const y = (p0.offsetY + p1.offsetY) / 2;
        return { x, y };
    }
    function calcDistance(p0, p1) {
        const d = calcDiff(p0, p1);
        return Math.sqrt(d.x * d.x + d.y * d.y);
    }
    function calcRadius(p0, p1) {
        const d = calcDiff(p0, p1);
        return Math.atan2(d.y, d.x);
    }
    CZMAP.calcRadius = calcRadius;
    function matchEventBind(e, bd) {
        if (typeof bd === 'number') {
            return e.buttons === bd;
        }
        if (e.buttons !== bd.button)
            return false;
        const modify = CZMAP.asArray(bd.modify);
        if (CZMAP.defined(modify)) {
            for (let i = 0; i < modify.length; ++i) {
                switch (modify[i]) {
                    case MouseEventModifyKey.AltKey:
                        if (!e.altKey)
                            return false;
                        break;
                    case MouseEventModifyKey.ShiftKey:
                        if (!e.shiftKey)
                            return false;
                        break;
                    case MouseEventModifyKey.CtrlKey:
                        if (!e.ctrlKey)
                            return false;
                        break;
                }
            }
        }
        return true;
    }
})(CZMAP || (CZMAP = {}));
/// <reference path="Parse.ts" />
var CZMAP;
(function (CZMAP) {
    class Numbers extends CZMAP.Parse {
    }
    /**
     * 解析长度为2的数组
     */
    Numbers.parseArray2 = Numbers.createParseArray(',', 2);
    /**
     * 解析长度为3的数组
     */
    Numbers.parseArray3 = Numbers.createParseArray(',', 3);
    /**
     * 解析长度为4的数组
     */
    Numbers.parseArray4 = Numbers.createParseArray(',', 4);
    CZMAP.Numbers = Numbers;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function findExpiredCount(poss, time) {
        let index = 0;
        for (; index < poss.length; ++index) {
            if (Cesium.JulianDate.greaterThan(poss[index].time, time))
                break;
        }
        return index;
    }
    function buildMaterial(material, time) {
        if (material instanceof Cesium.Material)
            return material;
        if (material.getType && material.getValue) {
            const type = material.getType(time);
            const value = material.getValue(time);
            return Cesium.Material.fromType(type, value);
        }
        return undefined;
    }
    /** 路径拖尾 */
    class PathTail {
        constructor(polyline, option) {
            this.positions = [];
            this.maxLength = 100;
            this.maxSeconds = 5;
            this.lastTime = new Cesium.JulianDate();
            this.polyline = polyline;
            this.position = option.position;
            this.maxLength = option.maxLength || 100;
            this.maxSeconds = option.maxSeconds || 1;
        }
        update(time) {
            let modify = false;
            const position = this.position(time);
            if (position && !Cesium.Cartesian3.equals(this.lastPos, position)) {
                //
                this.lastPos = position;
                this.positions.push({ position, time });
                modify = true;
            }
            const lastTime = Cesium.JulianDate.addSeconds(time, -this.maxSeconds, this.lastTime);
            const beforeCount = findExpiredCount(this.positions, lastTime);
            const count = Math.max(beforeCount, this.positions.length - this.maxLength);
            if (count > 0) {
                this.positions = this.positions.slice(count);
                modify = true;
            }
            ///
            if (modify)
                this._updatePolyline();
        }
        _updatePolyline() {
            this.polyline.positions = this.positions.map(pos => pos.position);
        }
    }
    CZMAP.PathTail = PathTail;
    /** 路径拖尾集合 */
    class PathTailCollection {
        constructor(viewer) {
            this._tails = [];
            this._viewer = viewer;
            this._viewer.scene.postRender.addEventListener(this._postRender, this);
            this._polylines = new Cesium.PolylineCollection();
            this.scene.primitives.add(this._polylines);
        }
        get scene() { return this._viewer.scene; }
        createTail(option) {
            const polyline = this._polylines.add({
                width: option.width,
                material: buildMaterial(option.material, this.scene.lastRenderTime),
                distanceDisplayCondition: option.distanceDisplayCondition
            });
            ///
            const tail = new PathTail(polyline, option);
            this._tails.push(tail);
            return tail;
        }
        removeTail(tail) {
            const index = this._tails.indexOf(tail);
            if (index != -1) {
                this._tails.splice(index, 1);
                this._polylines.remove(tail.polyline);
            }
        }
        _postRender(scene, time) {
            this._tails.forEach(tail => tail.update(time));
        }
    }
    CZMAP.PathTailCollection = PathTailCollection;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const STRING_VAR_REGEX = /{[^}]+}/g;
    /**
     * 字符串模板类
     */
    class StringTemp {
        /**
         * 获取所有变量名称
         * @param str 待查找的字符串
         * @return 变量名称列表
         */
        static getVarNames(str) {
            const vars = str.match(STRING_VAR_REGEX);
            if (vars === null) {
                return [];
            }
            ///
            return vars.map(s => { return s.substr(1, s.length - 2); });
        }
        /**
         * 解析变量
         * @param str 带解析的字符串，如：`'abc={value}'`
         * @param data 数据
         */
        static parseVar(str, data) {
            if (!CZMAP.Types.isString(str))
                return str;
            // eslint-disable-next-line no-constant-condition  
            while (true) {
                let sindex = str.indexOf("{");
                let eindex = str.indexOf("}");
                if (sindex == -1 || eindex == -1 || sindex > eindex)
                    break;
                ///
                let key = str.substring(sindex + 1, eindex);
                let val = data[key];
                if (!CZMAP.Types.isDefined(val))
                    val = '';
                ///
                str = str.substring(0, sindex) + val + str.substring(eindex + 1);
            }
            ///
            return str;
        }
        /**
         * 使用对象值替换字符串中的变量
         * @param str 待处理的字符串
         * @param data 对象数据
         */
        static parseVarMatch(str, data) {
            if (!CZMAP.Types.isString(str))
                return null;
            const names = this.getVarNames(str);
            if (names.length === 0)
                return null;
            const match = names.every(e => { return data.hasOwnProperty(e); });
            if (!match)
                return null;
            ///
            return this.parseVar(str, data);
        }
    }
    CZMAP.StringTemp = StringTemp;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /**
     * 字符串工具类
     */
    class StringUtils {
        /**
         * 解析变量
         * @param str 带解析的字符串`"abc={value}"`
         * @param data 数据
         */
        static parseVar(str, data) {
            return CZMAP.StringTemp.parseVar(str, data);
        }
        /**
         * 判断字符串是否未定义或者长度为0
         * @param str
         */
        static isNotEmpty(str) {
            return CZMAP.Types.isString(str) && str.length > 0;
        }
    }
    CZMAP.StringUtils = StringUtils;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function calcPose(p0, p1) {
        const transform = new Cesium.Matrix4();
        Cesium.Transforms.eastNorthUpToFixedFrame(p0, Cesium.Ellipsoid.WGS84, transform);
        Cesium.Matrix4.inverse(transform, transform);
        const offset = Cesium.Matrix4.multiplyByPoint(transform, p1, new Cesium.Cartesian3());
        ///
        return calcPoseByOffset(offset);
    }
    function calcPoseByOffset(offset) {
        const dist = Cesium.Cartesian3.magnitude(offset);
        const pitch = Cesium.Math.toDegrees(Math.asin(offset.z / dist));
        const heading = 90 - Cesium.Math.toDegrees(Math.atan2(offset.y, offset.x));
        return [heading, pitch, 0];
    }
    class TunnelUtils {
        /**
         * 定位管环
         * @param pts 隧道中心线坐标
         * @param num 隧道管环数
         * @param index 需要定位的管环号，从0开始
         */
        static calcPosition(pts, num, index) {
            const carts = pts.map(pt => Cesium.Cartesian3.fromDegrees(...pt));
            // 计算每段长度和总长度
            let allLength = 0;
            const lengths = carts.map((c, i) => {
                if (i == 0)
                    return 0;
                const length = Cesium.Cartesian3.distance(c, carts[i - 1]);
                allLength += length;
                return length;
            });
            const cell = allLength / num;
            const tar = cell * index;
            let curr = 0;
            for (let i = 0; i < lengths.length; ++i) {
                if (curr > tar) {
                    const p0 = carts[i - 1];
                    const p1 = carts[i];
                    const t = curr - tar;
                    const p = t / lengths[i];
                    const pos = Cesium.Cartesian3.lerp(p1, p0, p, new Cesium.Cartesian3());
                    const ca = Cesium.Cartographic.fromCartesian(pos);
                    return {
                        position: [
                            Cesium.Math.toDegrees(ca.longitude),
                            Cesium.Math.toDegrees(ca.latitude),
                            ca.height
                        ],
                        pose: calcPose(p0, p1)
                    };
                }
                curr += lengths[i];
            }
        }
    }
    CZMAP.TunnelUtils = TunnelUtils;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const Cesium_HorizontalOrigin = {
        [CZMAP.HorizontalOrigin.LEFT]: Cesium.HorizontalOrigin.LEFT,
        [CZMAP.HorizontalOrigin.CENTER]: Cesium.HorizontalOrigin.CENTER,
        [CZMAP.HorizontalOrigin.RIGHT]: Cesium.HorizontalOrigin.RIGHT
    };
    const Cesium_VerticalOrigin = {
        [CZMAP.VerticalOrigin.BASELINE]: Cesium.VerticalOrigin.BASELINE,
        [CZMAP.VerticalOrigin.BOTTOM]: Cesium.VerticalOrigin.BOTTOM,
        [CZMAP.VerticalOrigin.CENTER]: Cesium.VerticalOrigin.CENTER,
        [CZMAP.VerticalOrigin.TOP]: Cesium.VerticalOrigin.TOP
    };
    /**
     * Cesium 属性辅助类
     */
    class CesiumAttrib {
        static getBoolean(val, def = true) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            if (CZMAP.Types.isBool(val))
                return val;
            if (CZMAP.Types.isString(val)) {
                return val.toUpperCase() === 'TRUE';
            }
            ///
            return def;
        }
        static getNumber(val, def = 0) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            if (CZMAP.Types.isString(val))
                val = Number.parseFloat(val);
            if (CZMAP.Types.isNumber(val))
                return val;
            return def;
        }
        static getRadian(val, def = 0) {
            return this.getNumber(val, def) / 180 * Math.PI;
        }
        static getColor(val, def) {
            if (!CZMAP.Types.isDefined(val))
                return def ? this.getColor(def) : undefined;
            if (val instanceof Cesium.Color)
                return val;
            return Cesium.Color.fromCssColorString(val);
        }
        static getCartesian2(val, def = Cesium.Cartesian2.ZERO) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            if (CZMAP.Types.isArray(val))
                return new Cesium.Cartesian2(val[0], val[1]);
            if (CZMAP.Types.isObject(val))
                return new Cesium.Cartesian2(val.x, val.y);
            return def;
        }
        static getCartesian3(val, def = Cesium.Cartesian3.ZERO) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            if (CZMAP.Types.isArray(val))
                return new Cesium.Cartesian3(val[0], val[1], val[2]);
            if (CZMAP.Types.isObject(val))
                return new Cesium.Cartesian3(val.x, val.y, val.z);
            return def;
        }
        static getCartesian3Degree(val, def = Cesium.Cartesian3.ZERO) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            if (CZMAP.Types.isArray(val))
                return Cesium.Cartesian3.fromDegrees(val[0], val[1], val[2]);
            if (CZMAP.Types.isObject(val))
                return Cesium.Cartesian3.fromDegrees(val.x, val.y, val.z);
            return def;
        }
        static getHorizontal(val, def = Cesium.HorizontalOrigin.LEFT) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            return Cesium_HorizontalOrigin[val];
        }
        static getVertical(val, def = Cesium.VerticalOrigin.BOTTOM) {
            if (!CZMAP.Types.isDefined(val))
                return def;
            return Cesium_VerticalOrigin[val];
        }
        static getDisplayDistance(val) {
            if (!CZMAP.Types.isArray(val))
                return new Cesium.DistanceDisplayCondition();
            return new Cesium.DistanceDisplayCondition(val[0], val[1]);
        }
        static getNearFarScalar(val) {
            if (!CZMAP.Types.isArray(val))
                return undefined;
            return new Cesium.NearFarScalar(val[0], val[1], val[2], val[3]);
        }
        static readValue(prop, time, result) {
            if (!CZMAP.defined(prop))
                return undefined;
            ///
            return prop.getValue(time, result);
        }
    }
    CZMAP.CesiumAttrib = CesiumAttrib;
})(CZMAP || (CZMAP = {}));
/// hack
if (Array.prototype['last'] === undefined) {
    Array.prototype['last'] = function () {
        const len = this.length;
        if (len == 0)
            return;
        return this[len - 1];
    };
}
if (Array.prototype['remove'] === undefined) {
    Array.prototype['remove'] = function (t) {
        let count = 0;
        let index = -1;
        while ((index = this.indexOf(t)) !== -1) {
            this.splice(index, 1);
            count++;
        }
        return count;
    };
}
var CZMAP;
(function (CZMAP) {
    class PointInfo {
    }
    CZMAP.PointInfo = PointInfo;
    function setPointColor(pi, color) {
        if (pi)
            pi.entity.point.color = color;
    }
    /** 坐标编辑器 */
    class CoordinateEditor {
        constructor(view) {
            this._enities = [];
            ///
            this._points = [];
            this._pointPixelSize = 10;
            this._pointColor = Cesium.Color.RED;
            this._selectedColor = Cesium.Color.ORANGE;
            this._hoveredColor = Cesium.Color.YELLOW;
            this._alertFunc = globalThis.alert;
            this._view3d = view;
            this._czviewer = view.czviewer;
            this._editorTool = new CZMAP.TranslateEditorWidget3D(view, {
                position: [0, 0, 0],
                ontranslate: p => this._onMouseTranslate(p)
            });
            this._editorTool.visible = false;
        }
        setAlert(alert) {
            this._alertFunc = alert;
        }
        alert(msg) {
            CZMAP.tryCatchCall(this._alertFunc, msg);
        }
        get selected() { return this._selected; }
        _beginEdit() {
            this._bindEvents();
        }
        _endEdit() {
            this._releaseEvents();
        }
        /** 绑定鼠标事件和渲染事件 */
        _bindEvents() {
            if (!this._handler) {
                this._handler = new Cesium.ScreenSpaceEventHandler(this._czviewer.scene.canvas);
                this._handler.setInputAction((e) => this._onMouseClick(e), Cesium.ScreenSpaceEventType.LEFT_CLICK);
                this._handler.setInputAction((e) => this._onMouseMove(e), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            }
        }
        /** 释放事件绑定 */
        _releaseEvents() {
            if (this._handler) {
                this._handler.destroy();
                this._handler = undefined;
            }
        }
        _initPoints(pts) {
            pts.map(p => this._addPoint(p));
        }
        /** 添加点 */
        _addPoint(pt, data) {
            const pi = new PointInfo();
            pi.coordinate = pt;
            pi.position = Cesium.Cartesian3.fromDegrees(...pt);
            pi.entity = new Cesium.Entity({
                position: pi.position,
                point: {
                    color: this._pointColor,
                    pixelSize: this._pointPixelSize,
                    disableDepthTestDistance: 10000000
                }
            });
            pi.data = data;
            this._points.push(pi);
            this._enities.push(pi.entity);
            this._czviewer.entities.add(pi.entity);
            return pi;
        }
        /** 删除点 */
        _removePoint(pi) {
            const index = this._points.indexOf(pi);
            if (index === -1)
                return;
            this._points.splice(index, 1);
            this._enities.splice(index, 1);
            this._czviewer.entities.remove(pi.entity);
            if (pi === this._selected) {
                this._unselectPoint();
            }
            if (pi === this._hovered) {
                this._hovered = undefined;
            }
        }
        /** 复制点 */
        _clonePoint(pi, data) {
            const cpi = this._addPoint(CZMAP.GeoMath.clone(pi.coordinate), data);
            if (this._selected === pi) {
                this._selectPoint(cpi);
            }
            return cpi;
        }
        _removeAllPoints() {
            const entities = this._czviewer.entities;
            this._enities.forEach(p => entities.remove(p));
            this._enities.length = 0;
            this._points.length = 0;
        }
        _selectPoint(pi) {
            if (pi === this._selected)
                return;
            if (this._selected) {
                setPointColor(this._selected, this._pointColor);
            }
            const et = this._editorTool;
            et.position = pi.coordinate;
            et.offset = [0, 0, 0];
            et.visible = true;
            this._selected = pi;
            setPointColor(pi, this._selectedColor);
            ///
            this._onSelectedPoint(this._selected);
        }
        _unselectPoint() {
            this._editorTool.visible = false;
            if (this._selected) {
                setPointColor(this._selected, this._pointColor);
                this._selected = undefined;
            }
        }
        _onSelectedPoint(pi) {
        }
        _onMouseTranslate(p) {
            const selected = this._selected;
            if (!selected)
                return;
            Cesium.Cartesian3.fromDegrees(...p, undefined, selected.position);
            selected.entity.position = selected.position;
            CZMAP.GeoMath.clone(p, selected.coordinate);
            this._onTranslatePoint(selected);
        }
        _onMouseClick(p) {
            if (this._hovered) {
                this._selectPoint(this._hovered);
            }
        }
        _onMouseMove(p) {
            const pixel = p.endPosition;
            const pos2d = new Cesium.Cartesian2();
            const scene = this._czviewer.scene;
            const pointSizePower2 = this._pointPixelSize * this._pointPixelSize;
            const prehovered = this._hovered;
            const found = this._points.map(pi => {
                Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, pi.position, pos2d);
                return { pi, distance: Cesium.Cartesian2.distanceSquared(pos2d, pixel) };
            }).sort((a, b) => a.distance - b.distance)[0];
            this._hovered = (found === null || found === void 0 ? void 0 : found.distance) < pointSizePower2 ? found.pi : undefined;
            if (prehovered && prehovered !== this._hovered) {
                setPointColor(prehovered, prehovered === this._selected ? this._selectedColor : this._pointColor);
            }
            if (this._hovered && this._hovered !== prehovered) {
                setPointColor(this._hovered, this._hoveredColor);
            }
        }
        clear() {
            this._hovered = undefined;
            this._selected = undefined;
            this._removeAllPoints();
            if (this._editorTool)
                this._editorTool.visible = false;
        }
        /** 销毁对象 */
        destroy() {
            this.clear();
            this._releaseEvents();
            if (this._editorTool) {
                this._editorTool.destroy();
                this._editorTool = undefined;
            }
        }
    }
    CZMAP.CoordinateEditor = CoordinateEditor;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    /** 网络线信息 */
    class NetLineInfo {
        constructor(line) {
            /** 网路线应用的节点列表 */
            this.nodes = [];
            /** 节点列表的坐标列表 */
            this.points = [];
            this.line = line;
        }
        addNode(ni) {
            this.nodes.push(ni);
            this.points.push(ni.node.position);
            ni.lines.push(this);
        }
        insertNode(index, ni) {
            this.nodes.splice(index, 0, ni);
            this.points.splice(index, 0, ni.node.position);
            ni.lines.push(this);
        }
        removeNode(ni) {
            this.nodes.remove(ni);
            this.points.remove(ni.node.position);
            ni.lines.remove(this);
        }
        removeAllNode() {
            this.nodes.forEach(ni => ni.lines.remove(this));
            this.nodes.length = 0;
            this.points.length = 0;
        }
    }
    /** 网络节点信息 */
    class NetNodeInfo {
        constructor(node) {
            /** 网络节点对的的线信息 */
            this.lines = [];
            this.node = node;
        }
    }
    function findNodesByLine(line, nodes) {
        return line.nodes.map(nname => nodes.find(n => n.node.name === nname)).filter(n => CZMAP.defined(n));
    }
    function asPolylinePositions(pts, result) {
        let pre;
        let index = 0;
        pts.forEach(p => {
            const pos = Cesium.Cartesian3.fromDegrees(...p, undefined, result[index]);
            if (!Cesium.Cartesian3.equals(pre, pos)) {
                result[index] = (pos);
                pre = pos;
                index++;
            }
        });
        result.length = index;
        return result;
    }
    class NetEditor extends CZMAP.CoordinateEditor {
        constructor(view) {
            super(view);
        }
        startEdit(option) {
            this.clear();
            this._nodes = option.nodes.map(n => {
                const data = new NetNodeInfo(n); //= { node: n, lines: findLinesByNode(n, lineinfos) };
                data.point = this._addPoint(n.position, data);
                return data;
            });
            this._lines = option.lines.map(line => {
                const li = new NetLineInfo(line);
                const nodes = findNodesByLine(line, this._nodes);
                nodes.forEach(n => li.addNode(n));
                return li;
            });
            this._style = option.style;
            if (option.style) {
                this._lines.forEach(li => this._createLineEntity(li));
            }
            this._beginEdit();
        }
        stopEdit() {
            this._endEdit();
        }
        clear() {
            this._nodes = undefined;
            this._lines = undefined;
            this._style = undefined;
            super.clear();
        }
        getNetData() {
            return {
                nodes: this._nodes.map(ni => CZMAP.deepCopy(ni.node)),
                lines: this._lines.map(li => CZMAP.deepCopy(li.line))
            };
        }
        _createLineEntity(li) {
            const style = this._style;
            if (!style)
                return;
            const mat = CZMAP.Polyline3D.getStrokeMaterialProperty(style.detail);
            const entity = this._czviewer.entities.add({
                polyline: {
                    positions: new Cesium.CallbackProperty((time, result) => asPolylinePositions(li.points, result), false),
                    width: CZMAP.defaultValue(style.width, 5),
                    material: mat,
                    depthFailMaterial: mat
                }
            });
            li.entity = entity;
            this._enities.push(entity);
        }
        _removeLineEntity(li) {
            if (li.entity) {
                this._enities.remove(li.entity);
                this._czviewer.entities.remove(li.entity);
                li.entity = undefined;
            }
        }
        _checkNodeName(name) {
            if (!CZMAP.defined(name)) {
                let index = 1;
                while (true) {
                    name = '新节点-' + index;
                    if (this._nodes.find(n => n.node.name === name) === undefined) {
                        return name;
                    }
                    index++;
                }
            }
            ///
            if (this._nodes.find(n => n.node.name === name)) {
                throw new Error('节点名称重复');
            }
            return name;
        }
        _clearAlone() {
            this._lines.slice().forEach(li => {
                if (li.nodes.length < 2)
                    this._removeLine(li);
            });
            this._nodes.slice().forEach(ni => {
                if (ni.lines.length === 0)
                    this._removeNode(ni);
            });
        }
        _removeLine(li) {
            li.removeAllNode();
            this._removeLineEntity(li);
            this._lines.remove(li);
        }
        _createNode(name, position, properties) {
            /// 构建新节点
            const node = {
                name: this._checkNodeName(name),
                properties: CZMAP.deepCopy(properties),
                position
            };
            const ni = new NetNodeInfo(node);
            ni.point = this._addPoint(position, ni);
            this._nodes.push(ni);
            this._selectPoint(ni.point);
            return ni;
        }
        _removeNode(ni) {
            this._removePoint(ni.point);
            this._nodes.remove(ni);
        }
        createLine(option) {
            const selected = this.selected;
            if (!selected) {
                this.alert('请选择一个节点节点');
                return;
            }
            ///
            const ni0 = selected.data;
            /// 在点的附近创建一个新的点
            const near = this._calcNearPoint(ni0);
            const ni1 = this._createNode(option.nodeName, near.point, option.nodeProperties || ni0.node.properties);
            /// 构建线条
            const line = { nodes: [], properties: option.lineProperties };
            const lineinfo = new NetLineInfo(line);
            lineinfo.addNode(ni0);
            lineinfo.addNode(ni1);
            line.nodes.push(ni0.node.name, ni1.node.name);
            line.modified = true;
            this._lines.push(lineinfo);
            this._createLineEntity(lineinfo);
        }
        removeSelectLines() {
            const selected = this.selected;
            if (!selected) {
                this.alert('请选择一个节点节点');
                return;
            }
            const data = selected.data;
            new Set(data.lines).forEach(li => {
                this._removeLine(li);
            });
            this._clearAlone();
        }
        cloneSelectPoint(option) {
            const name = this._checkNodeName(option.name);
            const selected = this.selected;
            if (!selected) {
                this.alert('请选择一个节点节点');
                return;
            }
            const ni0 = selected.data;
            if (ni0.lines.length > 1) {
                this.alert('不支持对枢纽节点的复制');
                return false;
            }
            const li = ni0.lines[0];
            const index = li.points.indexOf(selected.coordinate);
            if (index === -1) {
                throw new Error('无法找到对应的节点');
            }
            const near = this._calcNearPointOnLine(ni0, li);
            const ni1 = this._createNode(name, near.point, option.properties || ni0.node.properties);
            const target_index = near.forward ? index + 1 : index;
            /// 将新节点插入线中
            li.insertNode(target_index, ni1);
            li.line.nodes.splice(target_index, 0, name);
            li.line.modified = true;
        }
        removeSelectPoint() {
            const selected = this.selected;
            if (!selected) {
                this.alert('请选择一个节点节点');
                return;
            }
            const ni = selected.data;
            ni.lines.slice().forEach(li => {
                li.removeNode(ni);
                li.line.nodes.remove(ni.node.name);
                li.line.modified = true;
            });
            this._removeNode(ni);
            this._clearAlone();
        }
        _onTranslatePoint(pi) {
            const ni = pi.data;
            ni.lines.forEach(li => {
                li.line.modified = true;
            });
        }
        _onSelectedPoint(pi) {
        }
        /**
         * 计算指定点浮点的点位
         * @param pi
         */
        _calcNearPoint(pi, pixel = 50) {
            /// 计算像素大小，缩放模型，保持像素大小不变
            const position = Cesium.Cartesian3.clone(pi.point.position);
            const pixelSize = this._view3d.calcPixelSize(position);
            position.x += pixelSize * pixel;
            return { position, point: CZMAP.GeoMath.fromCartesian3(position) };
        }
        _calcNearPointOnLine(ni, li, pixel = 50) {
            if (li.nodes.length <= 1) {
                const { position, point } = this._calcNearPoint(ni);
                return { position, point, forward: true };
            }
            const index0 = li.nodes.indexOf(ni);
            if (index0 === -1) {
                throw new Error('内部错误，定点不存在');
            }
            let index1 = 0;
            if (index0 < li.nodes.length - 1) {
                index1 = index0 + 1;
            }
            else {
                index1 = index0 - 1;
            }
            ///
            const p0 = li.nodes[index0].point.position;
            const p1 = li.nodes[index1].point.position;
            const dist = Cesium.Cartesian3.distance(p0, p1);
            const pixelSize = this._view3d.calcPixelSize(p0);
            const size = pixelSize * pixel;
            let percent = size / dist;
            if (percent > 0.5)
                percent = 0.5;
            const position = Cesium.Cartesian3.lerp(p0, p1, percent, new Cesium.Cartesian3());
            return { position, point: CZMAP.GeoMath.fromCartesian3(position), forward: index1 > index0 };
        }
    }
    CZMAP.NetEditor = NetEditor;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    function asPolylinePositions(pts, result) {
        let pre;
        let index = 0;
        pts.forEach(p => {
            const pos = Cesium.Cartesian3.fromDegrees(...p, undefined, result[index]);
            if (!Cesium.Cartesian3.equals(pre, pos)) {
                result[index] = (pos);
                pre = pos;
                index++;
            }
        });
        result.length = index;
        return result;
    }
    class PolylineEditor extends CZMAP.CoordinateEditor {
        constructor(view) {
            super(view);
        }
        startEdit(option) {
            this.clear();
            option.polylines.forEach(pts => {
                const data = { polyline: pts };
                pts.forEach(p => {
                    this._addPoint(p, data);
                });
                if (option.style) {
                    const mat = CZMAP.Polyline3D.getStrokeMaterialProperty(option.style.detail);
                    const entity = this._czviewer.entities.add({
                        polyline: {
                            positions: new Cesium.CallbackProperty((time, result) => asPolylinePositions(pts, result), false),
                            width: CZMAP.defaultValue(option.style.width, 5),
                            material: mat,
                            depthFailMaterial: mat
                        }
                    });
                    data.entity = entity;
                    this._enities.push(entity);
                }
            });
            this._beginEdit();
        }
        stopEdit() {
            this._endEdit();
        }
        cloneSelect() {
            const selected = this.selected;
            if (!selected) {
                this.alert('请选择一个节点节点');
                return;
            }
            const data = selected.data;
            const index = data.polyline.indexOf(selected.coordinate);
            if (index === -1) {
                throw new Error('无法找到对应的节点');
            }
            const cpi = this._clonePoint(selected, selected.data);
            data.polyline.splice(index + 1, 0, cpi.coordinate);
        }
        removeSelect() {
            const selected = this.selected;
            if (!selected) {
                this.alert('请选择一个节点节点');
                return;
            }
            const data = selected.data;
            const index = data.polyline.indexOf(selected.coordinate);
            if (index === -1) {
                throw new Error('无法找到对应的节点');
            }
            this._removePoint(selected);
            data.polyline.splice(index, 1);
        }
        _onTranslatePoint(pi) {
        }
        _onSelectedPoint(pi) {
        }
    }
    CZMAP.PolylineEditor = PolylineEditor;
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const DynamicCircleMaterialType = 'DynamicCircleMaterialType';
    let DynamicCircleMode;
    (function (DynamicCircleMode) {
        /** 延径向 */
        DynamicCircleMode[DynamicCircleMode["OnRadial"] = 0] = "OnRadial";
        /** 延X轴 */
        DynamicCircleMode[DynamicCircleMode["OnAxisX"] = 1] = "OnAxisX";
        /** 延Y轴 */
        DynamicCircleMode[DynamicCircleMode["OnAxisY"] = 2] = "OnAxisY";
    })(DynamicCircleMode = CZMAP.DynamicCircleMode || (CZMAP.DynamicCircleMode = {}));
    class DynamicCircleMaterialProperty {
        constructor(options) {
            this._definitionChanged = new Cesium.Event();
            this['color'] = CZMAP.CesiumAttrib.getColor(options === null || options === void 0 ? void 0 : options.color);
            this['speed'] = options === null || options === void 0 ? void 0 : options.speed;
            this['repeat'] = options === null || options === void 0 ? void 0 : options.repeat;
            this['mode'] = options === null || options === void 0 ? void 0 : options.mode;
        }
        ;
        get isConstant() {
            return false;
        }
        get definitionChanged() {
            return this._definitionChanged;
        }
        getType(time) {
            return DynamicCircleMaterialType;
        }
        getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = Cesium.Property.getValueOrDefault(this._color, time, Cesium.Color.RED, result.color);
            result.speed = Cesium.Property.getValueOrDefault(this._speed, time, 10, result.speed);
            result.repeat = Cesium.Property.getValueOrDefault(this._repeat, time, 1, result.repeat);
            result.mode = Cesium.Property.getValueOrDefault(this._mode, time, 0, result.mode);
            return result;
        }
        equals(other) {
            return (this === other ||
                (other instanceof DynamicCircleMaterialProperty &&
                    Cesium.Property.equals(this._color, other._color) &&
                    Cesium.Property.equals(this._speed, other._speed) &&
                    Cesium.Property.equals(this._repeat, other._repeat) &&
                    Cesium.Property.equals(this._mode, other._mode)));
        }
    }
    CZMAP.DynamicCircleMaterialProperty = DynamicCircleMaterialProperty;
    Object.defineProperties(DynamicCircleMaterialProperty.prototype, {
        color: Cesium.createPropertyDescriptor('color'),
        speed: Cesium.createPropertyDescriptor('speed'),
        repeat: Cesium.createPropertyDescriptor('repeat'),
        mode: Cesium.createPropertyDescriptor('mode')
    });
    const DynamicCircleMaterialSource = `
        //js
        uniform vec4 color;
        uniform float speed;
        uniform float repeat;
        uniform float mode;

        float circlePing(float r, float v1, float v2, float v3, float v4)
        {
            r = 1.0 - fract(r);
            return smoothstep(v1, v2, r) - smoothstep(v3, v4, r);
        }

        czm_material czm_getMaterial(czm_materialInput materialInput)
        {
            czm_material material = czm_getDefaultMaterial(materialInput);
            float time = fract(czm_frameNumber * speed / 1000.0);
            float r = 0.0;
            if (mode == 0.0)
            {
                vec2 st = (materialInput.st * 2.0  - 1.0);
                vec2 center = vec2(0.);
                r = length(st - center);
            }
            else if (mode == 1.0)
            {
                r = materialInput.st.x;
            }
            else 
            {
                r = materialInput.st.y;
            }
            
            float flag = circlePing(r * repeat - time, 0.01, 0.05, 0.05, 0.5);
            material.alpha = flag * smoothstep(1.0, 0.9, r);
            material.diffuse = flag * color.rgb;
            return material;
        }
        //!js
    `;
    Cesium.Material._materialCache.addMaterial(DynamicCircleMaterialType, {
        fabric: {
            type: DynamicCircleMaterialType,
            uniforms: {
                color: new Cesium.Color(1.0, 0.0, 0.0, 1.0),
                speed: 10.0,
                repeat: 1,
                mode: 0
            },
            source: DynamicCircleMaterialSource
        },
        translucent: function (material) {
            return true;
        }
    });
})(CZMAP || (CZMAP = {}));
var CZMAP;
(function (CZMAP) {
    const LineFlowMaterialType = 'LineFlowMaterialType';
    /**
     * 流线材质
     */
    class LineFlowMaterialProperty {
        constructor(options) {
            this._definitionChanged = new Cesium.Event();
            this._color = undefined;
            this._speed = undefined;
            this._percent = undefined;
            this._gradient = undefined;
            this['color'] = options.color;
            this['speed'] = options.speed;
            this['percent'] = options.percent;
            this['gradient'] = options.gradient;
        }
        ;
        get isConstant() {
            return false;
        }
        get definitionChanged() {
            return this._definitionChanged;
        }
        getType(time) {
            return LineFlowMaterialType;
        }
        getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = Cesium.Property.getValueOrDefault(this._color, time, Cesium.Color.RED, result.color);
            result.speed = Cesium.Property.getValueOrDefault(this._speed, time, 5.0, result.speed);
            result.percent = Cesium.Property.getValueOrDefault(this._percent, time, 0.1, result.percent);
            result.gradient = Cesium.Property.getValueOrDefault(this._gradient, time, 0.01, result.gradient);
            return result;
        }
        equals(other) {
            return (this === other ||
                (other instanceof LineFlowMaterialProperty &&
                    Cesium.Property.equals(this._color, other._color) &&
                    Cesium.Property.equals(this._speed, other._speed) &&
                    Cesium.Property.equals(this._percent, other._percent) &&
                    Cesium.Property.equals(this._gradient, other._gradient)));
        }
    }
    CZMAP.LineFlowMaterialProperty = LineFlowMaterialProperty;
    Object.defineProperties(LineFlowMaterialProperty.prototype, {
        color: Cesium.createPropertyDescriptor('color'),
        speed: Cesium.createPropertyDescriptor('speed'),
        percent: Cesium.createPropertyDescriptor('percent'),
        gradient: Cesium.createPropertyDescriptor('gradient'),
    });
    /// glsl
    const LineFlowMaterialSource = `
            //js
            uniform vec4 color;
            uniform float speed;
            uniform float percent;
            uniform float gradient;
            
            czm_material czm_getMaterial(czm_materialInput materialInput)
            {
                czm_material material = czm_getDefaultMaterial(materialInput);
                vec2 st = materialInput.st;
                float t = fract(czm_frameNumber * speed / 1000.0);
                t *= (1.0 + percent);
                float alpha = smoothstep(t- percent, t, st.s) * step(-t, -st.s);
                alpha += gradient;
                material.diffuse = color.rgb;
                material.alpha = alpha;
                return material;
            }
        //!js
        `;
    Cesium.Material._materialCache.addMaterial(LineFlowMaterialType, {
        fabric: {
            type: LineFlowMaterialType,
            uniforms: {
                color: new Cesium.Color(1.0, 0.0, 0.0, 1.0),
                speed: 10.0,
                percent: 0.1,
                gradient: 0.01
            },
            source: LineFlowMaterialSource
        },
        translucent: function () {
            return true;
        }
    });
})(CZMAP || (CZMAP = {}));
//# sourceMappingURL=czmap-s.js.map
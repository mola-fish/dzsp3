var WindEngine;!function(e){function t(e,t,n){var r=e.createShader(t);if(e.shaderSource(r,n),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS))throw new Error(e.getShaderInfoLog(r));return r}function n(e,t,n,r,i,a,o,s){var _=e.createTexture();return e.bindTexture(e.TEXTURE_2D,_),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,t),n?e.texImage2D(e.TEXTURE_2D,0,a,r,i,0,o,s,n):e.texImage2D(e.TEXTURE_2D,0,a,r,i,0,o,s,null),e.bindTexture(e.TEXTURE_2D,null),_}e.createProgram=function(e,n,r){var i=e.createProgram(),a=t(e,e.VERTEX_SHADER,n),o=t(e,e.FRAGMENT_SHADER,r);if(e.attachShader(i,a),e.attachShader(i,o),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(i));for(var s={program:i,vs:a,fs:o,uniforms:{},attributes:{}},_=e.getProgramParameter(i,e.ACTIVE_ATTRIBUTES),u=0;u<_;u++){var d=e.getActiveAttrib(i,u);s.attributes[d.name]=e.getAttribLocation(i,d.name)}for(var f=e.getProgramParameter(i,e.ACTIVE_UNIFORMS),c=0;c<f;c++){var m=e.getActiveUniform(i,c);s.uniforms[m.name]=e.getUniformLocation(i,m.name)}return s},e.deleteProgram=function(e,t){t&&(e.deleteShader(t.vs),e.deleteShader(t.fs),e.deleteProgram(t.program))},e.createTexture=function(e,t,r,i,a){return n(e,t,r,i,a,e.RGBA,e.RGBA,e.UNSIGNED_BYTE)},e.createTextureEx=n,e.createRenderbuffer=function(t,n,r,i){var a=t.createRenderbuffer();if(t.bindRenderbuffer(t.RENDERBUFFER,a),t instanceof WebGL2RenderingContext){var o=t.getParameter(t.MAX_SAMPLES);i=e.defaultValue(i,0),i=Math.min(i,o),t.renderbufferStorageMultisample(t.RENDERBUFFER,i,t.RGBA8,n,r)}else t.renderbufferStorage(t.RENDERBUFFER,t.RGBA4,n,r);return t.bindRenderbuffer(t.RENDERBUFFER,null),a},e.deleteGLObject=function(e,t){e&&(t instanceof WebGLTexture?e.deleteTexture(t):t instanceof WebGLBuffer?e.deleteBuffer(t):t instanceof WebGLProgram?e.deleteProgram(t):t instanceof WebGLFramebuffer?e.deleteFramebuffer(t):t instanceof WebGLRenderbuffer?e.deleteRenderbuffer(t):t instanceof WebGLShader&&e.deleteShader(t))},e.bindTexture=function(e,t,n){e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,t)},e.createVertexBuffer=function(e,t){var n=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),n},e.createIndexBuffer=function(e,t){var n=e.createBuffer();return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW),n},e.bindAttribute=function(e,t,n,r){e.bindBuffer(e.ARRAY_BUFFER,t),e.vertexAttribPointer(n,r,e.FLOAT,!1,0,0),e.enableVertexAttribArray(n)},e.bindElement=function(e,t){e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)},e.bindFramebufferTex2D=function(e,t,n){e.bindFramebuffer(e.FRAMEBUFFER,t),n&&(e instanceof WebGL2RenderingContext?e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0):e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0))},e.bindFramebufferRBO=function(e,t,n){e.bindFramebuffer(e.FRAMEBUFFER,t),n&&e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,n)}}(WindEngine||(WindEngine={})),function(e){e.Shaders={DrawVert:"",DrawFrag:"",QuadVert:"",UpdateFrag:"",ScreenVert:"",ScreenFrag:""}}(WindEngine||(WindEngine={})),function(e){function t(e){return null!=e}e.defined=t,e.defaultValue=function(e,n){return t(e)?e:n}}(WindEngine||(WindEngine={})),function(e){var t=["#FFFFFF"],n={noWebgl2:!1,msaaSamples:8,renderScale:1},r=function(){function r(r){this._isWebGl2=!1,this._numParticles=16384,this.pointSize=1.6,this.opacity=1,this.spdFilterMin=0,this.spdFilterMax=100,this.fadeOpacity=.955,this.speedFactor=.5,this.dropRate=.043,this.dropRateBump=.01,this.pointAge=.7,this._clearTag=!1,this._lastFrameTime=0,this._lastFramePassed=0,this._maxValue=32,this._maxColor=100,this._drawExtent=[],this._inExtent=[],this._option=Object.assign({},n,r),this._createMemoryCanvas();var i=this._memContext;i&&(this._drawProgram=e.createProgram(i,e.Shaders.DrawVert,e.Shaders.DrawFrag),this._screenProgram=e.createProgram(i,e.Shaders.ScreenVert,e.Shaders.ScreenFrag),this._updateProgram=e.createProgram(i,e.Shaders.QuadVert,e.Shaders.UpdateFrag),this._quadBuffer=e.createVertexBuffer(i,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1])),this._framebuffer=i.createFramebuffer(),this._backgroundFBO=i.createFramebuffer(),this.numParticles=this._numParticles,this.setColors(t))}return r.prototype.setWindUV=function(e,t,n,r,i){this.setWindData({datau:e,datav:t,width:n,height:r,extent:i,flipY:!1})},r.prototype.setWind=function(e,t,n,r){this.setWindData({data:e,width:t,height:n,extent:r,flipY:!1})},Object.defineProperty(r.prototype,"params",{get:function(){return{numParticles:this.numParticles,pointSize:this.pointSize,opacity:this.opacity,fadeOpacity:this.fadeOpacity,speedFactor:this.speedFactor,dropRate:this.dropRate,dropRateBump:this.dropRateBump,spdFilterMin:this.spdFilterMin,spdFilterMax:this.spdFilterMax,pointAge:this.pointAge}},set:function(e){Object.assign(this,this.params,e)},enumerable:!1,configurable:!0}),r.prototype.setWindData=function(t){var n=this._memContext;if(n){var r=this._width=t.width,i=this._height=t.height,a=t.noDataValueU,o=t.noDataValueV;if(!t.data){if(!t.datau||!t.datav)throw"bad param, need data or data uv(datau and datav)";for(var s=t.datau,_=t.datav,u=r*i,d=new Float32Array(2*u),f=0;f<u;++f)d[2*f]=s[f],d[2*f+1]=_[f];t.data=d}this._extent=t.extent;var c=r*i;this._maxValue=function(e,t){for(var n=e.length,r=0;r<n;++r){var i=Math.abs(e[r]);t<i&&(t=i)}return t}(t.data,0),this._maxValue+=1;for(var m=2*this._maxValue,l=t.flipY?-1:1,h=t.flipY?i-1:0,p=new Uint8Array(4*c),x=0;x<i;++x)for(var v=0;v<r;++v){var g=2*(v+(x*l+h)*r),b=4*(v+x*r),E=t.data[g],T=t.data[g+1];E===a&&(E=0),T===o&&(T=0),p[b]=(E+this._maxValue)/m*255,p[b+1]=(T+this._maxValue)/m*255,p[b+2]=0,p[b+3]=0}e.deleteGLObject(n,this._windTexture),this._windTexture=e.createTexture(n,n.LINEAR,p,this._width,this._height)}},r.prototype.setColors=function(t){var n=this._memContext;if(n){e.deleteGLObject(n,this._colorTexture);var r=function(e){var t=document.createElement("canvas"),n=t.getContext("2d");t.width=256,t.height=1;for(var r=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,a=0;a<e.length;++a){"object"==typeof(_=e[a])&&(_.min<r&&(r=_.min),_.max>i&&(i=_.max))}r===Number.POSITIVE_INFINITY&&(r=0,i=50);var o=i,s=n.createLinearGradient(0,0,256,0);for(a=0;a<e.length;++a){var _,u=a/e.length;"object"==typeof(_=e[a])&&(u=(_.max+_.min)/2/o,_=_.color),s.addColorStop(u,_)}return n.fillStyle=s,n.fillRect(0,0,256,1),{colors:new Uint8Array(n.getImageData(0,0,256,1).data),min:r,max:i}}(t);this._maxColor=r.max,this._colorTexture=e.createTexture(n,n.LINEAR,r.colors,256,1)}},Object.defineProperty(r.prototype,"numParticles",{get:function(){return this._numParticles},set:function(t){var n=this._memContext;if(n){for(var r=1;r*r<t;)r*=2;if(this.particleStateResolution!==r){var i=this.particleStateResolution=r;this._numParticles=i*i,e.deleteGLObject(n,this._currentStateTex2D),e.deleteGLObject(n,this._previousStateTex2D),e.deleteGLObject(n,this._vertexBuffer),e.deleteGLObject(n,this._indexBuffer);for(var a=new Float32Array(11*this._numParticles),o=0;o<11*this._numParticles;++o)a[o]=o;var s=[0,1,2,0,2,10,10,2,3,10,3,4,10,4,5,10,5,6,10,6,7,10,7,8,10,8,9],_=new Uint32Array(27*this._numParticles),u=function(e){s.forEach((function(t,n){_[27*e+n]=t+11*e}))};for(o=0;o<this._numParticles;++o)u(o);var d=n instanceof WebGL2RenderingContext?n.RGBA32F:n.RGBA,f=this._extFloatTex?n.FLOAT:n.UNSIGNED_BYTE;this._currentStateTex2D=e.createTextureEx(n,n.NEAREST,null,i,i,d,n.RGBA,f),this._previousStateTex2D=e.createTextureEx(n,n.NEAREST,null,i,i,d,n.RGBA,f),this._vertexBuffer=e.createVertexBuffer(n,a),this._indexBuffer=e.createIndexBuffer(n,_),this.clearParticles()}}},enumerable:!1,configurable:!0}),r.prototype.updateSize=function(t,n){if(this._memCanvas.width!==t||this._memCanvas.height!==n){this._memCanvas.width=t,this._memCanvas.height=n,this._memCanvas.style.width=t+"px",this._memCanvas.style.height=n+"px";var r=this._memContext;if(r){e.deleteGLObject(r,this._screenRBO),e.deleteGLObject(r,this._screenTex2D),e.deleteGLObject(r,this._backgroundTex2D);var i=this._RBOWidth=t*this._option.renderScale|0,a=this._RBOHeight=n*this._option.renderScale|0;this._backgroundTex2D=e.createTexture(r,r.LINEAR,null,i,a),r instanceof WebGL2RenderingContext?(this._screenRBO=e.createRenderbuffer(r,i,a,16),e.bindFramebufferTex2D(r,this._backgroundFBO,this._backgroundTex2D)):this._screenTex2D=e.createTexture(r,r.LINEAR,null,i,a),this.clearParticles()}}},r.prototype.updateExtent=function(e){this._drawExtent=e,this.clearParticles()},r.prototype.destroy=function(){var t=this._memContext;t&&(this._screenRBO=e.deleteGLObject(t,this._screenRBO),this._screenTex2D=e.deleteGLObject(t,this._screenTex2D),this._backgroundTex2D=e.deleteGLObject(t,this._backgroundTex2D),this._windTexture=e.deleteGLObject(t,this._windTexture),this._colorTexture=e.deleteGLObject(t,this._colorTexture),this._currentStateTex2D=e.deleteGLObject(t,this._currentStateTex2D),this._previousStateTex2D=e.deleteGLObject(t,this._previousStateTex2D),this._vertexBuffer=e.deleteGLObject(t,this._vertexBuffer),this._indexBuffer=e.deleteGLObject(t,this._indexBuffer),this._drawProgram=e.deleteProgram(t,this._drawProgram),this._updateProgram=e.deleteProgram(t,this._updateProgram),this._screenProgram=e.deleteProgram(t,this._screenProgram),this._framebuffer=e.deleteGLObject(t,this._framebuffer),this._backgroundFBO=e.deleteGLObject(t,this._backgroundFBO),this._quadBuffer=e.deleteGLObject(t,this._quadBuffer))},r.prototype.clearParticles=function(){this._clearTag=!0},Object.defineProperty(r.prototype,"canvas",{get:function(){return this._memCanvas},enumerable:!1,configurable:!0}),r.prototype._createMemoryCanvas=function(){var e={antialias:!1,alpha:!0,premultipliedAlpha:!0};if(this._memCanvas=document.createElement("CANVAS"),this._option.noWebgl2||(this._memContext=this._memCanvas.getContext("webgl2",e)),this._memContext?this._isWebGl2=!0:(this._isWebGl2=!1,this._memContext=this._memCanvas.getContext("webgl",e)),this._memContext){console.info("WebGL Wind, using:",this._isWebGl2?"webgl2":"webgl");var t=this._memContext;if(t instanceof WebGL2RenderingContext){this._extFloatTex=1,this._extUintIndex=1;t.getExtension("EXT_color_buffer_float")}else this._extFloatTex=t.getExtension("OES_texture_float"),this._extUintIndex=t.getExtension("OES_element_index_uint"),t.getExtension("WEBGL_color_buffer_float")}else console.error("WebGL not support!")},r.prototype.draw=function(){if(this._windTexture&&this._drawExtent){var e=(new Date).getTime(),t=e-this._lastFrameTime;0==this._lastFramePassed&&(t=10),t>1e3&&(t=10,this._clearTag=!0),this._lastFrameTime=e,this._lastFramePassed=t/1e3;var n=this._inExtent,r=this._extent[2]-this._extent[0],i=this._extent[3]-this._extent[1];n[0]=(this._drawExtent[0]-this._extent[0])/r,n[1]=(this._extent[3]-this._drawExtent[3])/i,n[2]=(this._drawExtent[2]-this._extent[0])/r,n[3]=(this._extent[3]-this._drawExtent[1])/i;var a=this._memContext;a.disable(a.DEPTH_TEST),a.disable(a.STENCIL_TEST),this._clearTag&&(a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT)),this._updateParticles(),this._drawScreen(),this._clearTag=!1}},r.prototype._drawScreen=function(){var t=this._memContext,n=this._RBOWidth,r=this._RBOHeight;if(t.viewport(0,0,n,r),this._isWebGl2?e.bindFramebufferRBO(t,this._framebuffer,this._screenRBO):e.bindFramebufferTex2D(t,this._framebuffer,this._screenTex2D),t.clear(t.COLOR_BUFFER_BIT),this._clearTag||this._drawTexture(this._backgroundTex2D,this.fadeOpacity),this._drawParticles(),t instanceof WebGL2RenderingContext)t.bindFramebuffer(t.READ_FRAMEBUFFER,this._framebuffer),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this._backgroundFBO),t.clearBufferfv(t.COLOR,0,[0,0,0,1]),t.blitFramebuffer(0,0,n,r,0,0,n,r,t.COLOR_BUFFER_BIT,t.NEAREST);else{var i=this._backgroundTex2D;this._backgroundTex2D=this._screenTex2D,this._screenTex2D=i}t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),e.bindFramebufferTex2D(t,null),t.clear(t.COLOR_BUFFER_BIT),t.viewport(0,0,t.canvas.width,t.canvas.height),this._drawTexture(this._backgroundTex2D,.9),t.disable(t.BLEND)},r.prototype._drawParticles=function(){var t=this._memContext,n=this._drawProgram;t.useProgram(n.program),e.bindAttribute(t,this._vertexBuffer,n.attributes.a_index,1),e.bindElement(t,this._indexBuffer),e.bindTexture(t,this._windTexture,0),t.uniform1i(n.uniforms.u_wind,0),e.bindTexture(t,this._colorTexture,1),t.uniform1i(n.uniforms.u_color_ramp,1),e.bindTexture(t,this._currentStateTex2D,2),t.uniform1i(n.uniforms.u_particles,2),e.bindTexture(t,this._previousStateTex2D,3),t.uniform1i(n.uniforms.u_particles2,3),t.uniform2f(n.uniforms.u_wind_max,this._maxValue,this._maxValue),t.uniform1f(n.uniforms.u_color_max,this._maxColor),t.uniform2f(n.uniforms.u_range_min,this._inExtent[0],this._inExtent[1]),t.uniform2f(n.uniforms.u_range_max,this._inExtent[2],this._inExtent[3]),t.uniform2f(n.uniforms.u_target_size,this._RBOWidth,this._RBOHeight),t.uniform1f(n.uniforms.u_point_size,this.pointSize),t.uniform1f(n.uniforms.u_opacity,this.opacity),t.uniform1f(n.uniforms.u_particles_res,this.particleStateResolution),t.drawElements(t.TRIANGLES,15*this._numParticles,t.UNSIGNED_INT,0)},r.prototype._drawTexture=function(t,n){var r=this._memContext,i=this._screenProgram;r.useProgram(i.program),r.clearColor(0,0,0,0),r.clear(r.COLOR_BUFFER_BIT),e.bindAttribute(r,this._quadBuffer,i.attributes.a_pos,2),e.bindTexture(r,t,0),r.uniform1i(i.uniforms.u_screen,0),r.uniform1f(i.uniforms.u_opacity,n),r.uniform2f(i.uniforms.u_resolution,this._RBOWidth,this._RBOHeight),r.drawArrays(r.TRIANGLES,0,6)},r.prototype._updateParticles=function(){var t=this._memContext;e.bindFramebufferTex2D(t,this._framebuffer,this._previousStateTex2D),t.viewport(0,0,this.particleStateResolution,this.particleStateResolution);var n=this._updateProgram;t.useProgram(n.program),e.bindAttribute(t,this._quadBuffer,n.attributes.a_pos,2),e.bindTexture(t,this._windTexture,0),t.uniform1i(n.uniforms.u_wind,0),e.bindTexture(t,this._currentStateTex2D,1),t.uniform1i(n.uniforms.u_particles,1),t.uniform2f(n.uniforms.u_wind_max,this._maxValue,this._maxValue),t.uniform1f(n.uniforms.u_spd_filter_min,this.spdFilterMin),t.uniform1f(n.uniforms.u_spd_filter_max,this.spdFilterMax),t.uniform2f(n.uniforms.u_range_min,this._inExtent[0],this._inExtent[1]),t.uniform2f(n.uniforms.u_range_max,this._inExtent[2],this._inExtent[3]),t.uniform2f(n.uniforms.u_target_size,this._RBOWidth,this._RBOHeight),t.uniform1f(n.uniforms.u_rand_seed,200*Math.random()),t.uniform1f(n.uniforms.u_speed_factor,this.speedFactor),t.uniform1f(n.uniforms.u_drop_rate,this.dropRate),t.uniform1f(n.uniforms.u_drop_rate_bump,this.dropRateBump),t.uniform1f(n.uniforms.u_pointAge,this.pointAge),t.uniform1f(n.uniforms.u_tag,this._clearTag?1:0),t.uniform1f(n.uniforms.u_time_passed,this._lastFramePassed),t.drawArrays(t.TRIANGLES,0,6);var r=this._currentStateTex2D;this._currentStateTex2D=this._previousStateTex2D,this._previousStateTex2D=r},r}();e.WindGL=r}(WindEngine||(WindEngine={})),function(e){var t=function(){function t(t,n){this._flagNum=2,this._flag=0,this._map=t,this._view=t.getView(),this._wind=new e.WindGL(n),this._createLayer(),this._render()}return Object.defineProperty(t.prototype,"layer",{get:function(){return this._layer},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"windGL",{get:function(){return this._wind},enumerable:!1,configurable:!0}),t.prototype.setWindUV=function(e,t,n,r,i){this._wind.setWindUV(e,t,n,r,i),this._layer.setExtent(i)},t.prototype.setWind=function(e,t,n,r){this._wind.setWind(e,t,n,r),this._layer.setExtent(r)},t.prototype.setWindData=function(e){this._wind.setWindData(e),this._layer.setExtent(e.extent)},t.prototype.destroy=function(){var e;cancelAnimationFrame(this._afHandle),this._wind.destroy(),this._wind=null,null===(e=this._map)||void 0===e||e.removeLayer(this._layer),this._layer=null,this._source=null},t.prototype._createLayer=function(){var e,t=this;this._source=new ol.source.ImageCanvas({canvasFunction:function(e,n,r,i,a){return t._canvasFunction(e,n,r,i,a)},projection:this._view.getProjection(),ratio:1}),this._layer=new ol.layer.Image({source:this._source}),null===(e=this._map)||void 0===e||e.addLayer(this._layer)},t.prototype._canvasFunction=function(e,t,n,r,i){return this._wind.updateSize(r[0],r[1]),this._wind.updateExtent(e),this._wind.draw(),this._wind.canvas},t.prototype._render=function(){var e=this;0==this._flag&&(this._wind.draw(),this._map.render()),this._flag=(this._flag+1)%this._flagNum,this._afHandle=requestAnimationFrame((function(){return e._render()}))},t}();e.WindOlLayer=t}(WindEngine||(WindEngine={})),WindEngine.Shaders.DrawFrag="//片元着色器源代码。片元着色器：进行逐片元处理过程。\nprecision mediump float;\nuniform sampler2D u_wind;\nuniform sampler2D u_color_ramp; \n\n///\nuniform float u_opacity;\n\n///\nuniform vec2 u_wind_max;\nuniform float u_color_max;\n\n///\nuniform vec2 u_range_min;\nuniform vec2 u_range_max;\n\n///\nvarying vec2 v_particle_pos;\n\n\nfloat angle_convert(float dir) \n{\n    if (dir < 0.0) { dir = dir + 360.0; }\n    return dir;\n} \n\nconst vec2 c_tex_min = vec2(0.0, 0.0);\nconst vec2 c_tex_max = vec2(1.0, 1.0);\n\nvec4 texture2DEx(sampler2D tex, vec2 pos, vec2 vmin, vec2 vmax)\n{\n    vec2 size = vmax - vmin;\n    vec2 cd = vmin + pos * size;\n    if (any(lessThan(cd, c_tex_min)) || any(greaterThan(cd, c_tex_max)))\n    {\n        discard;\n    }\n\n    ///\n    return texture2D(tex, cd);\n}\n\nvoid main() \n{\n    /// 获取当前风场的矢量\n    vec2 fakev = texture2DEx(u_wind, v_particle_pos, u_range_min, u_range_max).xy;\n\n    /// 实际风向量\n    vec2 velocity = mix(-u_wind_max, u_wind_max, fakev);  \n\n    ///  实际风速          \n    float speed = length(velocity); \n    if (speed / u_wind_max.x < 0.006) discard;\n\n    ///\n    gl_FragColor = texture2D(u_color_ramp, vec2(speed / u_color_max, 0));\n    gl_FragColor.a = gl_FragColor.a * u_opacity;\n}",WindEngine.Shaders.DrawVert="//GLSL ES语言\n//顶点着色器源代码。顶点着色器：用来描述顶点特性（gl_Position、gl_PointSize）\n//用于绘制粒子的顶点着色器程序\nprecision mediump float;//指定精度\nattribute float a_index; \n\n//当前帧的粒子纹理\nuniform sampler2D u_particles;\n\n//上一帧的粒子纹理\nuniform sampler2D u_particles2;\n\n/// 当前画布的尺寸\nuniform vec2 u_target_size;\n\n//保存粒子状态的纹理尺寸\nuniform float u_particles_res;\n\n//粒子像素大小\nuniform float u_point_size;\n\n//从顶点着色器到片元着色器传数据\n/// 粒子的位置\nvarying vec2 v_particle_pos; \n\nvoid main() \n{\n    /// 粒子的序号\n    float index = floor(a_index / 11.0);\n    /// 当前粒子三角形点序号\n    int mdx = int(mod(a_index, 11.0));\n\n    /// 解析粒子的位置索引\n    vec2 ipos = vec2(\n        fract(index / u_particles_res),\n        floor(index / u_particles_res) / u_particles_res);\n\n    /// 获取当前粒子的坐标\n    vec4 px = texture2D(u_particles, ipos);\n\n    /// 获取上一帧粒子的坐标\n    vec4 px2 = texture2D(u_particles2, ipos);\n    if (px.z == 0.0) {px2 = px;}\n\n    /// \n    vec2 p1 = px.xy * u_target_size;\n    vec2 p0 = px2.xy * u_target_size;\n    //vec2 p0 = px.zw * u_target_size;\n    vec2 pp = p1 - p0;\n\n    ///\n    vec2 dir = normalize(pp); \n    vec2 dira = vec2(dir.y, -dir.x);\n    vec2 dirb = vec2(-dir.y, dir.x);\n    vec2 dirc = normalize(dir + dira);\n    vec2 dird = normalize(dir + dirb);\n\n    ///\n    vec2 ps, ds;\n    if      (mdx ==  0) { ps = p0; ds = dira; }\n    else if (mdx ==  1) { ps = p0; ds = dirb; }\n    else if (mdx ==  2) { ps = p1; ds = dirb; }\n    else if (mdx ==  3) { ps = p1; ds = normalize(dirb + dird);; }\n    else if (mdx ==  4) { ps = p1; ds = dird; }\n    else if (mdx ==  5) { ps = p1; ds = normalize(dir + dird); }\n    else if (mdx ==  6) { ps = p1; ds = dir; }\n    else if (mdx ==  7) { ps = p1; ds = normalize(dir + dirc); }\n    else if (mdx ==  8) { ps = p1; ds = dirc; }\n    else if (mdx ==  9) { ps = p1; ds = normalize(dira + dirc); }\n    else   /*mdx == 10*/{ ps = p1; ds = dira; }\n\n    ///\n    vec2 pos = ps + ds * u_point_size / 2.0 + (mod(index, 5.0)) / 2.5;\n    v_particle_pos = pos / u_target_size;\n    \n    ///\n    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);//齐次坐标，最后一位为1\n}",WindEngine.Shaders.QuadVert="//顶点着色器源代码\nprecision mediump float;\n\n/// 顶点坐标\nattribute vec2 a_pos;\n\n/// 输出纹理坐标\nvarying vec2 v_tex_pos;\n\n/// \nvoid main() \n{\n    v_tex_pos = 1.0 - a_pos;\n    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n}",WindEngine.Shaders.UpdateFrag="//片元着色器源代码\n//更新粒子的片段着色器\nprecision highp float;\n\n/// 风场数据\nuniform sampler2D u_wind;\n/// 粒子状态\nuniform sampler2D u_particles;\n\n/// 风速数据的实际值域\nuniform vec2 u_wind_max;\nfloat f_wind_max = u_wind_max.x;\n\n/// 显示的数据范围\nuniform vec2 u_range_min;\nuniform vec2 u_range_max;\n\n/// 画布尺寸\nuniform vec2 u_target_size;\n\n/// 速度因子\nuniform float u_speed_factor;\n\n/// 随机数种子\nuniform float u_rand_seed;\n\n/// \nuniform float u_drop_rate;\nuniform float u_drop_rate_bump;\nuniform float u_pointAge;\n\n/// 速度过滤器\nuniform float u_spd_filter_min;\nuniform float u_spd_filter_max;\n\n/// 经的时间，单位：秒\nuniform float u_time_passed;\n\n/// 视图范围是否变化\nuniform float u_tag;\n\n/// 粒子的坐标\nvarying vec2 v_tex_pos; \n\n//   generator\nconst vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\nfloat rand(const vec2 co) \n{\n    float t = dot(rand_constants.xy, co);\n    return fract(sin(t) * (rand_constants.z + t));\n}\n\n/// 基于范围的纹理采样\nvec4 texture2DEx(sampler2D tex, vec2 pos, vec2 vmin, vec2 vmax)\n{\n    vec2 size = vmax - vmin;\n    return texture2D(tex, vmin + pos * size);\n}\n\nfloat point_tag=0.0;\n\nvoid main() \n{    \n    /// 获取粒子的当前位置\n    vec4 pp = texture2D(u_particles, v_tex_pos);\n    vec2 pos0 = pp.xy;\n\n    /// 从风场数据中获取粒子的当前位置的风速数据\n    vec2 fakev = texture2DEx(u_wind, pos0, u_range_min, u_range_max).xy;\n    \n    /// 计算实际风向矢量\n    vec2 velocity = mix(-u_wind_max, u_wind_max, fakev);\n\n    /// 计算风的速度\n    float speed_t = length(velocity);\n\n    /// 计算粒子移动的偏移量\n    vec2 offset = vec2(velocity.x, -velocity.y) * u_speed_factor / u_wind_max;\n\n    /// 粒子的最新位置\n    vec2 pos1 = pos0 + offset / u_target_size * 500.0 * u_time_passed;\n\n    /// 用于粒子下落的随机种子\n    vec2 seed = v_tex_pos * u_rand_seed;\n    \n    /// 下降率是粒子在随机位置重新启动的机会，以避免退化\n    float drop_rate;\n    float drop; float timep = 0.0;\n    \n    //如果视图范围变化\n    if (u_tag == 1.0 || speed_t < u_spd_filter_min || speed_t > u_spd_filter_max )\n    {\n        drop = 1.0;    \n        timep = rand(seed) * u_pointAge;\n    }\n    /// 如果当前点是新点，并且速度小于整体速度的0.2，则随机重新打点\n    else if (pp.z == 0.0 && speed_t < f_wind_max * 0.2 && rand(seed) < 0.5)\n    {\n        drop = 1.0;\n    }\n    /// 若粒子流动时间大于例子生产周期, 则随机产生新的随机粒子\n    else if (pp.w > u_pointAge)\n    {\n        drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n        drop = step(1.0 - drop_rate, rand(seed));     \n    }    \n\n    /// 返回pos1或random_pos\n    vec2 random_pos = vec2(rand(seed + 1.3), rand(seed + 2.1));  \n    vec2 posp1 = mix(pos1, random_pos, drop); \n    \n    vec2 st = mix(pp.zw + u_time_passed, vec2(0.0,timep), drop);\n\n    //输出粒子最新位置\n    gl_FragColor = vec4(posp1,st);\n}\n",WindEngine.Shaders.ScreenVert="//顶点着色器源代码\nprecision mediump float;\n\n/// 顶点坐标\nattribute vec2 a_pos;\n\n/// 输出纹理坐标\nvarying vec2 v_tex_pos;\n\n\nvoid main() {\n\n    ///\n    v_tex_pos = 1.0 - a_pos;\n    ///\n    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n}",WindEngine.Shaders.ScreenFrag="//片元着色器源代码\n//绘制指定的纹理到屏幕上\n\nprecision mediump float;\n\n/// 要绘制的贴图\nuniform sampler2D u_screen;\n\n/// 不透明度\nuniform float u_opacity; \n\n///\nuniform vec2 u_resolution;\n\n/// 纹理坐标\nvarying vec2 v_tex_pos; \n\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) \n{\n    ///\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) \n{\n\tvec2 inverseVP = 1.0 / resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\n///\nvoid main() \n{ \n    vec2 fragCoord = v_tex_pos * u_resolution; \n\tvec4 color; \n\n    ////\n    if (u_opacity == 1.0)\n    {\n        vec2 v_rgbNW;\n        vec2 v_rgbNE;\n        vec2 v_rgbSW;\n        vec2 v_rgbSE;\n        vec2 v_rgbM;\n        texcoords(fragCoord, u_resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n        color = fxaa(u_screen, fragCoord, u_resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    }\n    else \n        color = texture2D(u_screen, v_tex_pos);\n\n    ///\n    gl_FragColor = vec4(color * u_opacity); \n}";
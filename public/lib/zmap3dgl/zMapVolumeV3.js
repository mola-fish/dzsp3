var ZMapVolume;!function(e){class t{static c3ToCartographic(e){return Cesium.Cartographic.fromCartesian(e)}static c3ToCartographicDegrees(e){let t=Cesium.Cartographic.fromCartesian(e);return this.cartographic2CartographicDegrees(t)}static cartographic2CartographicDegrees(t){return e.LongLatHeight.formCartographic(t)}static c3ByDegrees(e,t){return e.toCartesian3(t)}static c3ByRadians(e){return Cesium.Cartesian3.fromRadians(e.longitude,e.latitude,e.height)}static fromDegreesArrayWithHeight(e){const t=[];for(let i=0;i<e.length;i+=3)t.push(Cesium.Cartesian3.fromDegrees(e[i],e[i+1],e[i+2]));return t}static radians2Degrees(e){return Cesium.Math.toDegrees(e)}static degrees2Radians(e){return Cesium.Math.toRadians(e)}static cartographicAdd(t,i){return new e.LongLatHeight(t.longitude+i.longitude,t.latitude+i.latitude,Math.max(t.height,i.height))}static expansion(e,t,i){let n=(t[0]-e[0])/i,s=(t[1]-e[1])/i,o=(t[2]-e[2])/i,a=[];for(let r=0;r<i;r++)r===i-1?a.push(...t):a.push(e[0]+n*r,e[1]+s*r,e[2]+o*r);return a}static expansionC3(e,i,n){let s=Cesium.Cartographic.fromCartesian(e),o=Cesium.Cartographic.fromCartesian(i),a=[Cesium.Math.toDegrees(s.longitude),Cesium.Math.toDegrees(s.latitude),s.height],r=[Cesium.Math.toDegrees(o.longitude),Cesium.Math.toDegrees(o.latitude),o.height];return Cesium.Cartesian3.fromDegreesArrayHeights(t.expansion(a,r,n))}static mergeMax(...t){let i=t[0].longitude,n=t[0].latitude,s=t[0].height;for(let e=0,o=t.length;e<o;e++)i=Math.max(i,t[e].longitude),n=Math.max(n,t[e].latitude),s=Math.max(s,t[e].height);return new e.LongLatHeight(i,n,s)}static mergeMin(...t){let i=t[0].longitude,n=t[0].latitude,s=t[0].height;for(let e=0,o=t.length;e<o;e++)i=Math.min(i,t[e].longitude),n=Math.min(n,t[e].latitude),s=Math.min(s,t[e].height);return new e.LongLatHeight(i,n,s)}static pointPlaneInstance(e,t,i){let n=Cesium.Cartesian3.subtract(t,e,new Cesium.Cartesian3(0,0,0)),s=Cesium.Cartesian3.normalize(n,new Cesium.Cartesian3(0,0,0)),o=Cesium.Plane.fromPointNormal(e,s);return Cesium.Plane.getPointDistance(o,i)}}e.ConvertTool=t}(ZMapVolume||(ZMapVolume={})),function(e){class t{constructor(t,i,n,s,o,a){this.xmin=t,this.ymin=i,this.zmin=n,this.xmax=s,this.ymax=o,this.zmax=a,this.center=[(s+t)/2,(o+i)/2,(a+n)/2],this.size=[s-t,o-i,a-n],this.from=new e.LongLatHeight(t,i,n),this.to=new e.LongLatHeight(s,o,a)}static fromStartEnd(e,i){return new t(e.longitude,e.latitude,e.height,i.longitude,i.latitude,i.height)}static fromStartEndArray(e,i){return new t(e[0],e[1],e[2],i[0],i[1],i[2])}}e.LongLatBox=t}(ZMapVolume||(ZMapVolume={})),function(e){class t{constructor(e,t,i){this.longitude=e,this.latitude=t,this.height=i}toCartographic(e){return Cesium.Cartographic.fromDegrees(this.longitude,this.latitude,this.height)}toCartesian3(e){return Cesium.Cartesian3.fromDegrees(this.longitude,this.latitude,this.height)}static fromDegrees(e,i,n){return new t(e,i,n)}static fromRadians(e,i,n){return new t(Cesium.Math.toDegrees(e),Cesium.Math.toDegrees(i),n)}static formCartographic(e){return this.fromRadians(e.longitude,e.latitude,e.height)}static fromCartesian3(e){const i=new t;return Cesium.Cartographic.fromCartesian(e,void 0,i),i.longitude=Cesium.Math.toDegrees(i.longitude),i.latitude=Cesium.Math.toDegrees(i.latitude),i}}e.LongLatHeight=t}(ZMapVolume||(ZMapVolume={})),function(e){e.Shaders={vertexShader:"",fragmentShader:"",materialShader:""}}(ZMapVolume||(ZMapVolume={})),function(e){e.VolumeBiningable=class{constructor(t){this._show=!0,this._viewer=t.cesium.viewer,this._scene=t.cesium.scene,this._entityTool=new e.EntityTool(this._viewer),this._box=new e.LongLatBox(0,0,0,.01,.01,1110)}binding(e){this._vol=e}get show(){return this._show}set show(e){this._show=e,this.onShowChanged(e)}}}(ZMapVolume||(ZMapVolume={})),function(e){let t,i,n;!function(e){e[e.GLOBE=1]="GLOBE",e[e.BOX=2]="BOX"}(t=e.VolumeMode||(e.VolumeMode={})),function(e){e[e.FORWARD=1]="FORWARD",e[e.BACKWORD=2]="BACKWORD"}(i=e.VolumeRayDir||(e.VolumeRayDir={})),function(e){e[e.GLOBE_VOLUME=1]="GLOBE_VOLUME",e[e.GLOBE_SLICE=2]="GLOBE_SLICE",e[e.BOX_VOLUME=3]="BOX_VOLUME",e[e.BOX_SLICE=4]="BOX_SLICE"}(n||(n={}));class s extends e.VolumeBiningable{constructor(n,s){if(super(n),this._sampleNum=256,this._dataValueRange=new Cesium.Cartesian2(0,1),this._center=new Cesium.Cartesian3,this._boxSizeInMeter=new Cesium.Cartesian3,this._boxMatrix=new Cesium.Matrix4,this._boxMatrixInv=new Cesium.Matrix4,this._slice={x:.5,y:.5,z:.5},this._rangeMin=[.01,.01,.01],this._rangeMax=[.99,.99,.99],this._rayDir=i.BACKWORD,this._globeV2=!0,this._appranceCaches={},this._cubeTex={},this._colorTex={},this._clearPreRender=null,this._temp_lc=new Cesium.Cartesian3,this._temp_wcc=new Cesium.Cartographic,this._temp_dir=new Cesium.Cartesian3,this._temp_planes=[new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0),new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0),new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0),new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0),new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0),new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0)],this._temp_results=[new Cesium.Cartesian3,new Cesium.Cartesian3,new Cesium.Cartesian3,new Cesium.Cartesian3,new Cesium.Cartesian3,new Cesium.Cartesian3],this._temp_sphere1=new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO,0),this._temp_sphere2=new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO,0),this._temp_sr1=new Cesium.Interval,this._temp_sr2=new Cesium.Interval,this._createDefaultTexture(),s=s||{},this._name=s.name?s.name:"Volume_TimeStap_"+Date.now(),this._sliceNum=s.sliceNum?s.sliceNum:[8,8],this._sampleNum=Cesium.defaultValue(s.sampleNum,256),this._scale=s.scale?s.scale:[1,1,1],this._offset=s.offset?s.offset:[0,0,0],this._vol_url=s.url?s.url:"BaseWhite",this._color_url=s.colorMap,this._turn=s.turn||[0,0,0],this._line=[0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],this.blongElement=s.blongElement,this._bindings=[],this._handlers={},this._vol_model={pri:null,apprance:null,mat:null},this._sec_model={pri:[],anypri:null,apprance:null,mat:null},s.dataValueRange&&(this._dataValueRange.x=s.dataValueRange[0],this._dataValueRange.y=s.dataValueRange[1]),this.filterParam=s.filterParam||{},this._mode=s&&s.mode===t.GLOBE?t.GLOBE:t.BOX,this._rayDir=s.rayDir?s.rayDir:i.FORWARD,e.FilterEdit&&!this._filterControl){const t=this.filterParam,i=document.createElement("div");i.className="analysis",i.setAttribute("data-allow","volume"),this.blongElement?"string"==typeof this.blongElement?document.querySelector(this.blongElement).appendChild(i):"object"==typeof this.blongElement&&this.blongElement instanceof HTMLElement&&this.blongElement.appendChild(i):document.body.appendChild(i),this._filterControl=new e.FilterEdit(i,t),this._filterControl.onchangestatus=(e,t)=>{const i=[],n=this._filterControl,s=n.max_Value-n.min_Value;t.forEach(e=>{i.push(e[0]/s+n.min_Value,e[1]/s+n.min_Value)}),this.filterLine=i}}}_createDefaultTexture(){s._defaultTexture||(s._defaultTexture=new Cesium.Texture({context:this._scene.context,source:{width:1,height:1,arrayBufferView:new Uint8Array([0,0,0,0])},flipY:!1}))}loadData(t){t.min&&t.max&&(this._box=e.LongLatBox.fromStartEndArray(t.min,t.max)),t.url&&(this._vol_url=t.url),t.colorMap&&(this._color_url=t.colorMap),t.offset&&(this._offset=t.offset),t.scale&&(this._scale=t.scale),t.sliceNum&&(this._sliceNum=t.sliceNum),Cesium.defined(t.sampleNum)&&(this._sampleNum=t.sampleNum),t.mode&&(this._mode=t.mode),t.rayDir&&(this._rayDir=t.rayDir),t.dataValueRange&&(this._dataValueRange.x=t.dataValueRange[0],this._dataValueRange.y=t.dataValueRange[1]),this._loadImage(),this._apply()}set visible(e){this.show=e}get visible(){return this.show}set box(e){this._box=e,this._apply()}get box(){return this._box}get readyPromise(){return this._volImagePromise}set rayDir(e){this._rayDir=e,this._apply()}get rayDir(){return this._rayDir}set scale(e){this._scale=e,this._apply()}get scale(){return this._scale}set offset(e){this._offset=e,this._apply()}get offset(){return this._offset}set filterLine(e){if(this._line=e,e.length>16&&(e.length=16),e.length<16)for(let t=e.length;t<16;++t)e[t]=1;Array.isArray(e)&&this._applyUniforms(t=>t.u_VolFilterLine=e)}get filterLine(){return this._line}set sampleMum(e){this._sampleNum=e,this._apply()}get sampleNum(){return this._sampleNum}showVolume(){this.setVolume()}set volumeVisible(e){this._vol_model.pri&&(this._vol_model.pri.show=e)}set sliceVisible(e){this._sec_model.pri.forEach(t=>{t&&(t.show=!!e)})}set anySliceVisible(e){this._sec_model.anypri&&(this._sec_model.anypri.show=!!e)}set sliceXVisble(e){const t=this._sec_model.pri[0];t&&(t.show=!!e)}set sliceYVisble(e){const t=this._sec_model.pri[1];t&&(t.show=!!e)}set sliceZVisble(e){const t=this._sec_model.pri[2];t&&(t.show=!!e)}update(e){}_apply(){this.clearVolume(),this._calcParam(),this._bindings.forEach(e=>{e.update(this._rbox)}),this._rmode==n.BOX_VOLUME||this._rmode==n.GLOBE_VOLUME?this.setVolume():this._rmode!=n.BOX_SLICE&&this._rmode!=n.GLOBE_SLICE||this.setSlice(this._slice),this._clearPreRender||(this._clearPreRender=this._scene.preRender.addEventListener(this._preRender,this))}clean(){}_loadImage(){const e=[];function t(e){e.image&&(e.image.onerror=e.image.onload=()=>{},e.image=null),e.texture&&(e.texture.destroy(),e.texture=null)}const i=this._scene.context;function n(e,n,s){if(n instanceof HTMLImageElement){if(e.image&&e.image===n&&null!==e.texture)return;return t(e),e.image=n,e.texture=new Cesium.Texture({context:i,source:n}),e.texture.type="sampler2D",void s.push(Promise.resolve())}const o=n;if(e.image&&e.image.src===o&&null!==e.texture)return;t(e);const a=new Image,r=new Promise((t,n)=>{a.onload=()=>{a.width<=0||a.height<=0?n():(e.texture=new Cesium.Texture({context:i,source:a}),e.texture.type="sampler2D",t())},a.onerror=t=>{e.image=null,n("Load Volume Data Error!")}});a.crossOrigin="anonymous",a.src=o,s.push(r),e.image=a}n(this._cubeTex,this._vol_url,e),n(this._colorTex,this._color_url,e),e.length>0&&(this.clearMaterial(),this._volImagePromise=Promise.all(e))}binding(t){Array.isArray(t)||(t=[t]);for(let i=0;i<t.length;i++){let n=t[i];if(!(n instanceof e.VolumeBiningable))throw Error("请传入实现_Comon接口的实例");this._bindings.push(n),n.binding(this)}}on(e,t){e in this._handlers||(this._handlers[e]=[]);const i=Date.now();return this._handlers[e].push({handler:t,id:i}),i}off(e,t){if(e)if(t){if(this._handlers[e]){let i=this._handlers[e];for(let e=0;e<i.length;e++)if(i[e].id===t){i.splice(e,1);break}}}else this._handlers[e]=[];else this._handlers={}}emit(e,t){const i=this._handlers[e];for(let n=0;n<i.length;n++)"function"==typeof i[n].handler&&i[n].handler(e,t)}_imageReadyInvoke(e,i,...n){const s={cancel:!1,callback:()=>{this._mode===t.GLOBE?e.apply(this,n):i.apply(this,n)}};const o=this._volImagePromise.ss;o&&(o.cancel=!0),this._volImagePromise.ss=s,this._volImagePromise.then((function(){s.cancel||s.callback()}),(function(e){console.warn("load volume data error.",e)}))}_createAppearance(t,o,a){const r={u_SliceNumXf:this._sliceNum[0],u_SliceNumYf:this._sliceNum[1],u_ColorTex:this._colorTex.texture,u_CubeTex:this._cubeTex.texture,u_InvWorldMat:Cesium.Matrix4.toArray(this._boxMatrixInv),u_VolBoxMin:o,u_VolBoxMax:a,u_VolClipMin:new Cesium.Cartesian3(...this._rangeMin),u_VolClipMax:new Cesium.Cartesian3(...this._rangeMax),u_VolBoxRadius:this._boundRadius,u_VolFilterLine:this._line,u_Turn:new Cesium.Cartesian3(...this._turn),u_DataValueRange:this._dataValueRange},l=t===n.BOX_SLICE||t===n.GLOBE_SLICE||t===n.GLOBE_VOLUME&&this._globeV2,h=`mode:${t}-ray:${this._rayDir}`;let _=this._appranceCaches[h];if(!_){const o=`\n#define ZMAP_RENDER_MODE_GLOBE_VOLUME       ${n.GLOBE_VOLUME}\n#define ZMAP_RENDER_MODE_GLOBE_SLICE        ${n.GLOBE_SLICE}\n#define ZMAP_RENDER_MODE_BOX_VOLUME         ${n.BOX_VOLUME}\n#define ZMAP_RENDER_MODE_BOX_SLICE          ${n.BOX_SLICE}\n\n#define ZMAP_VOL_RAY_FORWARD     ${i.FORWARD}\n#define ZMAP_VOL_RAY_BACKWARD    ${i.BACKWORD}\n\n#define ZMAP_MODE ${t}\n#define ZMAP_VOL_RAY_DIR ${this._rayDir}\n#define ZMAP_GLOBEV2 ${this._globeV2?1:0}\n#define ZMAP_IN_BOX ${this._isInBox?1:0}\n#define ZMAP_VOL_SAMPLE_NUM ${this._sampleNum}\n#line 0\n${e.Shaders.materialShader}`,a=new Cesium.Material({translucent:!l,fabric:{type:"ZMapVolume-"+h,source:o,uniforms:r}});a._defaultTexture=s._defaultTexture,a._textures.u_CubeTex=this._cubeTex.texture,a._textures.u_ColorTex=this._colorTex.texture;const c={material:a,vertexShaderSource:e.Shaders.vertexShader,fragmentShaderSource:e.Shaders.fragmentShader,translucent:!l,faceForward:!0,closed:!1,renderState:{cull:{enabled:!l,face:l?Cesium.CullFace.BACK:Cesium.CullFace.FRONT},depthMask:!1,blending:Cesium.BlendingState.ALPHA_BLEND}};_=new Cesium.MaterialAppearance(c),this._appranceCaches[h]=_}return Object.assign(_.material.uniforms,r),_}setVolume(){if(this.sliceVisible=!1,this.anySliceVisible=!1,this._vol_model.pri)return this._rmode=this._mode==t.GLOBE?n.GLOBE_VOLUME:n.BOX_VOLUME,void(this.volumeVisible=!0);const e=this._globeV2?this._setVolumeOnGlobeV2:this._setVolumeOnGlobe;this._imageReadyInvoke(e,this._setVolumeOnBox)}_setVolumeOnBox(){const e=this._viewer;this._calcParam(),this._rmode=n.BOX_VOLUME;const t=this._boxSizeInMeter,i=Cesium.Cartesian3.fromElements(-t.x/2,-t.y/2,-t.z/2),s=Cesium.Cartesian3.fromElements(t.x/2,t.y/2,t.z/2);this._vol_model.apprance=this._createAppearance(n.BOX_VOLUME,i,s),this._vol_model.mat=this._vol_model.apprance.material;const o=new Cesium.BoxGeometry({minimum:i,maximum:s}),a=Cesium.BoxGeometry.createGeometry(o);e.scene.primitives.remove(this._vol_model.pri),this._vol_model.pri=new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:a,modelMatrix:this._boxMatrix,id:this._name}),asynchronous:!1,appearance:this._vol_model.apprance}),e.scene.primitives.add(this._vol_model.pri)}_setVolumeOnGlobe(){const e=this._viewer;this._calcParam(),this._rmode=n.GLOBE_VOLUME;let{xmin:t,xmax:i,ymin:s,ymax:o,zmin:a,zmax:r}=this._rbox;const l=new Cesium.RectangleGeometry({rectangle:Cesium.Rectangle.fromDegrees(t,s,i,o),height:a,extrudedHeight:r}),h=Cesium.RectangleGeometry.createGeometry(l);this._vol_model.apprance=this._createAppearance(n.GLOBE_VOLUME,new Cesium.Cartesian3(t,s,a),new Cesium.Cartesian3(i,o,r)),this._vol_model.mat=this._vol_model.apprance.material,e.scene.primitives.remove(this._vol_model.pri),this._vol_model.pri=new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:h,id:this._name}),allowPicking:!1,asynchronous:!1,appearance:this._vol_model.apprance}),e.scene.primitives.add(this._vol_model.pri)}_setVolumeOnGlobeV2(){const e=this._viewer;this._calcParam(),this._rmode=n.GLOBE_VOLUME;const t=this._boxSizeInMeter,i=[t.x,t.y,t.z],s=Math.max(t.x,t.y,t.z),{xmin:o,xmax:a,ymin:r,ymax:l,zmin:h,zmax:_}=this._rbox,c=this._sampleNum;let m;!function(e){e[e.X=0]="X",e[e.Y=1]="Y",e[e.Z=2]="Z"}(m||(m={}));const u=[o,r,h,a,l,_];function d(e,t,i,n,s,o,a){const{position:r,texcoord:l,indices:h}=a,_=r.length/3,c=u[i],m=u[n],d=u[s],p=u[i+3]-c,C=u[n+3]-m,x=u[s+3]-d,f=new Cesium.Cartesian3,g=[0,0,0],y=[0,0,0];g[s]=d+o*x,y[s]=o;for(let s=0;s<=t;++s){const o=s/t,a=m+C*o;for(let t=0;t<=e;++t){const e=t/10,s=c+p*e;g[i]=s,g[n]=a,y[i]=e,y[n]=o;const h=Cesium.Cartesian3.fromDegrees(g[0],g[1],g[2],void 0,f);r.push(h.x,h.y,h.z),l.push(...y)}}for(let i=0;i<t;++i)for(let t=0;t<e;++t){const n=_+i*(e+1)+t,s=n+1,o=n+e+1,a=o+1;h.push(n,s,a,n,a,o)}}function p(e,t,n,o,a){const r=i[n],l=Math.floor(r/s*c),h=o?l:0,_=o?1:-1,m={position:[],texcoord:[],indices:[]};for(let i=o?0:l;i!=h;i+=_)d(10,10,e,t,n,i/l,m);const u=new Cesium.GeometryAttributes;let p;u.position=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:m.position}),u.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m.texcoord}),m.indices instanceof Uint16Array||m.indices instanceof Uint32Array||(p=m.indices.length<65536?new Uint16Array(m.indices):new Uint32Array(m.indices));const C=new Cesium.Geometry({attributes:u,indices:p,boundingSphere:Cesium.BoundingSphere.fromVertices(m.position)});return new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:C}),asynchronous:!1,allowPicking:!1,compressVertices:!1,appearance:a})}this._vol_model.apprance=this._createAppearance(n.GLOBE_VOLUME,new Cesium.Cartesian3(o,r,h),new Cesium.Cartesian3(a,l,_)),this._vol_model.mat=this._vol_model.apprance.material;const C=new Cesium.PrimitiveCollection;C.add(p(m.X,m.Y,m.Z,!0,this._vol_model.apprance)),C.add(p(m.X,m.Y,m.Z,!1,this._vol_model.apprance)),C.add(p(m.X,m.Z,m.Y,!0,this._vol_model.apprance)),C.add(p(m.X,m.Z,m.Y,!1,this._vol_model.apprance)),C.add(p(m.Y,m.Z,m.X,!0,this._vol_model.apprance)),C.add(p(m.Y,m.Z,m.X,!1,this._vol_model.apprance)),e.scene.primitives.remove(this._vol_model.pri),this._vol_model.pri=C,e.scene.primitives.add(this._vol_model.pri)}setSlice(e){this.volumeVisible=!1,this.anySliceVisible=!1,(e=Cesium.defaultValue(e,{x:.5,y:.5,z:.5})).x=Cesium.Math.clamp(Cesium.defaultValue(e.x,this._slice.x),0,1),e.y=Cesium.Math.clamp(Cesium.defaultValue(e.y,this._slice.y),0,1),e.z=Cesium.Math.clamp(Cesium.defaultValue(e.z,this._slice.z),0,1);let i=!1;if(e&&(e.x==this._slice.x&&e.y==this._slice.y&&e.z==this._slice.z||(i=!0)),!i&&3==this._sec_model.pri.length)return this._rmode=this._mode==t.GLOBE?n.GLOBE_SLICE:n.BOX_SLICE,void(this.sliceVisible=!0);this._imageReadyInvoke(this._setSliceOnGlobe,this._setSliceOnBox,e)}_setSliceOnBox(e){const t=this._viewer;this._calcParam(),this._rmode=n.BOX_SLICE;const i=this._boxSizeInMeter,s=Cesium.Cartesian3.fromElements(-i.x/2,-i.y/2,-i.z/2),o=Cesium.Cartesian3.fromElements(i.x/2,i.y/2,i.z/2);this._sec_model.apprance||(this._sec_model.apprance=this._createAppearance(n.BOX_SLICE,s,o),this._sec_model.mat=this._sec_model.apprance.material);const a=new Uint32Array([0,1,3,3,2,0]),r=[];if(e.x!==this._slice.x){this._slice.x=e.x;const t=e.x*i.x+s.x;r[0]={name:"lonSection",position:new Float64Array([t,s.y,s.z,t,o.y,s.z,t,s.y,o.z,t,o.y,o.z]),normal:new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0])}}if(e.y!==this._slice.y){this._slice.y=e.y;const t=e.y*i.y+s.y;r[1]={name:"latSection",position:new Float64Array([s.x,t,s.z,o.x,t,s.z,s.x,t,o.z,o.x,t,o.z]),normal:new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0])}}if(e.z!==this._slice.z){this._slice.z=e.z;const t=e.z*i.z+s.z;r[2]={name:"heiSection",position:new Float64Array([s.x,s.y,t,o.x,s.y,t,s.x,o.y,t,o.x,o.y,t]),normal:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1])}}for(let e=0;e<r.length;e++){const i=r[e];if(!i)continue;const n=new Cesium.GeometryAttributes;n.position=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:i.position}),n.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:i.normal});const s=new Cesium.Geometry({attributes:n,indices:a,primitiveType:Cesium.PrimitiveType.TRIANGLES,boundingSphere:Cesium.BoundingSphere.fromVertices(i.position)}),o=new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:s,id:i.name,modelMatrix:this._boxMatrix}),asynchronous:!1,appearance:this._sec_model.apprance});t.scene.primitives.remove(this._sec_model.pri[e]),this._sec_model.pri[e]=o,t.scene.primitives.add(o)}}_setSliceOnGlobe(e){const t=this._viewer;this._calcParam(),this._rmode=n.GLOBE_SLICE;const{xmin:i,ymin:s,zmin:o,xmax:a,ymax:r,zmax:l}=this._rbox;this._sec_model.apprance||(this._sec_model.apprance=this._createAppearance(n.GLOBE_SLICE,new Cesium.Cartesian3(i,s,o),new Cesium.Cartesian3(a,r,l)),this._sec_model.mat=this._sec_model.apprance.material);const h=["lonSection","latSection","heiSection"],_=[null,null,null];if(e.x!=this._slice.x){this._slice.x=e.x;const t=i+e.x*(a-i),n=Cesium.WallGeometry.fromConstantHeights({positions:Cesium.Cartesian3.fromDegreesArray([t,s,t,r]),minimumHeight:o,maximumHeight:l,vertexFormat:Cesium.VertexFormat.POSITION_AND_NORMAL});_[0]=Cesium.WallGeometry.createGeometry(n)}if(e.y!=this._slice.y){this._slice.y=e.y;const t=s+e.y*(r-s),n=Cesium.WallGeometry.fromConstantHeights({positions:Cesium.Cartesian3.fromDegreesArray([i,t,a,t]),minimumHeight:o,maximumHeight:l,vertexFormat:Cesium.VertexFormat.POSITION_AND_NORMAL});_[1]=Cesium.WallGeometry.createGeometry(n)}if(e.z!=this._slice.z){this._slice.z=e.z;const t=o+e.z*(l-o),n=new Cesium.RectangleGeometry({rectangle:Cesium.Rectangle.fromDegrees(i,s,a,r),height:t,vertexFormat:Cesium.VertexFormat.POSITION_AND_NORMAL});_[2]=Cesium.RectangleGeometry.createGeometry(n)}for(let e=0;e<3;e++){if(!_[e])continue;const i=new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:_[e],id:h[e],attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.TRANSPARENT)}}),asynchronous:!1,appearance:this._sec_model.apprance});t.scene.primitives.remove(this._sec_model.pri[e]),this._sec_model.pri[e]=i,t.scene.primitives.add(i)}}setSliceAny(e,t){const i=this._viewer;this.volumeVisible=!1,this.sliceVisible=!1,i.scene.primitives.remove(this._sec_model.anypri),this._sec_model.anypri=null,this._imageReadyInvoke(this._setSliceAnyOnGlobe,this._setSliceAnyOnBox,e,t)}_setSliceAnyOnBox(e,t){const i=this._viewer;this._calcParam(),this._rmode=n.BOX_SLICE;const s=this._rbox.center,o=[111e3*(e[0]-s[0]),111e3*(e[1]-s[1]),e[2]-s[2]],a=[111e3*(t[0]-s[0]),111e3*(t[1]-s[1]),t[2]-s[2]],r=this._boxSizeInMeter,l=Cesium.Cartesian3.fromElements(-r.x/2,-r.y/2,-r.z/2),h=Cesium.Cartesian3.fromElements(r.x/2,r.y/2,r.z/2);this._sec_model.apprance||(this._sec_model.apprance=this._createAppearance(n.BOX_SLICE,l,h),this._sec_model.mat=this._sec_model.apprance.material);const _=new Uint32Array([0,1,3,3,2,0]),c=new Cesium.Cartesian3(o[0]-a[0],o[1]-a[1],0);Cesium.Cartesian3.normalize(c,c),Cesium.Cartesian3.cross(c,Cesium.Cartesian3.UNIT_Z,c);const m={position:new Float64Array([o[0],o[1],l.z,a[0],a[1],l.z,o[0],o[1],h.z,a[0],a[1],h.z]),normal:new Float32Array([c.x,c.y,c.z,c.x,c.y,c.z,c.x,c.y,c.z,c.x,c.y,c.z]),name:"anySection"},u=new Cesium.GeometryAttributes;u.position=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:m.position}),u.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m.normal});const d=new Cesium.Geometry({attributes:u,indices:_,primitiveType:Cesium.PrimitiveType.TRIANGLES,boundingSphere:Cesium.BoundingSphere.fromVertices(m.position)}),p=new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:d,id:m.name,modelMatrix:this._boxMatrix}),asynchronous:!1,appearance:this._sec_model.apprance});this._sec_model.anypri=p,i.scene.primitives.add(p)}_setSliceAnyOnGlobe(e,t){const i=this._viewer;this._calcParam(),this._rmode=n.GLOBE_SLICE;const{xmin:s,ymin:o,zmin:a,xmax:r,ymax:l,zmax:h}=this._rbox;this._sec_model.apprance||(this._sec_model.apprance=this._createAppearance(n.GLOBE_SLICE,new Cesium.Cartesian3(s,o,a),new Cesium.Cartesian3(r,l,h)),this._sec_model.mat=this._sec_model.apprance.material);const _=Cesium.WallGeometry.fromConstantHeights({positions:Cesium.Cartesian3.fromDegreesArray([e[0],e[1],t[0],t[1]]),minimumHeight:a,maximumHeight:h,vertexFormat:Cesium.VertexFormat.POSITION_AND_NORMAL}),c=Cesium.WallGeometry.createGeometry(_),m=new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:c,id:"slice_any",attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.TRANSPARENT)}}),asynchronous:!1,appearance:this._sec_model.apprance});this._sec_model.anypri=m,i.scene.primitives.add(m)}_applyUniforms(e){this._vol_model.mat&&e(this._vol_model.mat.uniforms),this._sec_model.mat&&e(this._sec_model.mat.uniforms)}_preRender(){if(!this._rbox)return;if(this._rmode==n.GLOBE_VOLUME&&this._globeV2){const t=this._viewer.camera.directionWC.clone(this._temp_dir);Cesium.Cartesian3.normalize(t,t),Cesium.Matrix4.multiplyByPointAsVector(this._boxMatrixInv,t,t);const n=Math.abs(t.x),o=Math.abs(t.y),a=Math.abs(t.z),r=[t.z,t.y,t.x];let l=(s=n,(e=a)>(i=o)?e>s?0:2:i>s?1:2);r[l]>0?l=2*l+1:l*=2;const h=this._vol_model.pri;for(let e=0;e<6;++e)h.get(e).show=e==l;return}var e,i,s;const o=this._viewer.camera.positionWC,a=Cesium.Cartesian3.subtract(this._center,o,this._temp_dir),r=new Cesium.Ray(o,a);let l=Number.MAX_VALUE;if(this._mode==t.BOX){const e=Cesium.Matrix4.multiplyByPoint(this._boxMatrixInv,o,this._temp_lc),t=this._boxSizeInMeter;this._isInBox=e.x<t.x&&e.x>-t.x&&e.y<t.y&&e.y>-t.y&&e.z<t.z&&e.z>-t.z;const i=(e,t,i,n)=>{Cesium.Cartesian3.clone(i,e.normal),Cesium.Cartesian3.clone(i,t.normal),e.distance=n/2,t.distance=-n/2,Cesium.Plane.transform(e,this._boxMatrix,e),Cesium.Plane.transform(t,this._boxMatrix,t)},[n,s,a,h,_,c]=this._temp_planes;i(n,s,Cesium.Cartesian3.UNIT_X,this._boxSizeInMeter.x),i(a,h,Cesium.Cartesian3.UNIT_Y,this._boxSizeInMeter.y),i(_,c,Cesium.Cartesian3.UNIT_Z,this._boxSizeInMeter.z);const m=Cesium.IntersectionTests.rayPlane;let[u,d,p,C,x,f]=this._temp_results;u=m(r,n,u),d=m(r,s,d),p=m(r,a,p),C=m(r,h,C),x=m(r,_,x),f=m(r,c,f);const g=function(e,t){if(e&&t){const i=Cesium.Cartesian3.distanceSquared(e,t);i<l&&(l=i)}};g(u,d),g(p,C),g(x,f)}else{const e=this._temp_sphere1,t=this._temp_sphere2;e.radius=this._rbox.zmax+6378137,t.radius=this._rbox.zmin+6378137;const i=this._scene.camera.positionCartographic,n=Cesium.Math.toDegrees(i.longitude),s=Cesium.Math.toDegrees(i.latitude),o=i.height,a=this._rbox;this._isInBox=n>a.xmin&&n<a.xmax&&s>a.ymin&&s<a.ymax&&o>a.zmin&&o<a.zmax;const h=Cesium.IntersectionTests.raySphere(r,e,this._temp_sr1),_=Cesium.IntersectionTests.raySphere(r,t,this._temp_sr2);if(h&&_){const e=Cesium.Ray.getPoint(r,h.start,this._temp_results[0]),t=Cesium.Ray.getPoint(r,_.start,this._temp_results[1]);l=Cesium.Cartesian3.distanceSquared(e,t)}}l=Math.sqrt(l),l>this._boundRadius&&(l=this._boundRadius),this._applyUniforms(e=>e.u_VolBoxRadius=l)}reset(){return this._scale=[1,1,1],this._offset=[0,0,0],this.setVolume()}onShowChanged(e){this.volumeVisible=e,this.sliceVisible=e,this.anySliceVisible=e}clearVolume(){const e=this._viewer.scene.primitives;e.remove(this._vol_model.pri),this._vol_model.pri=null,this._vol_model.apprance=null,this._vol_model.mat=null,this._sec_model.pri.forEach(t=>e.remove(t)),this._sec_model.pri.length=0,e.remove(this._sec_model.anypri),this._sec_model.anypri=null,this._sec_model.apprance=null,this._sec_model.mat=null,this._slice={x:-1,y:-1,z:-1},this._rbox=null}clearMaterial(){this._appranceCaches={}}destroy(){this._clearPreRender&&(this._clearPreRender(),this._clearPreRender=null),this.clearVolume(),this.clearMaterial(),this._cubeTex.texture&&(this._cubeTex.texture.destroy(),this._cubeTex.texture=null),this._colorTex.texture&&(this._colorTex.texture.destroy(),this._colorTex.texture=null)}set colorMap(e){e&&this._color_url!==e&&(this._color_url=e,this._applyUniforms(t=>t.u_ColorTex=e))}set volTurn(e){this._turn=e.map(e=>Number(!!e)),this._applyUniforms(e=>e.u_Turn=new Cesium.Cartesian3(...this._turn))}get volTurn(){return this._turn}set filter(e){e?this._filterControl&&(this._filterControl.element.style.visibility="visible"):this._filterControl&&(this._filterControl.element.style.visibility="hidden"),this._filterOpen=e}get filter(){return this._filterOpen}set range(e){const t=this._rbox,i=function(e){return Math.max(Math.min(e,.99),.01)},n=t.size,s=i((e.xmin-t.xmin)/n[0]),o=i((e.ymin-t.ymin)/n[1]),a=i((e.zmin-t.zmin)/n[2]),r=i((e.xmax-t.xmin)/n[0]),l=i((e.ymax-t.ymin)/n[1]),h=i((e.zmax-t.zmin)/n[2]);this._rangeMin=[s,o,a],this._rangeMax=[r,l,h],this._applyUniforms(e=>{Cesium.Cartesian3.fromElements(s,o,a,e.u_VolClipMin),Cesium.Cartesian3.fromElements(r,l,h,e.u_VolClipMax)})}_calcScaleOffsetBox(){const t=this._box,i=this._offset,n=this._scale,s=i[0],o=i[1],a=i[2],r=n[0],l=n[1],h=n[2];this._rbox=new e.LongLatBox(s+t.xmin*r,o+t.ymin*l,a+t.zmin*h,s+t.xmax*r,o+t.ymax*l,a+t.zmax*h)}getRealValue(e,t){return(e-this._offset[t])/this._scale[t]}_calcParam(){this._calcScaleOffsetBox();const e=Cesium.Cartesian3.fromDegrees(this._rbox.xmin,this._rbox.ymax,this._rbox.zmin),t=Cesium.Cartesian3.fromDegrees(this._rbox.xmin,this._rbox.ymin,this._rbox.zmin),i=Cesium.Cartesian3.fromDegrees(this._rbox.xmax,this._rbox.ymax,this._rbox.zmin),n=Cesium.Cartesian3.distance(e,i),s=Cesium.Cartesian3.distance(e,t),o=this._rbox.size[2];Cesium.BoundingSphere.fromCornerPoints,Cesium.Cartesian3.fromElements(n,s,o,this._boxSizeInMeter),this._boundRadius=Math.sqrt(n*n+s*s);const[a,r,l]=this._rbox.center;Cesium.Cartesian3.fromDegrees(a,r,l,null,this._center),Cesium.Transforms.eastNorthUpToFixedFrame(this._center,void 0,this._boxMatrix),Cesium.Matrix4.inverse(this._boxMatrix,this._boxMatrixInv)}}e.VolumeRender=s}(ZMapVolume||(ZMapVolume={})),function(e){e.EntityTool=class{constructor(e){this._default={lineWidth:2,pointSize:10,lineColor:Cesium.Color.CORAL,pointColor:Cesium.Color.DEEPSKYBLUE,textColor:Cesium.Color.DEEPSKYBLUE},this.viewer=e}set defaultOpt(e){this._default=Object.assign(this._default,e)}get defaultOpt(){return this._default}addPloyline(e,t){let i=Object.assign(this.getDefault(),t);return this.viewer.entities.add({polyline:{positions:e,material:i.lineColor,width:i.lineWidth,clampToGround:!1}})}getDefault(){return this._default}addPoint(e,t,i){let n=Object.assign(this.getDefault(),i);return e.map(e=>this.viewer.entities.add({position:e,point:{pixelSize:n.pointSize,color:n.pointColor},label:t}))}addPointWithLongitude(e,t){let i=Object.assign(this.getDefault(),t);return e.map(e=>this.viewer.entities.add({position:e,point:{pixelSize:i.pointSize,color:i.pointColor},label:{text:"\n\n\n\n"+(Cesium.Cartographic.fromCartesian(e).longitude/Math.PI*180).toFixed(1),font:"16px sans-serif",fillColor:i.textColor}}))}addPointWithLatitude(e,t){let i=Object.assign(this.getDefault(),t);return e.map(e=>this.viewer.entities.add({position:e,point:{pixelSize:i.pointSize,color:i.pointColor},label:{text:"\n\n"+(Cesium.Cartographic.fromCartesian(e).latitude/Math.PI*180).toFixed(1),font:"16px sans-serif",fillColor:i.textColor}}))}addSinglePointWithText(e,t,i){let n=Object.assign(this.getDefault(),i);return this.viewer.entities.add({position:e,point:{pixelSize:n.pointSize,color:n.pointColor},label:{text:t,font:"16px sans-serif",fillColor:n.textColor}})}}}(ZMapVolume||(ZMapVolume={})),function(e){let t;!function(e){e[e.NONE=0]="NONE",e[e.PICKED=1]="PICKED",e[e.INSERT=2]="INSERT"}(t||(t={}));class i{constructor(e,t){if(this._pointSize=4,this._selPointSize=5,this._margin=[40,20,50,40],this._arrowLen=30,!(e instanceof Element))throw new Error("请传入一个正确的页面元素");this.element=e,t=Object.assign({name_X:"属性值",split_X:4,min_X:0,max_X:100,min_Value:0,max_Value:100,name_Y:"透明度",split_Y:5,min_Y:0,max_Y:100,pointSize:4,bkColor:"#22344C",axisColor:"#C6CDCC",lineColor:"#FF0000",fontColor:"#C6CDCC",textSpace:2},t),this._name_X=t.name_X,this._split_X=t.split_X,this._min_X=t.min_X,this._max_X=t.max_X,this._name_Y=t.name_Y,this._split_Y=t.split_Y,this._min_Y=t.min_Y,this._max_Y=t.max_Y,this._min_Value=t.min_Value,this._max_Value=t.max_Value,this._pointSize=t.pointSize,this._bkColor=t.bkColor,this._axisColor=t.axisColor,this._lineColor=t.lineColor,this._fontColor=t.fontColor,this._textSpace=t.textSpace,this._line=t.line?t.line:[[0,0],[this._max_X,this._max_Y]],this._init(this.element)}get min_Value(){return this._min_Value}get max_Value(){return this._max_Value}set filterLine(e){this._line=e,this._draw(),this.onchangestatus(0,this._line)}get filterLine(){return this._line}_init(i){this._width=i.offsetWidth,this._height=i.offsetHeight,this._area=new e.LongLatBox(this._margin[0],this._margin[1],0,this._width-this._margin[2],this._height-this._margin[3],0),this._painter=document.createElement("canvas"),this._painter.width=this._width,this._painter.height=this._height,i.appendChild(this._painter),i.style.zIndex="1000",this._context=this._painter.getContext("2d"),this._toDrawCoord();let n={type:t.NONE};this._painter.addEventListener("mousedown",e=>{1===e.buttons&&n.type==t.INSERT?(this._trans_line.splice(n.index,0,[e.offsetX,e.offsetY]),this._draw(n.index),this._toLoginCoord()):2===e.buttons&&n.type==t.PICKED&&0!=n.index&&n.index!=this._trans_line.length-1&&(this._trans_line.splice(n.index,1),this._draw(),this._toLoginCoord())}),this._painter.addEventListener("mousemove",e=>{console.log(`move bt:${e.button} id:${n.index}, type:${n.type}`);const i=this._area,s=i.xmin,o=i.xmax,a=this._height-i.ymax,r=this._height-i.ymin;if(1===e.buttons&&n.type!==t.NONE){const t=Cesium.Math.clamp(e.offsetX,s,o),i=Cesium.Math.clamp(e.offsetY,a,r),l=n.index;if(0==l)this._trans_line[l]=[s,i];else if(l==this._trans_line.length-1)this._trans_line[l]=[o,i];else{this._trans_line[l]=[t,i];for(let t=1;t<this._trans_line.length-1-l;t++)this._trans_line[l+t][0]<=e.offsetX&&(this._trans_line[l+t][0]=e.offsetX);for(let t=0;t<l;t++)this._trans_line[t][0]>=e.offsetX&&(this._trans_line[t][0]=e.offsetX);e.offsetX>=o&&(this._trans_line.length=l+1),e.offsetX<=s&&(this._trans_line.splice(0,l),n.index=0)}this._draw(l),this._toLoginCoord(),this.onchangestatus(l,this._line)}else if(0===e.buttons){let i=[e.offsetX,e.offsetY];n=this._getSelectedPoint(i),n.type==t.INSERT&&(i[0]<s||i[0]>o||i[1]<a||i[1]>r)&&(n.type=t.NONE),this._draw(),n.type===t.PICKED&&this._draw_select(n.index)}}),this._painter.addEventListener("mouseup",e=>{this.onchangestatus(0,this._line)}),this._painter.addEventListener("mouseout",e=>{this.onchangestatus(0,this._line)}),this._draw()}_reset(){this._line=[[0,0],[this._max_X,this._max_Y]],this._toDrawCoord(),this._draw()}_resetMax(){this._line=[[0,this._max_Y],[this._max_X,this._max_Y]],this._toDrawCoord(),this._draw()}_resetPoints(e){this._line=e,this._toDrawCoord(),this._draw()}_draw(e){this.clearCanvas(),this._draw_axis(),this._draw_line(e)}_draw_axis(){let e=this._context;e.beginPath(),e.lineWidth=1,e.strokeStyle=this._axisColor,e.font="10px Courier New",e.fillStyle=this._fontColor;const t=this._area,i=this._arrowLen,n=(this._width,this._height),s=t.xmin,o=n-t.ymin,a=t.xmax,r=n-t.ymax,l=a+i,h=r-i;e.moveTo(s,o),e.lineTo(s,h),e.lineTo(s-4,h+4),e.moveTo(s,h),e.lineTo(s+4,h+4),e.moveTo(s,o),e.lineTo(l,o),e.lineTo(l-4,o-4),e.moveTo(l,o),e.lineTo(l-4,o+4),e.textAlign="left";const _=t.size[0]/this._split_X,c=Math.floor((this._max_X-this._min_X)/this._split_X);for(let t=1;t<=this._split_X;t++){const i=_*t+s;e.moveTo(i,o),t%this._textSpace==1?(e.lineTo(i,o+5),e.fillText((this._min_X+c*t).toFixed(0),i-5,o+15)):e.lineTo(i,o+3)}e.moveTo(a,o),e.lineTo(a,r),e.textAlign="right";const m=t.size[1]/this._split_Y,u=Math.floor((this._max_Y-this._min_Y)/this._split_Y);for(let t=0;t<this._split_Y;t++){const i=r+m*t;e.moveTo(s,i),e.lineTo(a,i),e.fillText((this._max_Y-u*t).toFixed(0),s-5,i)}e.stroke(),e.textAlign="left",e.fillText(this._name_X,l-15,o+15),e.textAlign="right",e.fillText(this._name_Y,s-5,h+10)}_draw_line(e){const t=this._context;t.lineWidth=1,t.strokeStyle=this._lineColor,t.beginPath(),t.moveTo(this._trans_line[0][0],this._trans_line[0][1]);for(let e=1;e<this._trans_line.length;e++)t.lineTo(this._trans_line[e][0],this._trans_line[e][1]);t.stroke(),t.lineWidth=1,t.fillStyle=this._lineColor;for(let e=0;e<this._trans_line.length;e++)t.beginPath(),t.arc(this._trans_line[e][0],this._trans_line[e][1],this._pointSize,0,2*Math.PI),t.fill();void 0!==e&&this._draw_select(e)}_draw_select(e){let t=this._context;t.lineWidth=1,t.fillStyle=this._lineColor,t.strokeStyle=this._axisColor,t.beginPath(),t.arc(this._trans_line[e][0],this._trans_line[e][1],this._selPointSize,0,2*Math.PI),t.stroke()}clearCanvas(){let e=this._context;e.fillStyle=this._bkColor,e.fillRect(0,0,this._width,this._height)}_toDrawCoord(){this._trans_line=[];const e=this._area,t=(this._width,this._height),i=this._max_X-this._min_X,n=this._max_Y-this._min_Y;for(let s=0;s<this._line.length;s++){let o=this._line[s].slice(0);o[0]=(o[0]-this._min_X)/i*e.size[0]+e.xmin,o[1]=t-(o[1]-this._min_Y)/n*e.size[1]-e.ymin,this._trans_line.push(o)}}_toLoginCoord(){const e=this._area,t=(this._width,this._height),i=this._max_X-this._min_X,n=this._max_Y-this._min_Y;this._line=[];for(let s=0;s<this._trans_line.length;s++){let o=this._trans_line[s].slice(0);o[0]=(o[0]-e.xmin)/e.size[0]*i+this._min_X,o[1]=(t-o[1]-e.ymin)/e.size[1]*n+this._min_Y,this._line.push(o)}}onchangestatus(e,t){}static _squareDistance(e,t){const i=e[0]-t[0],n=e[1]-t[1];return i*i+n*n}_getSelectedPoint(e){const n=this._trans_line,s=this._pointSize+1,o=s*s;for(let s=0;s<n.length;s++){if(i._squareDistance(e,n[s])<=o)return{type:t.PICKED,index:s,point:n[s]}}for(let i=0;i<n.length;i++)if(e[0]<n[i][0])return{type:t.INSERT,index:i,point:e};return{type:t.NONE,point:e}}}e.FilterEdit=i}(ZMapVolume||(ZMapVolume={})),function(e){class t extends e.VolumeBiningable{constructor(t,i){super(t),this.xSteps=[],this.ySteps=[],this.zSteps=[],this.gridLine=[],this.scale=[1,1,1];this.opt=Object.assign({stepX:1,stepY:1,stepZ:100,useOrigin:!1},i),this._entityTool=new e.EntityTool(this._viewer),this.opt.style&&(this._entityTool.defaultOpt=this.opt.style)}get style(){return this._entityTool.getDefault()}set style(e){this._entityTool.defaultOpt=e,this.update(this._box)}get option(){return this.opt}set option(e){this.opt=Object.assign(this.opt,e),this.update(this._box)}set scales(e){this.scale=e}get scales(){return this.scale}update(e){this._box=e,this.destroy(),this.init()}clean(){}init(){const{xmin:e,ymin:t,zmin:i,xmax:n,ymax:s,zmax:o}=this._box;this.xSteps=this.computeMiddleSpacing(e,n,this.opt.stepX),this.ySteps=this.computeMiddleSpacing(t,s,this.opt.stepY);const a=Math.abs(o-i);for(;a/this.opt.stepZ>10;)this.opt.stepZ*=10;this.zSteps=a&&this.opt.stepZ?this.computeMiddleSpacing(i,o,this.opt.stepZ):[],this.onShowChanged(this.show)}onShowChanged(e){e&&0==this.gridLine.length&&this.createGrid(),this.gridLine.forEach(t=>{t.show=e})}computeMiddleSpacing(e,t,i){let n=[],s=t-e;for(let e=0;e<s/i;e++)n.push(i*e);return s%i!=0&&n.push(s),n}createGrid(){this.gridLine=this.gridLine.concat(this._lineOnX(),this._lineOnY(),this._lineOnZ())}_lineOnX(){return this._lineAxis(this.xSteps,this.ySteps,this.zSteps,[0,1,2],[0,20])}_lineOnY(){return this._lineAxis(this.ySteps,this.xSteps,this.zSteps,[1,0,2],[-40,0])}_lineOnZ(){return this._lineAxis(this.zSteps,this.xSteps,this.ySteps,[2,0,1],[-40,20])}_lineAxis(e,t,i,n,s){const o=[],a=this._box.from,r=[a.longitude,a.latitude,a.height],l=[0,0,0];return e.forEach(e=>{const a=t.map(t=>(l[n[0]]=r[n[0]]+e,l[n[1]]=r[n[1]]+t,l[n[2]]=r[n[2]],Cesium.Cartesian3.fromDegrees(l[0],l[1],l[2]))),h=i.map(t=>(l[n[0]]=r[n[0]]+e,l[n[1]]=r[n[1]],l[n[2]]=r[n[2]]+t,Cesium.Cartesian3.fromDegrees(l[0],l[1],l[2])));h.reverse(),h.length=h.length-1;const _=h.concat(a);o.push(this._entityTool.addPloyline(_)),l[n[0]]=r[n[0]]+e,l[n[1]]=r[n[1]],l[n[2]]=r[n[2]];const c=Cesium.Cartesian3.fromDegrees(l[0],l[1],l[2]),m=this._vol.getRealValue(l[n[0]],n[0]).toFixed(1),u=this._entityTool.addSinglePointWithText(c,m);u.label.pixelOffset=new Cesium.Cartesian2(s[0],s[1]),o.push(u)}),o}destroy(){let e=this._viewer.entities;this.gridLine.forEach(t=>{e.remove(t)}),this.gridLine=[]}}e.GridLine=t}(ZMapVolume||(ZMapVolume={})),function(e){class t extends e.VolumeBiningable{constructor(e,t){super(e),this.eightPoint={},this._xoy=new Cesium.Plane(Cesium.Cartesian3.UNIT_Z,0),this._yoz=new Cesium.Plane(Cesium.Cartesian3.UNIT_X,0),this._xoz=new Cesium.Plane(Cesium.Cartesian3.UNIT_Y,0);this.opt=Object.assign({sliceSize:20},t),this.points=[],this.opt.style&&(this.style=this.opt.style),!this.planes&&(this.planes={})}get style(){return this._entityTool.getDefault()}set style(e){this._entityTool.defaultOpt=e,this.update(this._box)}update(e){this._box=e,this.destroy(),this.init()}clean(){}binding(e){this._vol=e}destroy(){let e=this._viewer.entities;for(let t in this.planes)e.remove(this.planes[t]);this.points&&this.points.forEach(t=>{e.remove(t)}),this.planes={},this.points=[]}init(){this.height=Math.abs(this._box.zmax-this._box.zmin),this._calcPoints(),this._calcPlanes();const t=this.eightPoint,i=this.opt.sliceSize,n=e.ConvertTool.expansionC3,s=e=>this._entityTool.addPloyline(new Cesium.CallbackProperty(e,!1));this.copy_to=e.ConvertTool.c3ByDegrees(this._box.to),this.copy_from=e.ConvertTool.c3ByDegrees(this._box.from),this.planes.p_top=s(()=>[...n(t.$001,t.$101,i),...n(t.$111,t.$011,i),t.$001]),this.planes.p_bottom=s(()=>[...n(t.$000,t.$100,i),...n(t.$110,t.$010,i),t.$000]),this.planes.p_left=s(()=>[t.$000,t.$010,t.$011,t.$001,t.$000]),this.planes.p_right=s(()=>[...n(t.$000,t.$100,i),...n(t.$110,t.$010,i),t.$000]),this.planes.p_front=s(()=>[...n(t.$000,t.$100,i),...n(t.$101,t.$001,i),t.$000]),this.planes.p_behind=s(()=>[...n(t.$010,t.$110,i),...n(t.$111,t.$011,i),t.$010]),this.points=this._entityTool.addPoint(this.sixPoint),this.handler(),this.onShowChanged(this.show)}_calcPoints(e,t){const i=Cesium.Cartesian3.fromDegrees;e=e||this._box.from,t=t||this._box.to;const n=e.longitude,s=e.latitude,o=e.height,a=t.longitude,r=t.latitude,l=t.height,h=(a+n)/2,_=(r+s)/2,c=(l+o)/2,m=i(n,s,o),u=i(a,s,o),d=i(a,r,o),p=i(n,r,o),C=i(n,s,l),x=i(a,s,l),f=i(n,r,l),g=i(a,r,l),y=i(h,_,l),v=i(n,_,c),b=i(a,_,c),S=i(h,_,o),w=i(h,s,c),M=i(h,r,c);Object.assign(this.eightPoint,{$000:m,$100:u,$110:d,$010:p,$001:C,$101:x,$011:f,$111:g}),this.sixPoint=[y,v,b,S,w,M]}_calcPlanes(){const e=this.sixPoint[1],t=this.sixPoint[0],i=this.sixPoint[5],n=Cesium.Cartesian3.fromDegrees(this._box.center[0],this._box.center[1],this._box.center[2]),s=new Cesium.Cartesian3;Cesium.Cartesian3.subtract(e,n,s),Cesium.Cartesian3.normalize(s,s),this._yoz=Cesium.Plane.fromPointNormal(n,s,this._yoz),Cesium.Cartesian3.subtract(i,n,s),Cesium.Cartesian3.normalize(s,s),this._xoz=Cesium.Plane.fromPointNormal(n,s,this._xoz),Cesium.Cartesian3.subtract(t,n,s),Cesium.Cartesian3.normalize(s,s),this._xoy=Cesium.Plane.fromPointNormal(n,s,this._xoy)}_setPoints(t,i){let n=e.ConvertTool.c3ToCartographicDegrees(i),s=e.ConvertTool.c3ToCartographicDegrees(this.copy_from),o=e.ConvertTool.c3ToCartographicDegrees(this.copy_to);const a=(e,t,i)=>e<t?t:e>i?i:e;switch(t){case 0:o.height=a(n.height,this._box.from.height,this._box.to.height);break;case 2:o.longitude=a(n.longitude,this._box.from.longitude,this._box.to.longitude);break;case 5:o.latitude=a(n.latitude,this._box.from.latitude,this._box.to.latitude);break;case 1:s.longitude=a(n.longitude,this._box.from.longitude,this._box.to.longitude);break;case 3:s.height=a(n.height,this._box.from.height,this._box.to.height);break;case 4:s.latitude=a(n.latitude,this._box.from.latitude,this._box.to.latitude)}this.copy_to=e.ConvertTool.c3ByDegrees(o),this.copy_from=e.ConvertTool.c3ByDegrees(s),this._calcPoints(s,o),this.points.forEach((e,t)=>{e.position=this.sixPoint[t]}),this._vol&&(this._vol.range=e.LongLatBox.fromStartEnd(s,o))}handler(){this.control=new Cesium.ScreenSpaceEventHandler(this._viewer.scene.canvas);let e=this.control,t=-1,i=!1;const n=new Cesium.Ray,s=this._viewer.scene.screenSpaceCameraController;e.setInputAction(()=>{i=!0,t>-1&&(s.enableRotate=!1)},Cesium.ScreenSpaceEventType.LEFT_DOWN),e.setInputAction(()=>{i=!1,s.enableRotate=!0},Cesium.ScreenSpaceEventType.LEFT_UP),e.setInputAction(e=>{if(!this.show)return;const s=this._viewer.camera.getPickRay(e.endPosition,n);if(i&&-1!=t){let e=this._getIntersectPointOnPlane(t,this.sixPoint[t],s);e&&this._setPoints(t,e)}else t=this._pickPoint(s),this._hoverPoint(t)},Cesium.ScreenSpaceEventType.MOUSE_MOVE)}_hoverPoint(e){-1!=e?this.points[e].point.pixelSize=1.5*this.style.pointSize:this.points.forEach(e=>e.point.pixelSize=this.style.pointSize)}_pickPoint(e){let t=-1,i=Number.MAX_VALUE;const n=new Cesium.Interval,s=this._viewer.canvas,o=s.clientWidth,a=s.clientHeight,r=new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO,1);return this.sixPoint.forEach((s,l)=>{Cesium.Cartesian3.clone(s,r.center),r.radius=1;const h=this._viewer.camera.getPixelSize(r,o,a);r.radius=h*this._entityTool.defaultOpt.pointSize;const _=Cesium.IntersectionTests.raySphere(e,r,n);void 0!==_&&_.start<i&&(i=_.start,t=l)}),t}_getIntersectPointOnPlane(e,t,i){let n,s;switch(e){case 1:case 2:n=this._xoy,s=this._xoz;break;case 4:case 5:n=this._xoy,s=this._yoz;break;case 0:case 3:n=this._xoz,s=this._yoz}const o=Cesium.Cartesian3.dot(i.direction,this._xoy.normal),a=Math.abs(o)<.707?n:s;return Cesium.IntersectionTests.rayPlane(i,a)||t}onShowChanged(e){this.points.forEach(t=>{t.show=e});for(let t in this.planes)this.planes[t].show=e}}e.RectPlane=t}(ZMapVolume||(ZMapVolume={})),function(e){e.SliceControl=class{constructor(e,t,i){this.slice=e,this.opt=i||{},this._createRoot(t),this._createChild(),this.init(),this.bindingEvent(),this._x=.5,this._y=.5,this._z=.5}init(){this.inited||(this.root.classList.add("scroll-control3D"),this.root.setAttribute("data-allow","volume"),this.root.addEventListener("click",t=>{if("span"===t.target.tagName.toLowerCase()){let i={X:e.SlicePlane.YOZ,Y:e.SlicePlane.XOZ,Z:e.SlicePlane.XOY}[t.target.innerHTML];"active"===t.target.className?(t.target.className="",this.slice.showPlane(i,!0)):(t.target.className="active",this.slice.showPlane(i,!1)),"function"==typeof this.opt.buttonClick&&this.opt.buttonClick(t,i,"active"===t.target.className?"show":"hide")}t.stopPropagation()}),this.inited=!0)}_createRoot(e){let t=document.createElement("div");return"string"==typeof e?document.querySelector(e).appendChild(t):"object"==typeof e&&e instanceof HTMLElement?e.appendChild(t):document.body.appendChild(t),this.root=t,t}_createChild(){this.root.innerHTML=this._createChildEle("X")+this._createChildEle("Y")+this._createChildEle("Z")}_createChildEle(e){return`\n                <div class="control">\n                    <span>${e}</span>\n                    <div class="scroll" id="scrollBar${e}">\n                        <div class="bar"></div>\n                        <div class="mask"></div>\n                    </div>\n                </div>\n    `}bindingEvent(){"function"!=typeof this.opt.move&&(this.opt.move=function(){}),this._createBar({el:"#scrollBarX",move:e=>{this._sliceOffset("_x",e),this.opt.move(e,"X","move")},end:e=>{this._sliceOffset("_x",e),this.opt.move(e,"X","end")}}),this._createBar({el:"#scrollBarY",move:e=>{this._sliceOffset("_y",e),this.opt.move(e,"Y","move")},end:e=>{this._sliceOffset("_y",e),this.opt.move(e,"Y","end")}}),this._createBar({el:"#scrollBarZ",move:e=>{this._sliceOffset("_z",e),this.opt.move(e,"Z","move")},end:e=>{this._sliceOffset("_z",e),this.opt.move(e,"Z","end")}})}_sliceOffset(e,t){this[e]=t.scale,this.slice.offset=[this._x,this._y,this._z]}_createBar(e){let t=this.root.querySelector(e.el),i=t.children[0],n=t.children[1],s=(new Date).getTime();i.onmousedown=function(i){let o=i.clientX-this.offsetLeft,a=this;document.onmousemove=function(i){let r=(new Date).getTime();if(r-s<17)return;s=r,a.style.left=i.clientX-o+"px";let l=parseInt(a.style.left);l<0?a.style.left=0:l>382&&(a.style.left="382px"),n.style.width=a.style.left,"function"==typeof e.move&&e.move({type:"move",scrollBar:t,elText:e.el,scale:parseInt(a.style.left)/382})},document.onmouseup=function(){"function"==typeof e.end&&e.end({type:"end",scrollBar:t,elText:e.el,scale:parseInt(a.style.left)/382}),document.onmousemove=null,document.onmouseup=null}}}destroy(){this.root.parentNode.removeChild(this.root),this.slice=null,this.opt=null}}}(ZMapVolume||(ZMapVolume={})),function(e){let t;!function(e){e[e.XOY=2]="XOY",e[e.YOZ=0]="YOZ",e[e.XOZ=1]="XOZ"}(t=e.SlicePlane||(e.SlicePlane={}));class i extends e.VolumeBiningable{constructor(e,t){super(e);this.opt=Object.assign({sliceSize:20},t),this.blongElement=t.blongElement,this._planes=[{offset:.5,points:null,entity:null},{offset:.5,points:null,entity:null},{offset:.5,points:null,entity:null}],this.opt.style&&(this.style=this.opt.style)}get style(){return this._entityTool.getDefault()}set style(e){this._entityTool.defaultOpt=e,this.destroy(),this.update(this._box)}init(){e.SliceControl&&!this.sliceControl&&(this.sliceControl=new e.SliceControl(this,this.blongElement||null,this.opt));const t=e=>this._entityTool.addPloyline(new Cesium.CallbackProperty(e,!1));for(let e=0;e<3;++e){const i=this._planes[e];i.points=this._getPlanePoints(e,i.offset),i.entity=t(()=>i.points)}this.onShowChanged(this.show)}update(e){this._box=e,this.destroy(),this.init()}clean(){}destroy(){this._planes.forEach(e=>{e.entity&&this._viewer.entities.remove(e.entity)})}get control(){return this.sliceControl}set control(e){this.sliceControl.destroy(),this.sliceControl=e}_getPlanePoints(i,n){const{xmin:s,ymin:o,zmin:a,xmax:r,ymax:l,zmax:h}=this._box,_=a+(h-a)*n,c=s+(r-s)*n,m=o+(l-o)*n,u=this.opt.sliceSize;switch(i){case t.XOY:return Cesium.Cartesian3.fromDegreesArrayHeights([s,o,_,...e.ConvertTool.expansion([s,l,_],[r,l,_],u),...e.ConvertTool.expansion([r,o,_],[s,o,_],u)]);case t.YOZ:return Cesium.Cartesian3.fromDegreesArrayHeights([c,o,a,...e.ConvertTool.expansion([c,o,h],[c,l,h],u),...e.ConvertTool.expansion([c,l,a],[c,o,a],u)]);case t.XOZ:return Cesium.Cartesian3.fromDegreesArrayHeights([s,m,a,...e.ConvertTool.expansion([s,m,h],[r,m,h],u),...e.ConvertTool.expansion([r,m,a],[s,m,a],u)])}}set offset(e){this._planes.forEach((t,i)=>{t.offset=Cesium.Math.clamp(e[i],0,1),t.points=this._getPlanePoints(i,t.offset)}),this._vol&&this._vol.setSlice({z:this._planes[t.XOY].offset,y:this._planes[t.XOZ].offset,x:this._planes[t.YOZ].offset})}onShowChanged(e){if(this._planes.forEach(t=>{t.entity&&(t.entity.show=e)}),this.sliceControl){this.sliceControl.root.style.visibility=e?"visible":"hidden"}}showPlane(e,t){const i=this._planes[e];i&&(i.entity.show=t)}}e.SliceTool=i}(ZMapVolume||(ZMapVolume={})),ZMapVolume.Shaders.vertexShader="varying vec4 worldPos;\n\nattribute float batchId;\nattribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_normal2;\n\nvec4 czm_translateRelativeToEye2(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n    return vec4(highDifference + lowDifference, 1.0);\n}\n\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye2(position3DHigh, position3DLow);\n\n    ///\n    vec3 pos = position3DHigh + position3DLow;\n    worldPos = czm_model * vec4(pos, 1.0);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_normal2 = normal;\n\n    ///\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}",ZMapVolume.Shaders.fragmentShader="\n\n\nvoid main( void ) \n{\n    doZMapRender();\n}             \n",ZMapVolume.Shaders.materialShader="\n\nprecision highp float;\n\n/// 顶点的世界坐标\nvarying vec4 worldPos;\n\n/// \nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_normal2;\n\n/// uniforms\n// 体纹理，使用二维纹理替代\nuniform sampler2D u_CubeTex;\n// 色表\nuniform sampler2D u_ColorTex;\n// 逆矩阵\nuniform mat4 u_InvWorldMat;\n\n// 提数据的空间范围\nuniform vec3 u_VolBoxMin;\nuniform vec3 u_VolBoxMax;\n// 体纹理的有效区域（动态裁剪）\nuniform vec3 u_VolClipMin;\nuniform vec3 u_VolClipMax;\n// 提数据的包围球半径\nuniform float u_VolBoxRadius;\n// 属性过滤\nuniform mat4 u_VolFilterLine;\n\n/// 切片列数\nuniform float u_SliceNumXf;\n/// 切片行数\nuniform float u_SliceNumYf;\n\n/// 翻转参数\nuniform vec3 u_Turn;\nuniform vec2 u_DataValueRange;\n\n/// 体数据的尺寸\nvec3 c_VolBoxSize;\n\n/// 采样次数\nconst int MAX_STEPS = ZMAP_VOL_SAMPLE_NUM;\n/// \nconst float alphaCorrection = 1.0;\n\n/// 切片层数\nfloat SliceCountf = 0.0;\n\n/// 切片的宽高\nfloat SliceWidth = 0.0;\nfloat SliceHeight = 0.0;\n\n\n/// 属性过滤器\nvec2 filter_line[8];\nvoid initGlobeVars()\n{\n    /// 切片层数\n    SliceCountf = u_SliceNumXf * u_SliceNumYf;\n\n    /// 切片的宽高\n    SliceWidth  = 1.0 / u_SliceNumXf;\n    SliceHeight = 1.0 / u_SliceNumYf;\n\n    ///\n    filter_line[0] = vec2(u_VolFilterLine[0][0],u_VolFilterLine[0][1]);\n    filter_line[1] = vec2(u_VolFilterLine[0][2],u_VolFilterLine[0][3]);\n    filter_line[2] = vec2(u_VolFilterLine[1][0],u_VolFilterLine[1][1]);\n    filter_line[3] = vec2(u_VolFilterLine[1][2],u_VolFilterLine[1][3]);\n    filter_line[4] = vec2(u_VolFilterLine[2][0],u_VolFilterLine[2][1]);\n    filter_line[5] = vec2(u_VolFilterLine[2][2],u_VolFilterLine[2][3]);\n    filter_line[6] = vec2(u_VolFilterLine[3][0],u_VolFilterLine[3][1]);\n    filter_line[7] = vec2(u_VolFilterLine[3][2],u_VolFilterLine[3][3]);\n}\n\n/// 应用属性过滤\nfloat doFilter(float value)\n{\n    float k,b;\n\n    float x = value;\n    vec2 point0 = vec2(0.0, 0.0);\n    for(int i = 0;i < 8; i++)\n    {\n        vec2 point1 = filter_line[i];\n        if(x < point1.x)\n        {\n            k = (point1.y - point0.y) / (point1.x - point0.x);\n            b = point1.y - k * point1.x;\n            value = k * x + b;\n            break;\n        }\n\n        ///\n        point0 = point1;\n    }\n\n    ///\n    return value;\n}\n\nbool doVolClip(vec3 texCoord)\n{\n    return any(greaterThan(texCoord, u_VolClipMax)) || any(lessThan(texCoord, u_VolClipMin));\n}\n\n// Z方向-256层体数据变为64层体数据\nfloat readVolDataValue(vec3 texCoord)\n{\n    /// 翻转\n    texCoord = texCoord * (vec3(1.0,1.0,1.0) - u_Turn) + (vec3(1.0,1.0,1.0) - texCoord) * u_Turn;\n\n    /// 计算在第几个切片，加0.5便于计算\n    float slice = texCoord.z * SliceCountf + 0.5;\n    float slice_int = floor(slice);\n    float slice_dot = slice - slice_int;\n\n    ///\n    float slice_n1 = slice_int - 1.0, slice_n2 = slice_int;\n    if (slice_int == 0.0) slice_n1 = 0.0;\n    if (slice_int == SliceCountf) slice_n2 = SliceCountf - 1.0;\n\n    //The Z slices are stored in a matrix of 16x16 of Z slices.\n    //The original UV coordinates have to be rescaled by the tile numbers in each row and column.\n    texCoord.x /= u_SliceNumXf;\n    texCoord.y /= u_SliceNumYf;\n\n    ///\n    vec2 texcoord1 = texCoord.xy;\n    vec2 texcoord2 = texCoord.xy;\n    //Add an offset to the original UV coordinates depending on the row and column number.\n    texcoord1.x += mod(slice_n1, u_SliceNumXf) * SliceWidth;\n    texcoord1.y += (u_SliceNumYf - floor(slice_n1 / u_SliceNumXf) - 1.0) * SliceHeight;\n\n    texcoord2.x += mod(slice_n2, u_SliceNumXf) * SliceWidth;\n    texcoord2.y += (u_SliceNumYf - floor(slice_n2 / u_SliceNumXf) - 1.0) * SliceHeight;\n\n    /// 分别在两个切片上进行纹理采样\n    vec4 v1 = texture2D(u_CubeTex, texcoord1);\n    vec4 v2 = texture2D(u_CubeTex, texcoord2);\n\n    /// 混合上下两个值\n    float value = mix(v1.r, v2.r, slice_dot);\n    value = (value - u_DataValueRange[0]) / (u_DataValueRange[1] - u_DataValueRange[0]);\n    return clamp(value, 0.0, 1.0);\n}\n\nvec4 readColorTable(float v)\n{\n    /// 对色表进行采样\n    return texture2D(u_ColorTex, vec2(v, 1.0));\n}\n\n/// 三维坐标转纹理坐标（经纬度），计算结果比较准确，计算量比较大\nconst vec3 c_BoxTexMin = vec3(0.0,0.0,0.0);\nconst vec3 c_BoxTexMax = vec3(1.0,1.0,1.0);\n\nconst float WGS84EllipsoidA = 6378137.0;\nconst float WGS84EllipsoidB = 6356752.314245179;\n\n#if 1\n\n/// 椭球体\nvec3 xyz2lnlt(vec3 xyz)\n{\n    float X = xyz.x;\n    float Y = xyz.y;\n    float Z = xyz.z;\n    const float a = WGS84EllipsoidA;\n    const float b = WGS84EllipsoidB;\n    float er = sqrt(X * X + Y * Y);\n    float e1 = (a * a - b * b) / (a * a);\n    float e2 = (a * a - b * b) / (b * b);\n    float th = atan((Z * a) / (er * b));\n\n    float sinth3 = pow(sin(th), 3.0);\n    float costh3 = pow(cos(th), 3.0);\n\n    float L = atan(Y, X);\n    float B = atan((Z + e2 * b * sinth3) / (er - e1 * a * costh3));\n    float sinB = sin(B);\n    float cosB = cos(B);\n    float N = a / sqrt(1.0 - e1 * sinB * sinB);\n    float H = er / cosB - N;\n\n    return vec3(degrees(L),degrees(B),H);\n}\n#else \n\n/// 正求体\nvec3 xyz2lnlt(vec3 xyz)\n{\n    float radius = length(xyz);\n    float lon = atan(xyz.y, xyz.x);\n    float lat = asin(xyz.z / radius);\n\n    return vec3(degrees(lon), degrees(lat), radius - WGS84EllipsoidA);\n}\n#endif\n\n/// 单次体绘制\nvec4 doVolOnceRender(vec3 texCoord, vec4 acc, int i)\n{\n    if (doVolClip(texCoord)) return acc;\n\n    ///\n    float p = float(i) / float(MAX_STEPS);\n    //return vec4(1,0,0,p);\n\n    //Get the voxel intensity value from the 3D texture.    \n    float volValue = readVolDataValue(texCoord);\n    vec4 colorSample = readColorTable(volValue);\n    float alphaSample = doFilter(volValue) * colorSample.a;\n    \n    //Allow the alpha correction customization\n    alphaSample = alphaSample * alphaCorrection;\n\n    //Perform the composition.\n#if ZMAP_VOL_RAY_DIR == ZMAP_VOL_RAY_FORWARD\n    acc.rgb = acc.rgb * acc.a + (1.0 - acc.w) * colorSample.rgb;\n#else \n    acc.rgb = acc.rgb * (1.0-alphaSample) + colorSample.rgb * alphaSample;\n#endif\n    \n    //Store the alpha accumulated so far.\n    acc.a = 1.0 - (1.0 - acc.a) * (1.0 - alphaSample);\n\n    /// \n    return acc;\n}\n\nvec4 doPhong(vec3 positionToEyeEC, vec3 normalEC, vec4 color)\n{\n    czm_material material;\n    material.diffuse = color.rgb;\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = normalize(normalEC);\n    material.emission = vec3(0.0);\n    material.alpha = color.a;\n\n    ///\n    return czm_phong(normalize(-positionToEyeEC), material);\n}\n\nvec4 doSliceRender(vec3 texCoord)\n{\n    /// \n    if (doVolClip(texCoord)) discard;\n\n    ///\n    float value = readVolDataValue(texCoord);\n    vec4 color = readColorTable(value);\n    float alpha = doFilter(value) * color.a;\n\n    ///\n    //return vec4(alpha, 1.0, 1.0, 1.0);\n    alpha = alpha > 0.5 ? 1.0 : 0.0;\n    if (alpha == 0.0) discard;\n    \n    color.a = 1.0;\n\n    ///\n    //return vec4(v_normal2, 1.0);\n    //return color;\n    return doPhong(v_positionEC, v_normalEC, color);\n}\n\n\n#if ZMAP_MODE == ZMAP_RENDER_MODE_GLOBE_VOLUME\n\n#if ZMAP_GLOBEV2\n\n    /// 体绘制模式\n    void doVolRender()\n    {\n        vec3 texCoord = v_normal2;\n\n        /// \n        if (doVolClip(texCoord)) discard;\n\n        ///\n        float value = readVolDataValue(texCoord);\n        vec4 color = readColorTable(value);\n        color.a = doFilter(value) * color.a;\n\n        ///\n        gl_FragColor = color;\n    }\n#else\n\n    /// 体绘制模式\n    void doVolRender()\n    {\n        vec3 dir = worldPos.xyz - czm_viewerPositionWC.xyz ; \n        float delta = u_VolBoxRadius * 2.0 / float(MAX_STEPS);\n        vec3 deltaDirection = normalize(dir) * delta;\n\n        vec3 currentPosition = worldPos.xyz;\n        vec4 acc = vec4(0.0, 0.0, 0.0, 0.0);\n\n    #if ZMAP_VOL_RAY_DIR == ZMAP_VOL_RAY_FORWARD\n        currentPosition = currentPosition - deltaDirection * float(MAX_STEPS);\n    #endif\n        \n        ///\n        for (int i = 0; i < MAX_STEPS; ++i)\n        {\n            vec3 geo = xyz2lnlt(currentPosition);\n            geo = (geo - u_VolBoxMin) / c_VolBoxSize;\n\n            ///\n            acc = doVolOnceRender(geo, acc, i);\n            \n            //Advance the ray.\n    #if ZMAP_VOL_RAY_DIR == ZMAP_VOL_RAY_FORWARD\n            currentPosition += deltaDirection;\n            //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.\n            if (acc.w > 1.0) break;\n    #else\n            currentPosition -= deltaDirection;\n    #endif\n        }\n\n        ///\n        gl_FragColor = acc;\n    }\n#endif\n\n\n\n#elif ZMAP_MODE == ZMAP_RENDER_MODE_BOX_VOLUME\n\n    /// 立方体绘制方式\n    void doVolRender()\n    {\n        vec4 locPos = u_InvWorldMat * worldPos;\n        vec4 locViewerPositionWC = u_InvWorldMat * vec4(czm_viewerPositionWC, 1.0);\n        vec3 dir = locPos.xyz - locViewerPositionWC.xyz; \n\n        ///\n        float delta = 1.732 / float(MAX_STEPS);\n        vec3 deltaDirection = normalize(dir / c_VolBoxSize) * delta;\n        \n        ///\n        vec3 currentPosition = (locPos.xyz - u_VolBoxMin) / c_VolBoxSize;\n        vec4 acc = vec4(0.0, 0.0, 0.0, 0.0);\n\n    #if ZMAP_VOL_RAY_DIR == ZMAP_VOL_RAY_FORWARD\n        currentPosition = currentPosition - deltaDirection * float(MAX_STEPS);\n    #endif\n\n        ///\n        for(int i = 0; i < MAX_STEPS; i++)\n        {\n            ///\n            acc = doVolOnceRender(currentPosition, acc, i);\n            \n            ///\n    #if ZMAP_VOL_RAY_DIR == ZMAP_VOL_RAY_FORWARD\n            currentPosition += deltaDirection;\n            //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.\n            if (acc.w > 1.0) break;\n    #else\n            //Advance the ray.\n            currentPosition -= deltaDirection;\n    #endif\n        }\n\n        ///\n        gl_FragColor = acc;\n    }\n\n#elif ZMAP_MODE == ZMAP_RENDER_MODE_GLOBE_SLICE\n\n    /// 切面绘制模式\n    void doVolRender()\n    {\n        vec3 geo = xyz2lnlt(worldPos.xyz);\n        geo = (geo - u_VolBoxMin) / c_VolBoxSize;\n\n        ///\n        gl_FragColor = doSliceRender(geo);\n    }\n\n#elif ZMAP_MODE == ZMAP_RENDER_MODE_BOX_SLICE\n\n    void doVolRender()\n    {\n        vec4 locPos = u_InvWorldMat * worldPos;\n\n        ///\n        vec3 texCoord = (locPos.xyz - u_VolBoxMin) / c_VolBoxSize;\n        texCoord = clamp(texCoord, c_BoxTexMin, c_BoxTexMax);\n\n        ///\n        gl_FragColor = doSliceRender(texCoord);\n    }\n\n#endif\n\nvoid doDebugRender()\n{\n    vec3 currentPosition = worldPos.xyz;\n        \n    vec4 colorSample;\n    float accumulatedAlpha = 0.0;\n\n    vec3 geo = xyz2lnlt(currentPosition);\n    geo = (geo - u_VolBoxMin) / c_VolBoxSize;\n\n    gl_FragColor = vec4(geo, 0.5);\n}\n\nvoid doZMapRender( void ) \n{\n    c_VolBoxSize = u_VolBoxMax - u_VolBoxMin;\n\n    /// 初始化过滤器\n    initGlobeVars();\n\n    /// \n    doVolRender();\n}             \n";

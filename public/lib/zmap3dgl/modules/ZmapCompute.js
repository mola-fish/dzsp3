export default class{constructor(e){this.viewer=e,this.czviewer=e._czdata.viewer}getendpt(e,t){const{viewer:i,czviewer:r}=this;var a=r.camera.getPickRay(e);if(null==t){const t=r.scene.pickPosition(e);return t&&Cesium.Cartographic.fromCartesian(t).height>0?t:r.scene.globe.pick(a,r.scene)}var s=r.scene.globe.ellipsoid.radii.clone(),n=t;s.x+=n,s.y+=n,s.z+=n;var h=new Cesium.Ellipsoid(s.x,s.y,s.z),o=Cesium.IntersectionTests.rayEllipsoid(a,h);return o?Cesium.Ray.getPoint(a,o.start):new Cesium.Cartesian3}getCircleLinepoints(e,t,i=360){t/=6371e3;for(var r=[],a=0;a<i;a++){var s=2*a*Math.PI/i,n=this.getCirclePoint(e,s,t);r.push(n)}return r}getCirclePoint(e,t,i){var r=Math.sin(e.latitude),a=Math.cos(e.latitude),s=Math.sin(i),n=Math.cos(i),h=Math.sin(t),o=Math.cos(t),u=Math.asin(r*n+a*s*o),g=e.longitude+Math.atan2(h*s*a,n-r*Math.sin(u));return Cesium.Cartographic.toCartesian(new Cesium.Cartographic(g,u,e.height))}getHeightestByRay(e,t){const{viewer:i,czviewer:r}=this;e=Cesium.Cartographic.fromCartesian(e);for(var a=[t=Cesium.Cartographic.fromCartesian(t)],s=[e.longitude],n=[e.latitude],h=[e.height],o=0;o<100;o++){s[o+1]=Cesium.Math.lerp(e.longitude,t.longitude,.01*(o+1)),n[o+1]=Cesium.Math.lerp(e.latitude,t.latitude,.01*(o+1)),h[o+1]=Cesium.Math.lerp(e.height,t.height,.01*(o+1));var u=new Cesium.Cartographic(s[o+1],n[o+1],h[o+1]),g=r.scene.globe.getHeight(u);g>a[0].height?a=[new Cesium.Cartographic(s[o+1],n[o+1],g)]:g==a[0].height&&a.push(new Cesium.Cartographic(s[o+1],n[o+1],g))}return a}calcLines(e,t){const{viewer:i,czviewer:r}=this;for(var a=[e],s=[e.longitude],n=[e.latitude],h=[e.height],o=!0,u=0;u<100;u++){s[u+1]=Cesium.Math.lerp(e.longitude,t.longitude,.01*(u+1)),n[u+1]=Cesium.Math.lerp(e.latitude,t.latitude,.01*(u+1)),h[u+1]=Cesium.Math.lerp(e.height,t.height,.01*(u+1));var g=new Cesium.Cartographic(s[u+1],n[u+1],h[u+1]),c=r.scene.globe.getHeight(g);h[u+1]>c^1==o&&(o=!o,a.push(g))}return a}async getTV(e){const t=await axios.get(url,{responseType:"arraybuffer"}),i=new Float64Array(t.data);return new TerrainView(e,i)}async pots2tv(e){const t=getRectangle(e);return this.getTV(t)}}class TerrainView{constructor(e,t){this.rectangle=e,this.buffer=t}getHeight(e){if(!(e instanceof Cegore.Position))throw new TypeError("坐标类型异常！");const t=this.pos2index(e);return this.buffer[t]}pos2index(e){const t=Math.ceil(size[0]*(e.x-this.rectangle.west)/(this.rectangle.east-this.rectangle.west)),i=Math.ceil(size[1]*(e.y-this.rectangle.south)/(this.rectangle.north-this.rectangle.south))*size[0]+t-1;return i>=0?i:0}}function getRectangle(e){for(var t=e[0].x<e[1].x?e[0].x:e[1].x,i=e[0].y<e[1].y?e[0].y:e[1].y,r=e[0].x>e[1].x?e[0].x:e[1].x,a=e[0].y>e[1].y?e[0].y:e[1].y,s=0;s<e.length;s++)s<2||(e[s].x>r&&(r=e[s].x),e[s].x<t&&(t=e[s].x),e[s].y>a&&(a=e[s].y),e[s].y<i&&(i=e[s].y));return{west:t,south:i,east:r,north:a}}function isInnerPoint(e,t,i){i||(e=new Cegore.Position(Cesium.Math.toDegrees(e.longitude),Cesium.Math.toDegrees(e.latitude)));var r,a,s,n=t,h=e.x,o=e.y,u=0,g=0,c=0,l=0;if(n.length<3)return!1;for(r=0,a=n.length,s=0;s<a;s++){var C=s+1;C>=a&&(C=0),u=n[s].x,c=n[s].y,g=n[C].x,l=n[C].y,(o>=c&&o<l||o>=l&&o<c)&&Math.abs(c-l)>0&&u-(u-g)*(c-o)/(c-l)<h&&r++}return r%2!=0}